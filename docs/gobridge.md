# Go Bridge — Developer Reference

The Go Bridge allows Rugo scripts to call Go standard library functions
directly via the `import` keyword. Bridge packages are auto-generated by
`rugo dev bridgegen` and hand-curated where needed.

## Architecture

```
Rugo source:    import "strings"
                x = strings.to_upper("hello")
                    │
                    ▼
Compiler:       resolveRequires() validates package is registered
                    │
                    ▼
Codegen:        generateGoBridgeCall() produces:
                  interface{}(strings.ToUpper(rugo_to_string(x)))
                    │
                    ▼
Generated Go:   Direct Go stdlib call — no wrapper struct, no runtime
```

### File Convention

| Pattern | Role |
|---------|------|
| `*_gen.go` | Auto-generated by `rugo dev bridgegen`. Always overwritten. |
| `*_custom.go` | Hand-written. Uses `Extend()` for aliases, `Codegen` callbacks, runtime helpers. Never touched by bridgegen. |
| `helpers/*.go` | Runtime helper source files (real Go, `//go:build ignore`). Embedded via `//go:embed` — no string literals. |
| `gobridge.go` | Core types, registry API, conversion helpers. |
| `helpers_embed.go` | `//go:embed` directives loading helper source files. |
| `source_embed.go` | Embeds all `.go` files for the Rugo build cache. |

### Key Compiler Files

| File | Role |
|------|------|
| `compiler/compiler.go` | `resolveRequires()` — validates + deduplicates `import` statements |
| `compiler/codegen.go` | `generateGoBridgeCall()` — emits Go code with type conversions |
| `cmd/dev/bridgegen.go` | `rugo dev bridgegen` — auto-generates bridge packages via `go/types` |
| `ast/preprocess.go` | `import` keyword + array destructuring desugaring |
| `parser/rugo.ebnf` | Grammar: `ImportStmt = "import" str_lit ["as" ident] .` |

### `use` vs `import`

| | `use` (Rugo modules) | `import` (Go bridge) |
|--|---|---|
| **Mechanism** | Hand-crafted Go structs, embedded as runtime strings | Static registry → direct Go function calls |
| **Generated code** | `rugo_mod_func(arg1, arg2)` wrapper | `strings.ToUpper(rugo_to_string(arg))` direct call |
| **Adding functions** | Write Go struct + methods in `runtime.go` | Run `rugo dev bridgegen <pkg>` or add to `_custom.go` |

## Type System

All Rugo values are `interface{}`. The bridge converts at call boundaries:

```go
GoString      // string ↔ string       — rugo_to_string(arg)
GoInt         // int ↔ int             — rugo_to_int(arg)
GoFloat64     // float ↔ float64       — rugo_to_float(arg)
GoBool        // bool ↔ bool           — rugo_to_bool(arg)
GoByte        // int ↔ byte            — byte(rugo_to_int(arg))
GoStringSlice // array ↔ []string      — rugo_go_to_string_slice(arg)
GoByteSlice   // string ↔ []byte       — []byte(rugo_to_string(arg))
GoInt32       // int ↔ int32           — int32(rugo_to_int(arg))
GoInt64       // int ↔ int64           — int64(rugo_to_int(arg))
GoUint32      // int ↔ uint32          — uint32(rugo_to_int(arg))
GoUint64      // int ↔ uint64          — uint64(rugo_to_int(arg))
GoUint        // int ↔ uint            — uint(rugo_to_int(arg))
GoFloat32     // float ↔ float32       — float32(rugo_to_float(arg))
GoRune        // string ↔ rune         — rugo_first_rune(rugo_to_string(arg))
GoFunc        // lambda ↔ func(T)R     — adapter wrapping (see FuncTypes)
GoDuration    // int (ms) ↔ Duration   — time.Duration(n) * time.Millisecond
GoError       // panic ↔ error         — return-only, auto-panics on non-nil
```

Return conversions wrap Go values back to `interface{}`:
- Most types: `interface{}(goValue)`
- Narrowing types (int32, int64, uint*, float32): cast back to `int` or `float64`
- `GoByteSlice`: `string(goValue)` — bytes are strings in Rugo
- `GoRune`: `string(r)` with zero-rune → empty string
- `GoDuration`: `int(d / time.Millisecond)` — always milliseconds
- `GoStringSlice`: `rugo_go_from_string_slice(v)` → `[]interface{}`

## Function Signature

Each bridged function is described by `GoFuncSig`:

```go
type GoFuncSig struct {
    GoName       string              // PascalCase name or method chain ("StdEncoding.EncodeToString")
    Params       []GoType
    Returns      []GoType
    FuncTypes    map[int]*GoFuncType  // lambda adapter signatures for GoFunc params
    StructReturn *GoStructReturn      // struct → hash decomposition metadata
    ArrayTypes   map[int]*GoArrayType // fixed-size array [N]T → slice metadata
    TypeCasts    map[int]string       // named type casts ("os.FileMode")
    Variadic     bool
    Doc          string
    Codegen      CodegenFunc          // override for custom code generation
    RuntimeHelpers []RuntimeHelper    // Go helper functions to emit
}
```

### Return Pattern Handling

| Pattern | Codegen strategy |
|---------|-----------------|
| `()` void | IIFE: `func() interface{} { call; return nil }()` |
| `(T)` | `interface{}(call)` |
| `(error)` | IIFE with panic on non-nil error |
| `(T, error)` | IIFE: panic on error, return T |
| `(T, bool)` | IIFE: return nil if false, T if true |
| `(T1, T2, ...)` | IIFE: collect into `[]interface{}` array |

Multi-return functions return arrays that can be destructured:

```ruby
before, after, found = strings.cut("key=value", "=")
```

### Metadata Features

**FuncTypes** — Lambda-to-Go-func adapter. When a param is `GoFunc`, the
`FuncTypes` map describes the Go function signature so the codegen can wrap
a Rugo lambda:

```go
"contains_func": {Params: []GoType{GoString, GoFunc}, Returns: []GoType{GoBool},
    FuncTypes: map[int]*GoFuncType{1: {Params: []GoType{GoRune}, Returns: []GoType{GoBool}}}}
```

**StructReturn** — Declarative struct-to-hash decomposition:

```go
"parse": {Params: []GoType{GoString}, Returns: []GoType{GoString, GoError},
    StructReturn: &GoStructReturn{Pointer: true, Fields: []GoStructField{
        {GoField: "Scheme", RugoKey: "scheme", Type: GoString},
        {GoField: "Hostname", RugoKey: "hostname", Type: GoString, IsMethod: true},
    }}}
```

**ArrayTypes** — Fixed-size array returns. Codegen slices `[N]T → []T`:

```go
"sum256": {Params: []GoType{GoByteSlice}, Returns: []GoType{GoByteSlice},
    ArrayTypes: map[int]*GoArrayType{0: {Elem: GoByte, Size: 32}}}
```

**TypeCasts** — Named Go type casts for params:

```go
"mkdir_all": {Params: []GoType{GoString, GoInt}, Returns: []GoType{GoError},
    TypeCasts: map[int]string{1: "os.FileMode"}}
```

## Adding a New Go Package

### Automated (recommended)

```bash
rugo dev bridgegen <go-package>     # generates _gen.go + smoke tests
make bridgegen                       # regenerate all packages
```

This generates `gobridge/<pkg>_gen.go` with all auto-bridgeable functions
and `rats/gobridge/auto/<pkg>_gen_test.rugo` with smoke tests.

### Adding custom functions

Create `gobridge/<pkg>_custom.go` using `Extend()`:

```go
package gobridge

func init() {
    Extend("encoding/hex", map[string]GoFuncSig{
        "encode": {GoName: "EncodeToString", Params: []GoType{GoByteSlice},
                   Returns: []GoType{GoString}, Doc: "Encodes to hex."},
    })
}
```

`Extend()` merges into the package registered by `_gen.go`. Init order is
handled automatically — either file can load first.

### Runtime helpers

For packages needing custom Go helper functions (generics workarounds, deep
type conversion), write the helpers as real Go files in `gobridge/helpers/`:

```go
//go:build ignore

package helpers

func rugo_my_helper(v interface{}) interface{} {
    // implementation
}
```

Embed in `helpers_embed.go` and reference from `_custom.go`:

```go
var myHelpers = []RuntimeHelper{helperFromFile("rugo_my_helpers", myHelperSrc)}
```

Helpers are deduplicated by key and emitted once into generated code.
Core helpers (`rugo_first_rune`, `rugo_go_to_string_slice`) are auto-emitted
when the corresponding GoType is used — no RuntimeHelpers declaration needed.

### Packages using NoGoImport

For packages implemented entirely via runtime helpers (Go generics, etc.):

```go
Register(&Package{
    Path:         "slices",
    NoGoImport:   true,
    ExtraImports: []string{"sort"},
    Funcs: map[string]GoFuncSig{ ... },
})
```

### Verifying codegen

```bash
echo 'import "strings"
puts strings.to_upper("hello")' > /tmp/test.rugo
bin/rugo emit /tmp/test.rugo
```

## Bridgegen Classification

`rugo dev bridgegen --dry-run <pkg>` classifies each function:

| Tier | Meaning | Marker |
|------|---------|--------|
| auto | All params/returns are basic Go types | ✓ |
| castable | Needs numeric casts, []byte, rune, func adapters | ~ |
| func | Has function params with unbridgeable inner signatures | λ |
| blocked | Generics, interfaces, channels, complex structs | ✗ |

Bridgegen generates code for `auto` and `castable` tiers. `func` tier is
generated when the inner function signature is bridgeable (emits `FuncTypes`).
`blocked` functions are listed as comments in the generated file.

The classifier also enumerates methods on exported package-level variables
(e.g., `base64.StdEncoding.EncodeToString`), using dot-notation GoNames.

## Custom Codegen Catalog

These packages require `_custom.go` with `Codegen` callbacks:

| Package | Reason |
|---------|--------|
| `encoding/json` | Deep `map[interface{}]interface{}` ↔ `map[string]interface{}` recursive conversion |
| `slices` | Go generics — pure runtime helpers, `NoGoImport` |
| `maps` | Go generics — pure runtime helpers, `NoGoImport` |
| `sort` | In-place mutation via `sort.Slice` + `rugo_compare` |

Convenience aliases (curated short names) in `_custom.go`:

| Package | Alias | Maps to |
|---------|-------|---------|
| `encoding/base64` | `encode` | `StdEncoding.EncodeToString` |
| `encoding/base64` | `decode` | `StdEncoding.DecodeString` |
| `encoding/base64` | `url_encode` | `URLEncoding.EncodeToString` |
| `encoding/base64` | `url_decode` | `URLEncoding.DecodeString` |
| `encoding/hex` | `encode` | `EncodeToString` |
| `encoding/hex` | `decode` | `DecodeString` |
| `math/rand/v2` | `n` | `IntN` |

## Import Deduplication

The codegen tracks `emittedImports` to prevent duplicate Go import statements:

1. **Base imports** always emitted: `fmt`, `os`, `os/exec`, `runtime/debug`, `strings`
2. **Rugo module imports** (from `use`): e.g., `use "conv"` adds `strconv`
3. **Go bridge imports** (from `import`): added last, skipped if already emitted
4. **Aliased imports**: always emitted even if the bare path exists

## Namespace Conflict Detection

| Conflict | Error |
|----------|-------|
| `use "os"` + `import "os"` | Must alias: `import "os" as go_os` |
| `require "x" as "os"` + `use "os"` | Require alias conflicts with use'd module |
| `require "x" as "strings"` + `import "strings"` | Require alias conflicts with Go bridge |

## Test Coverage

Tests are split into hand-written and auto-generated:

- `rats/gobridge/*.rugo` — Hand-written behavioral tests (175 tests)
- `rats/gobridge/auto/*_gen_test.rugo` — Auto-generated smoke tests (291 tests)

Auto-generated tests verify every function is callable with correct arg
types and returns the expected Rugo type. They are regenerated by
`make bridgegen` alongside the bridge code.

Run all: `make rats` or `bin/rugo rats rats/gobridge/`
