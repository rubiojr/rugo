# RATS: Test require for Go modules
# require can transparently load Go packages with bridgeable exported functions
use "test"
use "conv"
use "str"

rats "require Go module loads bridgeable functions"
  tmpdir = test.tmpdir()
  test.run("cp -r rats/fixtures/go_module_basic #{tmpdir}/go_module_basic")
  script = <<~SCRIPT
    require "go_module_basic"
    puts(gomod_basic.greet("world"))
  SCRIPT
  test.write_file("#{tmpdir}/main.rugo", script)
  result = test.run("rugo run #{tmpdir}/main.rugo")
  test.assert_eq(result["status"], 0)
  test.assert_eq(result["output"], "hello, world")
end

rats "require Go module supports int params and returns"
  tmpdir = test.tmpdir()
  test.run("cp -r rats/fixtures/go_module_basic #{tmpdir}/go_module_basic")
  script = <<~SCRIPT
    require "go_module_basic"
    puts(gomod_basic.add(3, 4))
  SCRIPT
  test.write_file("#{tmpdir}/main.rugo", script)
  result = test.run("rugo run #{tmpdir}/main.rugo")
  test.assert_eq(result["status"], 0)
  test.assert_eq(result["output"], "7")
end

rats "require Go module with as alias"
  tmpdir = test.tmpdir()
  test.run("cp -r rats/fixtures/go_module_basic #{tmpdir}/go_module_basic")
  script = <<~SCRIPT
    require "go_module_basic" as gm
    puts(gm.upper("hello"))
  SCRIPT
  test.write_file("#{tmpdir}/main.rugo", script)
  result = test.run("rugo run #{tmpdir}/main.rugo")
  test.assert_eq(result["status"], 0)
  test.assert_eq(result["output"], "HELLO")
end

rats "require Go module build produces working binary"
  tmpdir = test.tmpdir()
  test.run("cp -r rats/fixtures/go_module_basic #{tmpdir}/go_module_basic")
  script = <<~SCRIPT
    require "go_module_basic"
    puts(gomod_basic.greet("binary"))
    puts(gomod_basic.add(10, 20))
  SCRIPT
  test.write_file("#{tmpdir}/main.rugo", script)
  build_result = test.run("rugo build #{tmpdir}/main.rugo -o #{tmpdir}/main_bin")
  test.assert_eq(build_result["status"], 0)
  result = test.run("#{tmpdir}/main_bin")
  test.assert_eq(result["status"], 0)
  lines = result["lines"]
  test.assert_eq(lines[0], "hello, binary")
  test.assert_eq(lines[1], "30")
end

rats "require Go module fails on non-Go non-Rugo directory"
  tmpdir = test.tmpdir()
  test.run("mkdir -p #{tmpdir}/emptymod")
  test.write_file("#{tmpdir}/emptymod/readme.txt", "not a module")
  script = <<~SCRIPT
    require "emptymod"
    puts("should not reach here")
  SCRIPT
  test.write_file("#{tmpdir}/main.rugo", script)
  result = test.run("rugo run #{tmpdir}/main.rugo")
  test.assert_neq(result["status"], 0)
  test.assert_contains(result["output"], "emptymod")
  test.assert_contains(result["output"], "no Rugo source files")
end

rats "require Go module error does not leak cache paths"
  tmpdir = test.tmpdir()
  test.run("mkdir -p #{tmpdir}/badmod")
  test.write_file("#{tmpdir}/badmod/go.mod", "module example.com/badmod\n\ngo 1.22\n")
  test.write_file("#{tmpdir}/badmod/badmod.go", "package badmod\ntype Foo struct{}\nfunc New() *Foo { return &Foo{} }\n")
  script = <<~SCRIPT
    require "badmod"
  SCRIPT
  test.write_file("#{tmpdir}/main.rugo", script)
  result = test.run("rugo run #{tmpdir}/main.rugo")
  test.assert_neq(result["status"], 0)
  test.assert_contains(result["output"], "example.com/badmod")
  test.assert_contains(result["output"], "no bridgeable functions")
  # The module error must use go.mod path, not a cache/local directory path
  test.assert_eq(str.contains(result["output"], "badmod/badmod.go"), false)
end

rats "require Go module namespace conflicts with use'd stdlib module"
  tmpdir = test.tmpdir()
  test.run("mkdir -p #{tmpdir}/mymod/os")
  test.write_file("#{tmpdir}/mymod/go.mod", "module example.com/mymod\n\ngo 1.22\n")
  test.write_file("#{tmpdir}/mymod/mymod.go", "package mymod\nfunc Hello() string { return \"hi\" }\n")
  test.write_file("#{tmpdir}/mymod/os/os.go", "package os\nfunc Info() string { return \"info\" }\n")
  script = <<~SCRIPT
    use "os"
    require "mymod/os"
    puts(os.info())
  SCRIPT
  test.write_file("#{tmpdir}/main.rugo", script)
  result = test.run("rugo run #{tmpdir}/main.rugo")
  test.assert_neq(result["status"], 0)
  test.assert_eq(str.contains(result["output"], "conflicts"), true)
end

rats "require Go module namespace conflicts with import'd bridge"
  tmpdir = test.tmpdir()
  test.run("mkdir -p #{tmpdir}/mymod/strings")
  test.write_file("#{tmpdir}/mymod/go.mod", "module example.com/mymod\n\ngo 1.22\n")
  test.write_file("#{tmpdir}/mymod/mymod.go", "package mymod\nfunc Hello() string { return \"hi\" }\n")
  test.write_file("#{tmpdir}/mymod/strings/strings.go", "package strings\nfunc Yell() string { return \"LOUD\" }\n")
  script = <<~SCRIPT
    import "strings"
    require "mymod/strings"
    puts(strings.yell())
  SCRIPT
  test.write_file("#{tmpdir}/main.rugo", script)
  result = test.run("rugo run #{tmpdir}/main.rugo")
  test.assert_neq(result["status"], 0)
  test.assert_eq(str.contains(result["output"], "conflicts"), true)
end

rats "require Go module namespace conflict resolved with alias"
  tmpdir = test.tmpdir()
  test.run("mkdir -p #{tmpdir}/mymod/os")
  test.write_file("#{tmpdir}/mymod/go.mod", "module example.com/mymod\n\ngo 1.22\n")
  test.write_file("#{tmpdir}/mymod/mymod.go", "package mymod\nfunc Hello() string { return \"hi\" }\n")
  test.write_file("#{tmpdir}/mymod/os/os.go", "package os\nfunc Info() string { return \"info\" }\n")
  script = <<~SCRIPT
    use "os"
    require "mymod/os" as myos
    puts(myos.info())
  SCRIPT
  test.write_file("#{tmpdir}/main.rugo", script)
  result = test.run("rugo run #{tmpdir}/main.rugo")
  test.assert_eq(result["status"], 0)
  test.assert_eq(result["output"], "info")
end
