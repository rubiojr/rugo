# RATS: Test implicit return (last expression in function body)
use "test"
use "eval"

rats "implicit return with literal"
  source = <<~RUGO
    def answer
      42
    end
    puts(answer())
  RUGO
  result = eval.run(source)
  test.assert_eq(result["status"], 0)
  test.assert_eq(result["output"], "42")
end

rats "implicit return with variable"
  source = <<~RUGO
    def greet(name)
      msg = "hello " + name
      msg
    end
    puts(greet("world"))
  RUGO
  result = eval.run(source)
  test.assert_eq(result["status"], 0)
  test.assert_eq(result["output"], "hello world")
end

rats "implicit return with array index"
  source = <<~RUGO
    def last(arr)
      arr[-1]
    end
    puts(last([1, 2, 3]))
  RUGO
  result = eval.run(source)
  test.assert_eq(result["status"], 0)
  test.assert_eq(result["output"], "3")
end

rats "implicit return with function call"
  source = <<~RUGO
    use "str"
    def first_word(s)
      parts = str.split(s, " ")
      parts[0]
    end
    puts(first_word("hello world"))
  RUGO
  result = eval.run(source)
  test.assert_eq(result["status"], 0)
  test.assert_eq(result["output"], "hello")
end

rats "implicit return with arithmetic"
  source = <<~RUGO
    def double(x)
      x * 2
    end
    puts(double(21))
  RUGO
  result = eval.run(source)
  test.assert_eq(result["status"], 0)
  test.assert_eq(result["output"], "42")
end

rats "explicit return still works"
  source = <<~RUGO
    def early(x)
      if x > 10
        return "big"
      end
      "small"
    end
    puts(early(5))
    puts(early(20))
  RUGO
  result = eval.run(source)
  test.assert_eq(result["status"], 0)
  test.assert_eq(result["output"], "small\nbig")
end

rats "implicit return from if/else in function"
  source = <<~RUGO
    def classify(x)
      if x > 10
        "big"
      else
        "small"
      end
    end
    puts(classify(20))
    puts(classify(5))
  RUGO
  result = eval.run(source)
  test.assert_eq(result["status"], 0)
  test.assert_eq(result["output"], "big\nsmall")
end

rats "implicit return from if/else in lambda"
  source = <<~RUGO
    arr = [1, 2, 3, nil]
    result = arr.map(fn(x)
      if x != nil
        x * 2
      else
        nil
      end
    end)
    puts result
  RUGO
  result = eval.run(source)
  test.assert_eq(result["status"], 0)
  test.assert_eq(result["output"], "[2, 4, 6, nil]")
end

# Bug 8daeef0: functions with typed returns but incomplete paths
# should return nil (not the type's zero value) when no return is hit.

rats "partial return path returns nil not empty string"
  source = <<~RUGO
    def maybe(x)
      if x
        return "yes"
      end
    end
    result = maybe(false)
    puts(result == nil)
  RUGO
  result = eval.run(source)
  test.assert_eq(result["status"], 0)
  test.assert_eq(result["output"], "true")
end

rats "partial return path returns nil not zero int"
  source = <<~RUGO
    def find_index(arr, target)
      for i in arr
        if i == target
          return i
        end
      end
    end
    result = find_index([1, 2, 3], 99)
    puts(result == nil)
  RUGO
  result = eval.run(source)
  test.assert_eq(result["status"], 0)
  test.assert_eq(result["output"], "true")
end

rats "partial return path returns nil not false"
  source = <<~RUGO
    def check(x)
      if x > 0
        return true
      end
    end
    result = check(-1)
    puts(result == nil)
  RUGO
  result = eval.run(source)
  test.assert_eq(result["status"], 0)
  test.assert_eq(result["output"], "true")
end

rats "bare return in typed function returns nil"
  source = <<~RUGO
    def process(x)
      if x == nil
        return
      end
      return "done"
    end
    result = process(nil)
    puts(result == nil)
  RUGO
  result = eval.run(source)
  test.assert_eq(result["status"], 0)
  test.assert_eq(result["output"], "true")
end
