# Bare-style calls inside string interpolation should produce a clear error
# suggesting the function-call form, not dump raw parser internals.

use "test"
use "eval"
use "str"

rats "bare append in interpolation gives actionable error"
  source = <<~'RUGO'
    parts = []
    key = "foo"
    "#{append parts, key}"
  RUGO
  result = eval.run(source)
  test.assert_neq(result["status"], 0)
  test.assert_contains(result["output"], "bare-style call not supported inside interpolation")
  test.assert_contains(result["output"], "use append(parts, key) instead")
end

rats "bare call error does not expose parser internals"
  source = <<~'RUGO'
    parts = []
    key = "foo"
    "#{append parts, key}"
  RUGO
  result = eval.run(source)
  test.assert_neq(result["status"], 0)
  test.assert_false(str.contains(result["output"], "expected ["))
  test.assert_false(str.contains(result["output"], "HashLit"))
  test.assert_false(str.contains(result["output"], "UnaryExpr"))
end

rats "generic interpolation parse error is clean"
  source = <<~'RUGO'
    puts("#{0!}")
  RUGO
  result = eval.run(source)
  test.assert_neq(result["status"], 0)
  test.assert_false(str.contains(result["output"], "expected ["))
  test.assert_contains(result["output"], "syntax error in expression")
end
