# RATS: Test Go bridge â€” maps package
use "test"

import "maps"

rats "maps.keys"
  keys = maps.keys({name: "Rugo", version: "1.0", lang: "go"})
  test.assert_eq(len(keys), 3)
  test.assert_eq(keys[0], "lang")
  test.assert_eq(keys[1], "name")
  test.assert_eq(keys[2], "version")
end

rats "maps.values"
  test.assert_eq(len(maps.values({a: "one", b: "two"})), 2)
end

rats "maps.clone"
  h = {name: "Rugo", version: "1.0"}
  copy = maps.clone(h)
  copy.name = "Rugo2"
  test.assert_eq(h.name, "Rugo")
  test.assert_eq(copy.name, "Rugo2")
end

rats "maps.equal identical"
  test.assert_true(maps.equal({a: 1, b: 2}, {a: 1, b: 2}))
end

rats "maps.equal different values"
  test.assert_false(maps.equal({a: 1}, {a: 2}))
end

rats "maps.equal different keys"
  test.assert_false(maps.equal({a: 1}, {b: 1}))
end

rats "maps.equal different sizes"
  test.assert_false(maps.equal({a: 1, b: 2}, {a: 1}))
end

rats "maps empty hash"
  test.assert_eq(len(maps.keys({})), 0)
  test.assert_true(maps.equal({}, {}))
end

rats "maps.clone is shallow"
  h = {data: {inner: "hello"}}
  copy = maps.clone(h)
  copy.data.inner = "world"
  test.assert_eq(h.data.inner, "world")
end

rats "maps.clone mutation isolation for top-level keys"
  h = {a: 1, b: 2}
  copy = maps.clone(h)
  copy.a = 99
  test.assert_eq(h.a, 1)
  test.assert_eq(copy.a, 99)
end

rats "maps.values preserves all values"
  vals = maps.values({x: 10, y: 20, z: 30})
  sum = 0
  for v in vals
    sum = sum + v
  end
  test.assert_eq(sum, 60)
end

rats "maps.keys returns sorted order"
  keys = maps.keys({z: 1, a: 2, m: 3})
  test.assert_eq(keys[0], "a")
  test.assert_eq(keys[1], "m")
  test.assert_eq(keys[2], "z")
end
