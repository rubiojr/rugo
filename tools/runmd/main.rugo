# tool: Verify Rugo code blocks in markdown files compile correctly
#
# Parses markdown files for ```ruby code blocks and validates each snippet.
# By default it checks snippets build; with --verify it also runs snippets
# and compares output against an immediately following ```text block.
#
# Usage:
#   rugo runmd <file.md> [file2.md ...]
#   rugo runmd -i <file.md>         # interactive mode
#   rugo runmd --verify <file.md>   # verify runtime output against ```text
#
# Exit code 0 if all snippets compile, 1 if any fail.

use "cli"
use "os"
use "str"
use "color"
use "test"
import "os" as go_os

TmpName = "runmd_check.rugo"

cli.name "rugo-runmd"
cli.about "Verify ruby code blocks in markdown files compile as valid Rugo"
cli.bool_flag("", "interactive", "i", "Show each snippet and prompt to run it")
cli.bool_flag("", "verify", "v", "Run snippets and verify output against following ```text blocks")
cli.parse()

Interactive = cli.get("interactive")
Verify = cli.get("verify")

args = cli.args()
if len(args) == 0
  puts "usage: rugo runmd <file.md> [file2.md ...]"
  os.exit 1
end

failures = 0
total = 0
passed = 0
skipped = 0
tmp_dir = os.exec("mktemp -d")
tmp_file = "#{tmp_dir}/#{TmpName}"
tmp_bin = "#{tmp_file}.bin"

# Check if bat is available for syntax highlighting.
def has_bat()
  result = test.run("command -v bat")
  return result.status == 0
end

UseBat = has_bat()

# Display a code snippet with syntax highlighting.
# Uses bat when available, otherwise prints with color.
def show_snippet(code)
  if UseBat
    tmp = "#{tmp_dir}/snippet_display.rugo"
    go_os.write_file(tmp, code, 420)
    output = try os.exec("bat --language=ruby --style=plain --paging=never --force-colorization " + tmp) or ""
    if output != ""
      puts output
    else
      puts code
    end
  else
    puts code
  end
end

# Normalize output for stable comparisons.
def normalize_output(raw)
  normalized = str.replace(raw, "\r\n", "\n")
  normalized = str.replace(normalized, "\r", "\n")
  lines = str.split(normalized, "\n")
  while len(lines) > 0 && str.trim(lines[len(lines) - 1]) == ""
    lines = lines[0, len(lines) - 1]
  end
  return str.join(lines, "\n")
end

# Extract ```ruby code blocks and optional following ```text expected output blocks.
# Returns an array of hashes with "code", "line", "expected", and "has_expected" keys.
def extract_ruby_blocks(content)
  lines = str.split(content, "\n")
  code_blocks = []
  in_block = false
  block_lang = ""
  block_lines = []
  block_start = 0

  for i, line in lines
    trimmed = str.trim(line)
    if in_block == false
      if str.starts_with(trimmed, "```") && trimmed != "```"
        in_block = true
        block_lang = str.trim(trimmed[3, len(trimmed) - 3])
        block_lines = []
        block_start = i + 2
      end
    else
      if trimmed == "```"
        in_block = false
        code_blocks = append(code_blocks, {lang: block_lang, code: str.join(block_lines, "\n"), line: block_start})
      else
        block_lines = append(block_lines, line)
      end
    end
  end

  blocks = []
  i = 0
  while i < len(code_blocks)
    block = code_blocks[i]
    if block.lang == "ruby"
      ruby_block = {code: block.code, line: block.line, expected: "", has_expected: false}
      if i + 1 < len(code_blocks)
        next_block = code_blocks[i + 1]
        if next_block.lang == "text"
          ruby_block.expected = next_block.code
          ruby_block.has_expected = true
        end
      end
      blocks = append(blocks, ruby_block)
    end
    i += 1
  end

  return blocks
end

# Draw a box around text using Unicode box-drawing characters.
def draw_box(text, styler)
  lines = str.split(text, "\n")
  max_w = 0
  for line in lines
    w = str.rune_count(line)
    if w > max_w
      max_w = w
    end
  end

  bar = ""
  n = max_w + 2
  while n > 0
    bar += "─"
    n -= 1
  end

  tl = "╭"
  tr = "╮"
  bl = "╰"
  br = "╯"
  vb = "│"
  puts styler(tl + bar + tr)
  for line in lines
    pad = ""
    n = max_w - str.rune_count(line)
    while n > 0
      pad += " "
      n -= 1
    end
    puts styler(vb) + " #{line}#{pad} " + styler(vb)
  end
  puts styler(bl + bar + br)
end

# Strip temp file paths from rugo build error output.
def clean_output(raw)
  marker = TmpName + ":"
  lines = str.split(raw, "\n")
  cleaned = []
  for line in lines
    idx = str.index(line, marker)
    if idx >= 0
      rest_start = idx + len(marker)
      cleaned = append(cleaned, str.trim(line[rest_start, len(line) - rest_start]))
    else
      cleaned = append(cleaned, line)
    end
  end
  return str.join(cleaned, "\n")
end

for file in args
  if os.file_exists(file) == false
    puts "error: file not found: #{file}"
    failures += 1
    next
  end

  content = go_os.read_file(file)
  blocks = extract_ruby_blocks(content)

  for block in blocks
    total += 1

    if Interactive
      puts ""
      puts color.cyan("─── ") + color.bold("#{file}:#{block.line}") + color.cyan(" ───")
      puts ""
      show_snippet(block.code)
      puts ""
      answer = os.read_line(color.yellow("Run? [y/N/q] "))
      answer = str.lower(str.trim(answer))
      puts ""

      if answer == "q"
        go_os.remove_all(tmp_dir)
        puts ""
        puts "aborted"
        os.exit 0
      end

      if answer != "y"
        skipped += 1
        puts color.dim("  skipped")
        next
      end

      go_os.write_file(tmp_file, block.code, 420)
      result = test.run("rugo build #{tmp_file} -o #{tmp_bin}")
      if result.status != 0
        failures += 1
        output = clean_output(result.output)
        if output != ""
          draw_box(output, fn(s) color.red(s) end)
        else
          draw_box("build failed", fn(s) color.red(s) end)
        end
        next
      end

      run_result = test.run(tmp_bin)
      if run_result.output != ""
        draw_box(run_result.output, fn(s) color.green(s) end)
      end
      if run_result.status != 0
        failures += 1
        puts color.red("  exit status: #{run_result.status}")
      elsif Verify && block.has_expected
        actual_output = normalize_output(run_result.output)
        expected_output = normalize_output(block.expected)
        if actual_output == expected_output
          passed += 1
          puts color.green("  output matches")
        else
          failures += 1
          puts color.red("  output mismatch")
          draw_box("expected:\n#{expected_output}", fn(s) color.yellow(s) end)
          draw_box("actual:\n#{actual_output}", fn(s) color.red(s) end)
        end
      elsif Verify && block.has_expected == false
        failures += 1
        puts color.red("  missing ```text block for output verification")
      else
        passed += 1
      end
    else
      go_os.write_file(tmp_file, block.code, 420)

      result = test.run("rugo build #{tmp_file} -o #{tmp_bin}")
      if result.status != 0
        failures += 1
        puts "#{file}:#{block.line}: FAIL"
        output = clean_output(result.output)
        if output != ""
          puts "  #{output}"
        end
        next
      end

      if Verify && block.has_expected
        run_result = test.run(tmp_bin)
        if run_result.status != 0
          failures += 1
          puts "#{file}:#{block.line}: FAIL"
          puts "  exit status: #{run_result.status}"
          next
        end

        actual_output = normalize_output(run_result.output)
        expected_output = normalize_output(block.expected)
        if actual_output == expected_output
          passed += 1
          puts "#{file}:#{block.line}: ok"
        else
          failures += 1
          puts "#{file}:#{block.line}: FAIL"
          puts "  expected: #{expected_output}"
          puts "  actual:   #{actual_output}"
        end
      elsif Verify && block.has_expected == false
        failures += 1
        puts "#{file}:#{block.line}: FAIL"
        puts "  missing ```text block for output verification"
      else
        passed += 1
        puts "#{file}:#{block.line}: ok"
      end
    end
  end
end

go_os.remove_all(tmp_dir)

puts ""
if Interactive
  puts "#{total} snippet(s), #{passed} ran, #{skipped} skipped, #{failures} failed"
else
  puts "#{total} snippet(s), #{passed} passed, #{failures} failed"
end

if failures > 0
  os.exit 1
end
