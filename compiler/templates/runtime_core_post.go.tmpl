func rugo_panic_handler(e interface{}) {
	// Parse debug.Stack() to find the .rg source location
	stack := string(debug.Stack())
	file := ""
	line := ""
	// Find .rg frames after the panic() frame (skip recovery frames)
	lines := strings.Split(stack, "\n")
	pastPanic := false
	for _, s := range lines {
		if strings.Contains(s, "panic(") { pastPanic = true; continue }
		if !pastPanic { continue }
		s = strings.TrimSpace(s)
		if idx := strings.Index(s, ".rg:"); idx >= 0 {
			rest := s[idx+4:]
			lineEnd := strings.IndexAny(rest, " +")
			if lineEnd < 0 { lineEnd = len(rest) }
			line = rest[:lineEnd]
			file = s[:idx+3]
			break
		}
	}
	if file != "" && line != "" {
		fmt.Fprintf(os.Stderr, "error: %v (%s:%s)\n", e, file, line)
	} else {
		fmt.Fprintf(os.Stderr, "error: %v\n", e)
	}
	os.Exit(1)
}

func rugo_dot_get(obj interface{}, field string) interface{} {
	// Task-like objects: check for field accessor interface
	if fa, ok := obj.(interface{ DotGet(string) (interface{}, bool) }); ok {
		if val, handled := fa.DotGet(field); handled {
			return val
		}
	}
	if m, ok := obj.(map[interface{}]interface{}); ok {
		return m[field]
	}
	panic(fmt.Sprintf("cannot access .%s on %T â€” expected a hash/struct", field, obj))
}

func rugo_dot_set(obj interface{}, field string, val interface{}) {
	if m, ok := obj.(map[interface{}]interface{}); ok {
		m[field] = val
		return
	}
	panic(fmt.Sprintf("cannot set .%s on %T â€” expected a hash/struct", field, obj))
}

// --- End Rugo Runtime ---

