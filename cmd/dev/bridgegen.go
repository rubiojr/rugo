package dev

import (
	"context"
	"fmt"
	"go/format"
	"go/importer"
	"go/types"
	"os"
	"path/filepath"
	"sort"
	"strings"

	"github.com/rubiojr/rugo/gobridge"
	"github.com/urfave/cli/v3"
)

func bridgegenCommand() *cli.Command {
	return &cli.Command{
		Name:      "bridgegen",
		Usage:     "Generate a Go bridge package (_gen.go file, always overwritten)",
		ArgsUsage: "<go-package>",
		Flags: []cli.Flag{
			&cli.BoolFlag{
				Name:  "dry-run",
				Usage: "Preview classification without writing files",
			},
		},
		Action: bridgegenAction,
	}
}

// bridgeTier is an alias for gobridge.Tier for local use.
type bridgeTier = gobridge.Tier

const (
	tierAuto     = gobridge.TierAuto
	tierCastable = gobridge.TierCastable
	tierFunc     = gobridge.TierFunc
	tierBlocked  = gobridge.TierBlocked
)

// bridgedFunc is an alias for gobridge.ClassifiedFunc for local use.
type bridgedFunc = gobridge.ClassifiedFunc

func bridgegenAction(_ context.Context, cmd *cli.Command) error {
	if cmd.NArg() < 1 {
		return fmt.Errorf("usage: rugo dev bridgegen <go-package>")
	}
	pkgPath := cmd.Args().First()
	dryRun := cmd.Bool("dry-run")

	imp := importer.Default()
	pkg, err := imp.Import(pkgPath)
	if err != nil {
		return fmt.Errorf("importing %s: %w", pkgPath, err)
	}

	// Enumerate and classify exported functions
	scope := pkg.Scope()
	var funcs []bridgedFunc
	for _, name := range scope.Names() {
		obj := scope.Lookup(name)

		// Package-level functions
		if fn, ok := obj.(*types.Func); ok {
			if !fn.Exported() {
				continue
			}
			sig := fn.Type().(*types.Signature)
			if sig.Recv() != nil {
				continue
			}
			rugoName := gobridge.ToSnakeCase(name)
			bf := gobridge.ClassifyFunc(name, rugoName, sig)
			funcs = append(funcs, bf)
			continue
		}

		// Package-level vars — enumerate their methods (e.g., base64.StdEncoding)
		if v, ok := obj.(*types.Var); ok && v.Exported() {
			varType := v.Type()
			// Dereference pointer types
			if ptr, ok := varType.(*types.Pointer); ok {
				varType = ptr.Elem()
			}
			named, ok := varType.(*types.Named)
			if !ok {
				continue
			}
			// Check methods on the named type and its pointer
			for _, base := range []*types.Named{named} {
				for j := 0; j < base.NumMethods(); j++ {
					m := base.Method(j)
					if !m.Exported() {
						continue
					}
					sig := m.Type().(*types.Signature)
					// Build method chain GoName: "VarName.MethodName"
					goName := name + "." + m.Name()
					rugoName := gobridge.ToSnakeCase(name) + "_" + gobridge.ToSnakeCase(m.Name())
					// Strip receiver from signature for classification
					bf := gobridge.ClassifyFunc(goName, rugoName, sig)
					funcs = append(funcs, bf)
				}
			}
			// Also check pointer receiver methods
			ptrMethods := types.NewMethodSet(types.NewPointer(named))
			for j := 0; j < ptrMethods.Len(); j++ {
				sel := ptrMethods.At(j)
				m := sel.Obj().(*types.Func)
				if !m.Exported() {
					continue
				}
				// Skip if already added from value methods
				found := false
				for _, f := range funcs {
					if f.GoName == name+"."+m.Name() {
						found = true
						break
					}
				}
				if found {
					continue
				}
				sig := m.Type().(*types.Signature)
				goName := name + "." + m.Name()
				rugoName := gobridge.ToSnakeCase(name) + "_" + gobridge.ToSnakeCase(m.Name())
				bf := gobridge.ClassifyFunc(goName, rugoName, sig)
				funcs = append(funcs, bf)
			}
		}
	}

	sort.Slice(funcs, func(i, j int) bool {
		if funcs[i].Tier != funcs[j].Tier {
			return funcs[i].Tier < funcs[j].Tier
		}
		return funcs[i].RugoName < funcs[j].RugoName
	})

	if dryRun {
		return printClassification(pkgPath, funcs)
	}

	return writeBridgeFile(pkgPath, funcs)
}

func printClassification(pkgPath string, funcs []bridgedFunc) error {
	counts := map[bridgeTier]int{}
	for _, f := range funcs {
		counts[f.Tier]++
	}

	fmt.Printf("Package: %s\n", pkgPath)
	fmt.Printf("Total: %d functions\n", len(funcs))
	fmt.Printf("  auto:     %d\n", counts[tierAuto])
	fmt.Printf("  castable: %d\n", counts[tierCastable])
	fmt.Printf("  func:     %d\n", counts[tierFunc])
	fmt.Printf("  blocked:  %d\n\n", counts[tierBlocked])

	for _, f := range funcs {
		marker := "✓"
		if f.Tier == tierBlocked {
			marker = "✗"
		} else if f.Tier == tierFunc {
			marker = "λ"
		} else if f.Tier == tierCastable {
			marker = "~"
		}
		line := fmt.Sprintf("  %s %-25s → %-25s [%s]", marker, f.GoName, f.RugoName, f.Tier)
		if f.Reason != "" {
			line += "  // " + f.Reason
		}
		fmt.Println(line)
	}
	return nil
}

func writeBridgeFile(pkgPath string, funcs []bridgedFunc) error {
	ns := gobridge.DefaultNS(pkgPath)
	fileName := filepath.Join("gobridge", ns+"_gen.go")

	// Filter to generatable functions (auto + castable)
	var genFuncs []bridgedFunc
	var skipped []bridgedFunc
	for _, f := range funcs {
		if f.Tier == tierAuto || f.Tier == tierCastable {
			genFuncs = append(genFuncs, f)
		} else {
			skipped = append(skipped, f)
		}
	}

	var sb strings.Builder
	sb.WriteString("// Code generated by rugo dev bridgegen; DO NOT EDIT.\n\n")
	sb.WriteString("package gobridge\n\n")
	sb.WriteString("func init() {\n")
	sb.WriteString("\tRegister(&Package{\n")
	sb.WriteString(fmt.Sprintf("\t\tPath: %q,\n", pkgPath))
	sb.WriteString(fmt.Sprintf("\t\tDoc:  \"Functions from Go's %s package.\",\n", pkgPath))
	sb.WriteString("\t\tFuncs: map[string]GoFuncSig{\n")

	for _, f := range genFuncs {
		sb.WriteString(formatFuncEntry(f))
	}

	// Add skipped functions as comments
	if len(skipped) > 0 {
		sb.WriteString("\t\t\t// --- Skipped (need custom Codegen or _custom.go) ---\n")
		for _, f := range skipped {
			sb.WriteString(fmt.Sprintf("\t\t\t// %s (%s): %s\n", f.RugoName, f.Tier, f.Reason))
		}
	}

	sb.WriteString("\t\t},\n")
	sb.WriteString("\t})\n")
	sb.WriteString("}\n")

	formatted, err := format.Source([]byte(sb.String()))
	if err != nil {
		return fmt.Errorf("formatting %s: %w", fileName, err)
	}

	if err := os.WriteFile(fileName, formatted, 0o644); err != nil {
		return fmt.Errorf("writing %s: %w", fileName, err)
	}

	fmt.Printf("Generated %s\n", fileName)
	fmt.Printf("  %d functions generated, %d skipped\n", len(genFuncs), len(skipped))

	// Generate smoke tests — skip functions overridden by _custom.go
	customFuncs := gobridge.PackageFuncs(pkgPath)
	var testFuncs []bridgedFunc
	for _, f := range genFuncs {
		if customFuncs != nil {
			if existing, ok := customFuncs[f.RugoName]; ok {
				// Custom override exists — skip if signature differs
				if len(existing.Params) != len(f.Params) {
					continue
				}
			}
		}
		testFuncs = append(testFuncs, f)
	}
	testFile := filepath.Join("rats", "gobridge", "auto", ns+"_gen_test.rugo")
	if err := writeTestFile(testFile, pkgPath, ns, testFuncs); err != nil {
		return fmt.Errorf("writing tests: %w", err)
	}
	fmt.Printf("Generated %s\n", testFile)

	return nil
}

func formatFuncEntry(f bridgedFunc) string {
	var sb strings.Builder

	// Params
	paramStrs := make([]string, len(f.Params))
	for i, p := range f.Params {
		paramStrs[i] = gobridge.GoTypeConst(p)
	}
	paramList := "nil"
	if len(paramStrs) > 0 {
		paramList = "[]GoType{" + strings.Join(paramStrs, ", ") + "}"
	}

	// Returns
	retStrs := make([]string, len(f.Returns))
	for i, r := range f.Returns {
		retStrs[i] = gobridge.GoTypeConst(r)
	}
	retList := "nil"
	if len(retStrs) > 0 {
		retList = "[]GoType{" + strings.Join(retStrs, ", ") + "}"
	}

	sb.WriteString(fmt.Sprintf("\t\t\t%q: {GoName: %q, Params: %s, Returns: %s",
		f.RugoName, f.GoName, paramList, retList))

	if f.Variadic {
		sb.WriteString(", Variadic: true")
	}

	if len(f.FuncTypes) > 0 {
		var parts []string
		for idx, ft := range f.FuncTypes {
			var fParams, fRets []string
			for _, p := range ft.Params {
				fParams = append(fParams, gobridge.GoTypeConst(p))
			}
			for _, r := range ft.Returns {
				fRets = append(fRets, gobridge.GoTypeConst(r))
			}
			pList := "nil"
			if len(fParams) > 0 {
				pList = "[]GoType{" + strings.Join(fParams, ", ") + "}"
			}
			rList := "nil"
			if len(fRets) > 0 {
				rList = "[]GoType{" + strings.Join(fRets, ", ") + "}"
			}
			parts = append(parts, fmt.Sprintf("%d: {Params: %s, Returns: %s}", idx, pList, rList))
		}
		sb.WriteString(fmt.Sprintf(", FuncTypes: map[int]*GoFuncType{%s}", strings.Join(parts, ", ")))
	}

	if len(f.ArrayTypes) > 0 {
		// Emit ArrayTypes metadata
		var parts []string
		for idx, at := range f.ArrayTypes {
			parts = append(parts, fmt.Sprintf("%d: {Elem: %s, Size: %d}", idx, gobridge.GoTypeConst(at.Elem), at.Size))
		}
		sb.WriteString(fmt.Sprintf(", ArrayTypes: map[int]*GoArrayType{%s}", strings.Join(parts, ", ")))
	}

	if f.Doc != "" {
		sb.WriteString(fmt.Sprintf(", Doc: %q", f.Doc))
	}

	sb.WriteString("},\n")
	return sb.String()
}

// writeTestFile generates smoke tests for all bridged functions.
func writeTestFile(path, pkgPath, ns string, funcs []bridgedFunc) error {
	if err := os.MkdirAll(filepath.Dir(path), 0o755); err != nil {
		return err
	}

	var sb strings.Builder
	sb.WriteString("# Auto-generated smoke tests by rugo dev bridgegen; DO NOT EDIT.\n")
	sb.WriteString("use \"test\"\n")
	sb.WriteString(fmt.Sprintf("import %q\n\n", pkgPath))

	for _, f := range funcs {
		// Skip void functions and functions with complex return types
		if len(f.Returns) == 0 {
			continue
		}
		// Skip functions whose only return is error (void semantics)
		if len(f.Returns) == 1 && f.Returns[0] == gobridge.GoError {
			continue
		}
		// Skip GoFunc params — need lambda args we can't auto-generate
		// Skip GoError params — can't construct error values in Rugo
		hasFunc := false
		for _, p := range f.Params {
			if p == gobridge.GoFunc || p == gobridge.GoError {
				hasFunc = true
			}
		}
		if hasFunc {
			continue
		}

		args := testArgs(f)
		expectedType := testReturnType(f)
		if expectedType == "" {
			continue
		}

		sb.WriteString(fmt.Sprintf("rats \"%s.%s is callable\"\n", ns, f.RugoName))
		if f.Variadic && len(f.Params) == 1 {
			sb.WriteString(fmt.Sprintf("  result = try %s.%s(%s) or nil\n", ns, f.RugoName, args[0]))
		} else {
			sb.WriteString(fmt.Sprintf("  result = try %s.%s(%s) or nil\n", ns, f.RugoName, strings.Join(args, ", ")))
		}
		sb.WriteString(fmt.Sprintf("  if result != nil\n"))
		sb.WriteString(fmt.Sprintf("    test.assert_eq(type_of(result), %q)\n", expectedType))
		sb.WriteString(fmt.Sprintf("  end\n"))
		sb.WriteString("end\n\n")
	}

	return os.WriteFile(path, []byte(sb.String()), 0o644)
}

// testArgs generates safe zero-value arguments for a function call.
func testArgs(f bridgedFunc) []string {
	var args []string
	for _, p := range f.Params {
		args = append(args, testZeroValue(p))
	}
	return args
}

// testZeroValue returns a safe Rugo literal for a GoType.
func testZeroValue(t gobridge.GoType) string {
	switch t {
	case gobridge.GoString:
		return `"a"`
	case gobridge.GoInt:
		return "1"
	case gobridge.GoFloat64:
		return "1.0"
	case gobridge.GoBool:
		return "false"
	case gobridge.GoByte:
		return "0"
	case gobridge.GoStringSlice:
		return `["a"]`
	case gobridge.GoByteSlice:
		return `"a"`
	case gobridge.GoInt64:
		return "1"
	case gobridge.GoInt32:
		return "1"
	case gobridge.GoUint32:
		return "1"
	case gobridge.GoUint64:
		return "1"
	case gobridge.GoUint:
		return "1"
	case gobridge.GoFloat32:
		return "1.0"
	case gobridge.GoRune:
		return `"a"`
	case gobridge.GoDuration:
		return "1"
	default:
		return "nil"
	}
}

// testReturnType returns the expected Rugo type_of() string for a return pattern.
func testReturnType(f bridgedFunc) string {
	returns := f.Returns
	// (T, error) → T
	if len(returns) >= 2 && returns[len(returns)-1] == gobridge.GoError {
		returns = returns[:len(returns)-1]
	}
	// (T, bool) → T or nil
	if len(returns) == 2 && returns[1] == gobridge.GoBool {
		return "" // can't predict nil vs value
	}
	// Multi-return → Array
	if len(returns) > 1 {
		return "Array"
	}
	if len(returns) == 0 {
		return ""
	}
	switch returns[0] {
	case gobridge.GoString, gobridge.GoByteSlice:
		return "String"
	case gobridge.GoInt, gobridge.GoInt32, gobridge.GoInt64, gobridge.GoUint32, gobridge.GoUint64, gobridge.GoUint:
		return "Integer"
	case gobridge.GoFloat64, gobridge.GoFloat32:
		return "Float"
	case gobridge.GoBool:
		return "Bool"
	case gobridge.GoRune:
		return "String"
	case gobridge.GoStringSlice:
		return "Array"
	case gobridge.GoDuration:
		return "Integer"
	default:
		return ""
	}
}
