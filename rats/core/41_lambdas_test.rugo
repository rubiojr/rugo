use "test"
use "str"
use "eval"

rats "fn: basic lambda assign and call"
  source = <<~RUGO
    double = fn(x) x * 2 end
    puts double(5)
  RUGO
  result = eval.run(source)
  test.assert_eq(result["status"], 0)
  test.assert_eq(result["lines"][0], "10")
end

rats "fn: multi-param lambda"
  source = <<~RUGO
    add = fn(a, b) a + b end
    puts add(3, 4)
  RUGO
  result = eval.run(source)
  test.assert_eq(result["status"], 0)
  test.assert_eq(result["lines"][0], "7")
end

rats "fn: zero-arg lambda"
  source = <<~RUGO
    greet = fn() "hello" end
    puts greet()
  RUGO
  result = eval.run(source)
  test.assert_eq(result["status"], 0)
  test.assert_eq(result["lines"][0], "hello")
end

rats "fn: multi-line lambda"
  source = <<~RUGO
    transform = fn(x)
      result = x * 2
      return result
    end
    puts transform(21)
  RUGO
  result = eval.run(source)
  test.assert_eq(result["status"], 0)
  test.assert_eq(result["lines"][0], "42")
end

rats "fn: pass lambda to function"
  source = <<~RUGO
    def my_map(f, arr)
      result = []
      for item in arr
        result = append(result, f(item))
      end
      return result
    end
    
    nums = my_map(fn(x) x * 2 end, [1, 2, 3])
    puts nums[0]
    puts nums[1]
    puts nums[2]
  RUGO
  result = eval.run(source)
  test.assert_eq(result["status"], 0)
  test.assert_eq(result["lines"][0], "2")
  test.assert_eq(result["lines"][1], "4")
  test.assert_eq(result["lines"][2], "6")
end

rats "fn: return lambda from function (closure)"
  source = <<~RUGO
    def make_adder(n)
      return fn(x) x + n end
    end
    
    add5 = make_adder(5)
    puts add5(10)
  RUGO
  result = eval.run(source)
  test.assert_eq(result["status"], 0)
  test.assert_eq(result["lines"][0], "15")
end

rats "fn: lambda in hash"
  source = <<~RUGO
    ops = {
      "add" => fn(a, b) a + b end,
      "mul" => fn(a, b) a * b end
    }
    puts ops["add"](2, 3)
    puts ops["mul"](4, 5)
  RUGO
  result = eval.run(source)
  test.assert_eq(result["status"], 0)
  test.assert_eq(result["lines"][0], "5")
  test.assert_eq(result["lines"][1], "20")
end

rats "fn: lambda in array"
  source = <<~RUGO
    fns = [fn(x) x + 1 end, fn(x) x * 2 end]
    puts fns[0](10)
    puts fns[1](10)
  RUGO
  result = eval.run(source)
  test.assert_eq(result["status"], 0)
  test.assert_eq(result["lines"][0], "11")
  test.assert_eq(result["lines"][1], "20")
end

rats "fn: closure captures by reference"
  source = <<~RUGO
    x = 10
    f = fn() x end
    x = 20
    puts f()
  RUGO
  result = eval.run(source)
  test.assert_eq(result["status"], 0)
  test.assert_eq(result["lines"][0], "20")
end

rats "fn: nested lambdas (compose)"
  source = <<~RUGO
    compose = fn(f, g)
      return fn(x) f(g(x)) end
    end
    
    double = fn(x) x * 2 end
    inc = fn(x) x + 1 end
    double_then_inc = compose(inc, double)
    puts double_then_inc(5)
  RUGO
  result = eval.run(source)
  test.assert_eq(result["status"], 0)
  test.assert_eq(result["lines"][0], "11")
end

rats "fn: lambda with explicit return"
  source = <<~RUGO
    classify = fn(x)
      if x > 0
        return "positive"
      end
      return "non-positive"
    end
    puts classify(1)
    puts classify(-1)
  RUGO
  result = eval.run(source)
  test.assert_eq(result["status"], 0)
  test.assert_eq(result["lines"][0], "positive")
  test.assert_eq(result["lines"][1], "non-positive")
end

rats "fn: lambda with string interpolation"
  source = <<~'RUGO'
    greet = fn(name) "hello #{name}" end
    puts greet("world")
  RUGO
  result = eval.run(source)
  test.assert_eq(result["status"], 0)
  test.assert_eq(result["lines"][0], "hello world")
end

rats "fn: lambda compiles to native binary"
  tdir = test.tmpdir()
  script = tdir + "/fn_basic.rugo"
  source = <<~RUGO
    # Simple lambda assigned to a variable
    add = fn(a, b) a + b end
    puts add(3, 7)
  RUGO
  test.write_file(script, source)
  result = test.run("rugo build " + script + " -o #{tdir}/fn_bin && #{tdir}/fn_bin")
  test.assert_eq(result["status"], 0)
  test.assert_eq(result["lines"][0], "10")
end

rats "fn: emit produces valid Go with lambda"
  tdir = test.tmpdir()
  script = tdir + "/fn_basic_emit.rugo"
  source = <<~RUGO
    # Simple lambda assigned to a variable
    add = fn(a, b) a + b end
    puts add(3, 7)
  RUGO
  test.write_file(script, source)
  result = test.run("rugo emit " + script)
  test.assert_eq(result["status"], 0)
  test.assert_contains(result["output"], "func(_args ...interface{}) interface{}")
end

# --- Negative tests ---

rats "fn: missing end is a parse error"
  source = <<~RUGO
    # fn missing end keyword
    f = fn(x) x * 2
  RUGO
  result = eval.run(source)
  test.assert_neq(result["status"], 0)
  test.assert_contains(result["output"], "expected \"end\"")
  test.assert_contains(result["output"], "eval.rugo")
end

rats "fn: missing ( is a parse error"
  source = <<~RUGO
    # fn missing opening paren
    f = fn x * 2 end
  RUGO
  result = eval.run(source)
  test.assert_neq(result["status"], 0)
  test.assert_contains(result["output"], "expected \"(\"")
  test.assert_contains(result["output"], "eval.rugo")
end

rats "fn: calling non-function variable is a compile error"
  source = <<~RUGO
    # calling a non-function variable as a lambda
    x = 42
    x(1)
  RUGO
  result = eval.run(source)
  test.assert_neq(result["status"], 0)
  test.assert_contains(result["output"], "not a function")
  test.assert_false(str.contains(result["output"], "interface"))
end

rats "fn: runtime error in lambda shows correct line"
  source = <<~RUGO
    # runtime error inside lambda body
    f = fn(x)
      y = x + 1
      z = y / x
      return z
    end
    f(0)
  RUGO
  result = eval.run(source)
  test.assert_neq(result["status"], 0)
  test.assert_contains(result["output"], "integer divide by zero")
  test.assert_contains(result["output"], "eval.rugo:4")
end

rats "fn: error output has no Go stacktrace"
  source = <<~RUGO
    # runtime error inside lambda body
    f = fn(x)
      y = x + 1
      z = y / x
      return z
    end
    f(0)
  RUGO
  result = eval.run(source)
  test.assert_neq(result["status"], 0)
  test.assert_false(str.contains(result["output"], "goroutine"))
  test.assert_false(str.contains(result["output"], "panic("))
end
