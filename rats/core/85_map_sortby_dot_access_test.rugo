# RATS: inline lambda preprocessing regressions
# Tests for bugs where expressions inside inline fn() bodies were
# mishandled by the preprocessor (dot-access, comparison operators).
use "test"

# ============================================================
# A. map with dot-access on hash fields
# ============================================================

rats "map callback supports dot-access on hash fields"
  arr = [{name: "Alice"}, {name: "Bob"}]
  names = arr.map(fn(u) u.name end)
  test.assert_eq(names[0], "Alice")
  test.assert_eq(names[1], "Bob")
end

rats "map callback supports dot-access on nested hash fields"
  arr = [{user: {name: "Alice"}}, {user: {name: "Bob"}}]
  names = arr.map(fn(u) u.user.name end)
  test.assert_eq(names[0], "Alice")
  test.assert_eq(names[1], "Bob")
end

rats "map callback dot-access works with multiple hash fields"
  people = [{name: "Alice", age: 30}, {name: "Bob", age: 25}]
  ages = people.map(fn(p) p.age end)
  test.assert_eq(ages[0], 30)
  test.assert_eq(ages[1], 25)
end

# ============================================================
# B. sort_by with dot-access on hash fields
# ============================================================

rats "sort_by callback supports dot-access on hash fields"
  arr = [{name: "Charlie"}, {name: "Alice"}, {name: "Bob"}]
  sorted = arr.sort_by(fn(u) u.name end)
  test.assert_eq(sorted[0].name, "Alice")
  test.assert_eq(sorted[1].name, "Bob")
  test.assert_eq(sorted[2].name, "Charlie")
end

rats "sort_by callback supports dot-access on numeric hash fields"
  people = [{name: "Alice", age: 30}, {name: "Bob", age: 20}, {name: "Charlie", age: 25}]
  sorted = people.sort_by(fn(p) p.age end)
  test.assert_eq(sorted[0].name, "Bob")
  test.assert_eq(sorted[1].name, "Charlie")
  test.assert_eq(sorted[2].name, "Alice")
end

# ============================================================
# C. chained operations with dot-access
# ============================================================

rats "filter then map with dot-access works"
  people = [{name: "Alice", age: 30}, {name: "Bob", age: 17}, {name: "Charlie", age: 25}]
  adults = people.filter(fn(p) p.age >= 18 end).map(fn(p) p.name end)
  test.assert_eq(adults[0], "Alice")
  test.assert_eq(adults[1], "Charlie")
end

# ============================================================
# D. comparison operators inside inline lambda bodies
# ============================================================

rats "== inside inline lambda is not treated as shell"
  nums = [1, 2, 3]
  found = nums.find(fn(x) x == 2 end)
  test.assert_eq(found, 2)
end

rats "!= inside inline lambda works"
  nums = [1, 2, 3]
  result = nums.filter(fn(x) x != 2 end)
  test.assert_eq(len(result), 2)
  test.assert_eq(result[0], 1)
  test.assert_eq(result[1], 3)
end

rats "hash.find with == in inline lambda"
  h = {a: 1, b: 2, c: 3}
  found = h.find(fn(k, v) v == 2 end)
  test.assert_eq(found[0], "b")
  test.assert_eq(found[1], 2)
end
