# RATS: Built-in hash collection methods
# Tests for .map, .filter, .reject, .each, .reduce, .find, .any, .all,
# .count, .keys, .values, .merge
use "test"

# ============================================================
# A. map
# ============================================================

rats "hash.map transforms each pair into array"
  h = {a: 1, b: 2}
  result = h.map(fn(k, v) "#{k}=#{v}" end)
  test.assert_eq(len(result), 2)
  test.assert_eq(type_of(result), "Array")
end

# ============================================================
# B. filter
# ============================================================

rats "hash.filter returns a hash with matching pairs"
  h = {a: 1, b: 2, c: 3}
  result = h.filter(fn(k, v) v > 1 end)
  test.assert_eq(type_of(result), "Hash")
  test.assert_eq(len(result), 2)
end

rats "hash.filter by key"
  h = {name: "Alice", age: 30, city: "NYC"}
  result = h.filter(fn(k, v) k != "age" end)
  test.assert_eq(result["name"], "Alice")
  test.assert_eq(result["city"], "NYC")
  test.assert_eq(result["age"], nil)
end

# ============================================================
# C. reject
# ============================================================

rats "hash.reject removes matching pairs"
  h = {a: 1, b: 2, c: 3}
  result = h.reject(fn(k, v) v > 1 end)
  test.assert_eq(type_of(result), "Hash")
  test.assert_eq(len(result), 1)
  test.assert_eq(result["a"], 1)
end

# ============================================================
# D. each
# ============================================================

rats "hash.each iterates all pairs"
  h = {a: 1, b: 2}
  items = []
  h.each(fn(k, v) items = append(items, k) end)
  test.assert_eq(len(items), 2)
end

# ============================================================
# E. reduce
# ============================================================

rats "hash.reduce accumulates over pairs"
  h = {a: 1, b: 2, c: 3}
  sum = h.reduce(0, fn(acc, k, v) acc + v end)
  test.assert_eq(sum, 6)
end

# ============================================================
# F. find
# ============================================================

rats "hash.find returns first matching pair as array"
  h = {a: 1, b: 2, c: 3}
  found = h.find(fn(k, v) v == 2 end)
  test.assert_eq(type_of(found), "Array")
  test.assert_eq(found[0], "b")
  test.assert_eq(found[1], 2)
end

rats "hash.find returns nil when no match"
  h = {a: 1}
  found = h.find(fn(k, v) v > 10 end)
  test.assert_eq(found, nil)
end

# ============================================================
# G. any / all
# ============================================================

rats "hash.any returns true when match exists"
  h = {a: 1, b: 2, c: 3}
  test.assert_true(h.any(fn(k, v) v > 2 end))
end

rats "hash.any returns false when no match"
  h = {a: 1, b: 2}
  test.assert_false(h.any(fn(k, v) v > 10 end))
end

rats "hash.all returns true when all match"
  h = {a: 1, b: 2, c: 3}
  test.assert_true(h.all(fn(k, v) v > 0 end))
end

rats "hash.all returns false when one fails"
  h = {a: 1, b: 2, c: 3}
  test.assert_false(h.all(fn(k, v) v > 1 end))
end

# ============================================================
# H. count
# ============================================================

rats "hash.count counts matching pairs"
  h = {a: 1, b: 2, c: 3}
  test.assert_eq(h.count(fn(k, v) v > 1 end), 2)
end

# ============================================================
# I. keys / values
# ============================================================

rats "hash.keys returns all keys"
  h = {a: 1, b: 2}
  keys = h.keys()
  test.assert_eq(type_of(keys), "Array")
  test.assert_eq(len(keys), 2)
end

rats "hash.values returns all values"
  h = {a: 1, b: 2}
  vals = h.values()
  test.assert_eq(type_of(vals), "Array")
  test.assert_eq(len(vals), 2)
end

# ============================================================
# J. merge
# ============================================================

rats "hash.merge combines two hashes"
  h1 = {a: 1, b: 2}
  h2 = {b: 99, c: 3}
  merged = h1.merge(h2)
  test.assert_eq(merged["a"], 1)
  test.assert_eq(merged["b"], 99)
  test.assert_eq(merged["c"], 3)
end

rats "hash.merge does not mutate original"
  h1 = {a: 1}
  h2 = {b: 2}
  merged = h1.merge(h2)
  test.assert_eq(len(h1), 1)
  test.assert_eq(len(merged), 2)
end

# ============================================================
# K. Hash key lookup still works for non-reserved names
# ============================================================

rats "hash lambda via dot call still works"
  ops = {greet: fn(name) "hello " + name end}
  test.assert_eq(ops.greet("world"), "hello world")
end

# ============================================================
# L. Method priority: built-in wins over hash key
# ============================================================

rats "built-in method takes priority over hash key"
  h = {keys: "my_keys_value", name: "test"}
  result = h.keys()
  test.assert_eq(type_of(result), "Array")
  test.assert_eq(len(result), 2)
end

# ============================================================
# M. keys returns sorted keys
# ============================================================

rats "hash.keys returns sorted keys"
  h = {c: 3, a: 1, b: 2}
  keys = h.keys()
  test.assert_eq(keys[0], "a")
  test.assert_eq(keys[1], "b")
  test.assert_eq(keys[2], "c")
end

# ============================================================
# N. clone
# ============================================================

rats "hash.clone returns a shallow copy"
  h = {a: 1, b: 2, c: 3}
  copy = h.clone()
  test.assert_eq(len(copy), 3)
  test.assert_eq(copy["a"], 1)
  test.assert_eq(copy["b"], 2)
  test.assert_eq(copy["c"], 3)
end

rats "hash.clone does not mutate original"
  h = {x: 10}
  copy = h.clone()
  copy["y"] = 20
  test.assert_eq(len(h), 1)
  test.assert_eq(len(copy), 2)
end

rats "hash.clone of empty hash"
  h = {}
  copy = h.clone()
  test.assert_eq(len(copy), 0)
  test.assert_eq(type_of(copy), "Hash")
end
