# RATS: Regression test for bare variable not treated as shell command
# Covers: def, fn, spawn, for-loop variables, and mid-body bare variable
use "test"
use "eval"

# --- Positive: bare variable in various block types ---

rats "bare variable in def is not a shell command"
  source = <<~RUGO
    def greet(name)
      msg = "Hello, " + name
      return msg
    end
    puts greet("Rugo")
  RUGO
  result = eval.run(source)
  test.assert_eq(result["status"], 0)
  test.assert_eq(result["output"], "Hello, Rugo")
end

rats "bare variable in fn is implicit return"
  source = <<~RUGO
    greet = fn(name)
      msg = "Hello, " + name
      msg
    end
    puts greet("Rugo")
  RUGO
  result = eval.run(source)
  test.assert_eq(result["status"], 0)
  test.assert_eq(result["output"], "Hello, Rugo")
end

rats "bare variable in spawn is task result"
  source = <<~RUGO
    task = spawn
      x = "hello"
      x
    end
    puts task.value
  RUGO
  result = eval.run(source)
  test.assert_eq(result["status"], 0)
  test.assert_eq(result["output"], "hello")
end

rats "bare variable mid-body in def is not a shell command"
  source = <<~RUGO
    def double(n)
      result = n * 2
      result
      return result
    end
    puts double(21)
  RUGO
  result = eval.run(source)
  test.assert_eq(result["status"], 0)
  test.assert_eq(result["output"], "42")
end

rats "for-loop variable is not a shell command"
  source = <<~RUGO
    items = [10, 20, 30]
    total = 0
    for x in items
      total += x
    end
    puts total
  RUGO
  result = eval.run(source)
  test.assert_eq(result["status"], 0)
  test.assert_eq(result["output"], "60")
end

# --- Edge: fn parameter as bare identifier ---

rats "fn parameter as bare implicit return"
  source = <<~RUGO
    double = fn(x)
      x * 2
    end
    puts double(21)
  RUGO
  result = eval.run(source)
  test.assert_eq(result["status"], 0)
  test.assert_eq(result["output"], "42")
end

# --- Edge: for k, v in hash tracks both variables ---

rats "for k, v loop variables are not shell commands"
  source = <<~RUGO
    h = {"a" => 1, "b" => 2}
    keys = []
    vals = []
    for k, v in h
      keys = append(keys, k)
      vals = append(vals, v)
    end
    puts len(keys)
    puts len(vals)
  RUGO
  result = eval.run(source)
  test.assert_eq(result["status"], 0)
  test.assert_contains(result["output"], "2")
end

# --- Edge: bare variable inside if body ---

rats "bare variable in if body is not a shell command"
  source = <<~RUGO
    x = 42
    if x > 10
      msg = "big"
      msg
    end
    puts x
  RUGO
  result = eval.run(source)
  test.assert_eq(result["status"], 0)
  test.assert_eq(result["output"], "42")
end

# --- Edge: variable shadows a shell command name ---

rats "variable shadowing shell command is treated as variable"
  source = <<~RUGO
    ls = "not a directory listing"
    puts ls
  RUGO
  result = eval.run(source)
  test.assert_eq(result["status"], 0)
  test.assert_eq(result["output"], "not a directory listing")
end

# --- Negative: shell commands still work ---

rats "shell fallback still works for unknown identifiers"
  result = test.run("rugo run examples/shell_fallback.rugo")
  test.assert_eq(result["status"], 0)
end

# --- Build: bare variable compiles to native binary ---

rats "bare variable compiles to native binary"
  bin = test.tmpdir() + "/bare_var_build_test"
  result = test.run("rugo build rats/fixtures/bare_var_build.rugo -o #{bin}")
  test.assert_eq(result["status"], 0)
  result = test.run(bin)
  test.assert_eq(result["status"], 0)
  test.assert_eq(result["output"], "Hello, Rugo")
end
