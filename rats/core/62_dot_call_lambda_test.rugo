use "test"
use "eval"
use "str"

# --- Positive tests ---

rats "fn dot-call: basic lambda via dot access"
  source = <<~RUGO
    h = {name: "test"}
    h["greet"] = fn() "hello " + h.name end
    puts h.greet()
  RUGO
  result = eval.run(source)
  test.assert_eq(result["status"], 0)
  test.assert_eq(result["lines"][0], "hello test")
end

rats "fn dot-call: lambda with arguments"
  source = <<~RUGO
    record = {name: "Alice"}
    record["rename"] = fn(new_name) record.name = new_name end
    record.rename("Bob")
    puts record.name
  RUGO
  result = eval.run(source)
  test.assert_eq(result["status"], 0)
  test.assert_eq(result["lines"][0], "Bob")
end

rats "fn dot-call: colon syntax hash with lambdas"
  source = <<~RUGO
    ops = {
      add: fn(a, b) a + b end,
      mul: fn(a, b) a * b end
    }
    puts ops.add(2, 3)
    puts ops.mul(4, 5)
  RUGO
  result = eval.run(source)
  test.assert_eq(result["status"], 0)
  test.assert_eq(result["lines"][0], "5")
  test.assert_eq(result["lines"][1], "20")
end

rats "fn dot-call: zero-arg lambda"
  source = <<~RUGO
    h = {ping: fn() "pong" end}
    puts h.ping()
  RUGO
  result = eval.run(source)
  test.assert_eq(result["status"], 0)
  test.assert_eq(result["lines"][0], "pong")
end

rats "fn dot-call: multi-arg lambda"
  source = <<~RUGO
    math = {
      clamp: fn(val, lo, hi)
        if val < lo
          return lo
        end
        if val > hi
          return hi
        end
        return val
      end
    }
    puts math.clamp(5, 0, 10)
    puts math.clamp(-1, 0, 10)
    puts math.clamp(99, 0, 10)
  RUGO
  result = eval.run(source)
  test.assert_eq(result["status"], 0)
  test.assert_eq(result["lines"][0], "5")
  test.assert_eq(result["lines"][1], "0")
  test.assert_eq(result["lines"][2], "10")
end

rats "fn dot-call: both index and dot access work"
  source = <<~RUGO
    ops = {
      add: fn(a, b) a + b end
    }
    puts ops["add"](2, 3)
    puts ops.add(2, 3)
  RUGO
  result = eval.run(source)
  test.assert_eq(result["status"], 0)
  test.assert_eq(result["lines"][0], "5")
  test.assert_eq(result["lines"][1], "5")
end

rats "fn dot-call: factory pattern with closure"
  source = <<~RUGO
    def make_record(name)
      record = {name: name}
      record["greet"] = fn() "Hello, " + record.name end
      return record
    end

    r = make_record("Alice")
    puts r.greet()
  RUGO
  result = eval.run(source)
  test.assert_eq(result["status"], 0)
  test.assert_eq(result["lines"][0], "Hello, Alice")
end

rats "fn dot-call: lambda mutates hash state"
  source = <<~RUGO
    record = {name: "Alice", saved: false}
    record["save"] = fn()
      record.saved = true
      return "saved " + record.name
    end

    puts record.saved
    puts record.save()
    puts record.saved
  RUGO
  result = eval.run(source)
  test.assert_eq(result["status"], 0)
  test.assert_eq(result["lines"][0], "false")
  test.assert_eq(result["lines"][1], "saved Alice")
  test.assert_eq(result["lines"][2], "true")
end

# --- Negative tests ---

rats "fn dot-call: error on missing key"
  source = <<~RUGO
    h = {name: "Alice"}
    h.missing_method()
  RUGO
  result = eval.run(source)
  test.assert_eq(result["status"], 1)
  test.assert_contains(result["output"], "undefined method .missing_method()")
  test.assert_contains(result["output"], "not found in hash")
end

rats "fn dot-call: error calling non-function value"
  source = <<~RUGO
    h = {name: "Alice"}
    h.name()
  RUGO
  result = eval.run(source)
  test.assert_eq(result["status"], 1)
  test.assert_contains(result["output"], "cannot call .name()")
  test.assert_contains(result["output"], "not a function")
end

rats "fn dot-call: compiles to native binary"
  bin = test.tmpdir() + "/fn_dot_call_test"
  result = test.run("rugo build rats/fixtures/fn_dot_call_basic.rugo -o #{bin}")
  test.assert_eq(result["status"], 0)
  result = test.run(bin)
  test.assert_eq(result["status"], 0)
  test.assert_eq(result["lines"][0], "hello test")
end
