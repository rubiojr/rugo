// Code generated by 'egg -o parser.go -package parser -start Program -type Parser -constprefix Rugo rugo.ebnf', DO NOT EDIT.

// Parser generated from rugo.ebnf.

package parser

import (
	"errors"
	"fmt"
	"go/token"
	"strconv"
	"unicode"
	"unicode/utf8"

	"modernc.org/scanner"
)

var _ = unicode.MaxRune





// Symbols
const (
	RugoTOK_EOF = Symbol(0) // EOF
	RugoTOK_00260026 = Symbol(1) // "&&"
	RugoTOK_002d003e = Symbol(2) // "->"
	RugoTOK_003d003e = Symbol(3) // "=>"
	RugoTOK_as = Symbol(4) // "as"
	RugoTOK_bench = Symbol(5) // "bench"
	RugoTOK_break = Symbol(6) // "break"
	RugoTOK_case = Symbol(7) // "case"
	RugoTOK_def = Symbol(8) // "def"
	RugoTOK_else = Symbol(9) // "else"
	RugoTOK_elsif = Symbol(10) // "elsif"
	RugoTOK_end = Symbol(11) // "end"
	RugoTOK_false = Symbol(12) // "false"
	RugoTOK_fn = Symbol(13) // "fn"
	RugoTOK_for = Symbol(14) // "for"
	RugoTOK_if = Symbol(15) // "if"
	RugoTOK_import = Symbol(16) // "import"
	RugoTOK_in = Symbol(17) // "in"
	RugoTOK_next = Symbol(18) // "next"
	RugoTOK_nil = Symbol(19) // "nil"
	RugoTOK_of = Symbol(20) // "of"
	RugoTOK_or = Symbol(21) // "or"
	RugoTOK_parallel = Symbol(22) // "parallel"
	RugoTOK_rats = Symbol(23) // "rats"
	RugoTOK_require = Symbol(24) // "require"
	RugoTOK_return = Symbol(25) // "return"
	RugoTOK_sandbox = Symbol(26) // "sandbox"
	RugoTOK_spawn = Symbol(27) // "spawn"
	RugoTOK_true = Symbol(28) // "true"
	RugoTOK_try = Symbol(29) // "try"
	RugoTOK_use = Symbol(30) // "use"
	RugoTOK_while = Symbol(31) // "while"
	RugoTOK_with = Symbol(32) // "with"
	RugoTOK_007c007c = Symbol(33) // "||"
	RugoTOK_0021 = Symbol(34) // '!'
	RugoTOK_0025 = Symbol(35) // '%'
	RugoTOK_0028 = Symbol(36) // '('
	RugoTOK_0029 = Symbol(37) // ')'
	RugoTOK_002a = Symbol(38) // '*'
	RugoTOK_002b = Symbol(39) // '+'
	RugoTOK_002c = Symbol(40) // ','
	RugoTOK_002d = Symbol(41) // '-'
	RugoTOK_002e = Symbol(42) // '.'
	RugoTOK_002f = Symbol(43) // '/'
	RugoTOK_003a = Symbol(44) // ':'
	RugoTOK_003b = Symbol(45) // ';'
	RugoTOK_003d = Symbol(46) // '='
	RugoTOK_005b = Symbol(47) // '['
	RugoTOK_005d = Symbol(48) // ']'
	RugoTOK_007b = Symbol(49) // '{'
	RugoTOK_007d = Symbol(50) // '}'
	Rugocomp_op = Symbol(51) // comp_op
	Rugofloat_lit = Symbol(52) // float_lit
	Rugoident = Symbol(53) // ident
	Rugointeger = Symbol(54) // integer
	Rugoraw_str_lit = Symbol(55) // raw_str_lit
	Rugostr_lit = Symbol(56) // str_lit
	Rugowhite_space = Symbol(57) // white_space
	RugoProgram = Symbol(58) // Program
	RugoStatement = Symbol(59) // Statement
	RugoUseStmt = Symbol(60) // UseStmt
	RugoImportStmt = Symbol(61) // ImportStmt
	RugoRequireStmt = Symbol(62) // RequireStmt
	RugoSandboxStmt = Symbol(63) // SandboxStmt
	RugoSandboxPerm = Symbol(64) // SandboxPerm
	RugoSandboxList = Symbol(65) // SandboxList
	RugoFuncDef = Symbol(66) // FuncDef
	RugoTestDef = Symbol(67) // TestDef
	RugoBenchDef = Symbol(68) // BenchDef
	RugoParamList = Symbol(69) // ParamList
	RugoParam = Symbol(70) // Param
	RugoBody = Symbol(71) // Body
	RugoIfStmt = Symbol(72) // IfStmt
	RugoCaseExpr = Symbol(73) // CaseExpr
	RugoExprList = Symbol(74) // ExprList
	RugoWhileStmt = Symbol(75) // WhileStmt
	RugoForStmt = Symbol(76) // ForStmt
	RugoBreakStmt = Symbol(77) // BreakStmt
	RugoNextStmt = Symbol(78) // NextStmt
	RugoReturnStmt = Symbol(79) // ReturnStmt
	RugoAssignOrExpr = Symbol(80) // AssignOrExpr
	RugoExpr = Symbol(81) // Expr
	RugoOrExpr = Symbol(82) // OrExpr
	RugoAndExpr = Symbol(83) // AndExpr
	RugoCompExpr = Symbol(84) // CompExpr
	RugoAddExpr = Symbol(85) // AddExpr
	RugoMulExpr = Symbol(86) // MulExpr
	RugoUnaryExpr = Symbol(87) // UnaryExpr
	RugoPostfix = Symbol(88) // Postfix
	RugoSuffix = Symbol(89) // Suffix
	RugoArgList = Symbol(90) // ArgList
	RugoPrimary = Symbol(91) // Primary
	RugoTryExpr = Symbol(92) // TryExpr
	RugoSpawnExpr = Symbol(93) // SpawnExpr
	RugoParallelExpr = Symbol(94) // ParallelExpr
	RugoFnExpr = Symbol(95) // FnExpr
	RugoArrayLit = Symbol(96) // ArrayLit
	RugoHashLit = Symbol(97) // HashLit
	RugoHashEntry = Symbol(98) // HashEntry
)

const RugoSymbolNames = "EOF\"&&\"\"->\"\"=>\"\"as\"\"bench\"\"break\"\"case\"\"def\"\"else\"\"elsif\"\"end\"\"false\"\"fn\"\"for\"\"if\"\"import\"\"in\"\"next\"\"nil\"\"of\"\"or\"\"parallel\"\"rats\"\"require\"\"return\"\"sandbox\"\"spawn\"\"true\"\"try\"\"use\"\"while\"\"with\"\"||\"'!''%''('')''*''+'',''-''.''/'':'';''=''['']''{''}'comp_opfloat_litidentintegerraw_str_litstr_litwhite_spaceProgramStatementUseStmtImportStmtRequireStmtSandboxStmtSandboxPermSandboxListFuncDefTestDefBenchDefParamListParamBodyIfStmtCaseExprExprListWhileStmtForStmtBreakStmtNextStmtReturnStmtAssignOrExprExprOrExprAndExprCompExprAddExprMulExprUnaryExprPostfixSuffixArgListPrimaryTryExprSpawnExprParallelExprFnExprArrayLitHashLitHashEntry"

var SymbolIndex = [...]uint16{0, 3, 7, 11, 15, 19, 26, 33, 39, 44, 50, 57, 62, 69, 73, 78, 82, 90, 94, 100, 105, 109, 113, 123, 129, 138, 146, 155, 162, 168, 173, 178, 185, 191, 195, 198, 201, 204, 207, 210, 213, 216, 219, 222, 225, 228, 231, 234, 237, 240, 243, 246, 253, 262, 267, 274, 285, 292, 303, 310, 319, 326, 336, 347, 358, 369, 380, 387, 394, 402, 411, 416, 420, 426, 434, 442, 451, 458, 467, 475, 485, 497, 501, 507, 514, 522, 529, 536, 545, 552, 558, 565, 572, 579, 588, 600, 606, 614, 621, 630, }


func (s Symbol) String() string {
	idx := int(s) - 0
	if s < 0 || idx >= len(SymbolIndex)-1 {
		return "Symbol(" + strconv.FormatInt(int64(s), 10) + ")"
	}
	return RugoSymbolNames[SymbolIndex[idx]:SymbolIndex[idx+1]]
}

var errorSets = [...][]Symbol{
{RugoTOK_end},
{RugoTOK_fn},
{RugoTOK_for},
{RugoTOK_if},
{RugoTOK_import},
{RugoTOK_002c, RugoTOK_in},
{RugoTOK_in},
{RugoTOK_next},
{RugoTOK_00260026},
{RugoHashLit, RugoArrayLit, RugoFnExpr, RugoParallelExpr, RugoSpawnExpr, RugoTryExpr, RugoPrimary, RugoPostfix, RugoUnaryExpr, RugoMulExpr, RugoAddExpr, RugoCompExpr, RugoAndExpr, RugoOrExpr, RugoExpr, RugoAssignOrExpr, RugoReturnStmt, RugoNextStmt, RugoBreakStmt, RugoForStmt, RugoWhileStmt, RugoCaseExpr, RugoIfStmt, RugoBenchDef, RugoTestDef, RugoFuncDef, RugoSandboxStmt, RugoRequireStmt, RugoImportStmt, RugoUseStmt, RugoStatement, Rugostr_lit, Rugoraw_str_lit, Rugointeger, Rugoident, Rugofloat_lit, RugoTOK_007b, RugoTOK_005b, RugoTOK_003b, RugoTOK_002d, RugoTOK_0028, RugoTOK_0021, RugoTOK_while, RugoTOK_use, RugoTOK_try, RugoTOK_true, RugoTOK_spawn, RugoTOK_sandbox, RugoTOK_return, RugoTOK_require, RugoTOK_rats, RugoTOK_parallel, RugoTOK_nil, RugoTOK_next, RugoTOK_import, RugoTOK_if, RugoTOK_for, RugoTOK_fn, RugoTOK_false, RugoTOK_end, RugoTOK_def, RugoTOK_case, RugoTOK_break, RugoTOK_bench, RugoTOK_002d003e},
{RugoHashLit, RugoArrayLit, RugoFnExpr, RugoParallelExpr, RugoSpawnExpr, RugoTryExpr, RugoPrimary, RugoPostfix, RugoUnaryExpr, RugoMulExpr, RugoAddExpr, RugoCompExpr, RugoAndExpr, RugoOrExpr, RugoExpr, RugoAssignOrExpr, RugoReturnStmt, RugoNextStmt, RugoBreakStmt, RugoForStmt, RugoWhileStmt, RugoCaseExpr, RugoIfStmt, RugoBenchDef, RugoTestDef, RugoFuncDef, RugoSandboxStmt, RugoRequireStmt, RugoImportStmt, RugoUseStmt, RugoStatement, Rugostr_lit, Rugoraw_str_lit, Rugointeger, Rugoident, Rugofloat_lit, RugoTOK_007b, RugoTOK_005b, RugoTOK_003b, RugoTOK_002d, RugoTOK_0028, RugoTOK_0021, RugoTOK_while, RugoTOK_use, RugoTOK_try, RugoTOK_true, RugoTOK_spawn, RugoTOK_sandbox, RugoTOK_return, RugoTOK_require, RugoTOK_rats, RugoTOK_parallel, RugoTOK_of, RugoTOK_nil, RugoTOK_next, RugoTOK_import, RugoTOK_if, RugoTOK_for, RugoTOK_fn, RugoTOK_false, RugoTOK_end, RugoTOK_elsif, RugoTOK_else, RugoTOK_def, RugoTOK_case, RugoTOK_break, RugoTOK_bench, RugoTOK_002d003e},
{RugoHashLit, RugoArrayLit, RugoFnExpr, RugoParallelExpr, RugoSpawnExpr, RugoTryExpr, RugoPrimary, RugoPostfix, RugoUnaryExpr, RugoMulExpr, RugoAddExpr, RugoCompExpr, RugoAndExpr, RugoOrExpr, RugoExpr, RugoAssignOrExpr, RugoReturnStmt, RugoNextStmt, RugoBreakStmt, RugoForStmt, RugoWhileStmt, RugoCaseExpr, RugoIfStmt, RugoBenchDef, RugoTestDef, RugoFuncDef, RugoSandboxStmt, RugoRequireStmt, RugoImportStmt, RugoUseStmt, RugoStatement, Rugostr_lit, Rugoraw_str_lit, Rugointeger, Rugoident, Rugofloat_lit, RugoTOK_007b, RugoTOK_005b, RugoTOK_003b, RugoTOK_002d, RugoTOK_0028, RugoTOK_0021, RugoTOK_while, RugoTOK_use, RugoTOK_try, RugoTOK_true, RugoTOK_spawn, RugoTOK_sandbox, RugoTOK_return, RugoTOK_require, RugoTOK_rats, RugoTOK_parallel, RugoTOK_nil, RugoTOK_next, RugoTOK_import, RugoTOK_if, RugoTOK_for, RugoTOK_fn, RugoTOK_false, RugoTOK_end, RugoTOK_elsif, RugoTOK_else, RugoTOK_def, RugoTOK_case, RugoTOK_break, RugoTOK_bench, RugoTOK_002d003e},
{RugoTOK_or},
{RugoTOK_parallel},
{RugoTOK_rats},
{RugoTOK_require},
{RugoTOK_return},
{RugoTOK_sandbox},
{RugoTOK_spawn},
{RugoTOK_try},
{RugoTOK_use},
{RugoTOK_while},
{RugoTOK_007c007c},
{RugoTOK_002f, RugoTOK_002a, RugoTOK_0025},
{RugoTOK_005b, RugoTOK_002e, RugoTOK_0028},
{RugoTOK_0028},
{RugoParam, Rugoident, RugoTOK_0029},
{RugoTOK_0029},
{RugoTOK_002d, RugoTOK_002b},
{RugoTOK_003d003e},
{RugoTOK_with, RugoTOK_as},
{RugoTOK_005d, RugoTOK_002c},
{RugoTOK_007d, RugoTOK_002c},
{RugoTOK_002c},
{RugoTOK_003a},
{RugoTOK_003d},
{Rugostr_lit, Rugointeger, RugoTOK_005b},
{RugoTOK_005b},
{RugoTOK_005d},
{RugoTOK_007b},
{RugoTOK_as},
{RugoHashLit, RugoArrayLit, RugoFnExpr, RugoParallelExpr, RugoSpawnExpr, RugoTryExpr, RugoPrimary, RugoPostfix, RugoUnaryExpr, RugoMulExpr, RugoAddExpr, RugoCompExpr, RugoAndExpr, RugoOrExpr, RugoExpr, RugoAssignOrExpr, RugoReturnStmt, RugoNextStmt, RugoBreakStmt, RugoForStmt, RugoWhileStmt, RugoCaseExpr, RugoIfStmt, RugoBenchDef, RugoTestDef, RugoFuncDef, RugoSandboxStmt, RugoRequireStmt, RugoImportStmt, RugoUseStmt, RugoStatement, Rugostr_lit, Rugoraw_str_lit, Rugointeger, Rugoident, Rugofloat_lit, RugoTOK_007b, RugoTOK_005b, RugoTOK_003b, RugoTOK_002d, RugoTOK_0028, RugoTOK_0021, RugoTOK_while, RugoTOK_use, RugoTOK_try, RugoTOK_true, RugoTOK_spawn, RugoTOK_sandbox, RugoTOK_return, RugoTOK_require, RugoTOK_rats, RugoTOK_parallel, RugoTOK_nil, RugoTOK_next, RugoTOK_import, RugoTOK_if, RugoTOK_for, RugoTOK_fn, RugoTOK_false, RugoTOK_end, RugoTOK_def, RugoTOK_case, RugoTOK_break, RugoTOK_bench},
{RugoHashLit, RugoArrayLit, RugoFnExpr, RugoParallelExpr, RugoSpawnExpr, RugoTryExpr, RugoPrimary, RugoPostfix, RugoUnaryExpr, RugoMulExpr, RugoAddExpr, RugoCompExpr, RugoAndExpr, RugoOrExpr, RugoExpr, RugoAssignOrExpr, RugoReturnStmt, RugoNextStmt, RugoBreakStmt, RugoForStmt, RugoWhileStmt, RugoCaseExpr, RugoIfStmt, RugoBenchDef, RugoTestDef, RugoFuncDef, RugoSandboxStmt, RugoRequireStmt, RugoImportStmt, RugoUseStmt, Rugostr_lit, Rugoraw_str_lit, Rugointeger, Rugoident, Rugofloat_lit, RugoTOK_007b, RugoTOK_005b, RugoTOK_003b, RugoTOK_002d, RugoTOK_0028, RugoTOK_0021, RugoTOK_while, RugoTOK_use, RugoTOK_try, RugoTOK_true, RugoTOK_spawn, RugoTOK_sandbox, RugoTOK_return, RugoTOK_require, RugoTOK_rats, RugoTOK_parallel, RugoTOK_nil, RugoTOK_next, RugoTOK_import, RugoTOK_if, RugoTOK_for, RugoTOK_fn, RugoTOK_false, RugoTOK_def, RugoTOK_case, RugoTOK_break, RugoTOK_bench},
{RugoHashLit, RugoArrayLit, RugoFnExpr, RugoParallelExpr, RugoSpawnExpr, RugoTryExpr, RugoPrimary, RugoPostfix, RugoUnaryExpr, RugoMulExpr, RugoAddExpr, RugoCompExpr, RugoAndExpr, RugoOrExpr, RugoExpr, RugoCaseExpr, Rugostr_lit, Rugoraw_str_lit, Rugointeger, Rugoident, Rugofloat_lit, RugoTOK_007b, RugoTOK_005b, RugoTOK_002d, RugoTOK_0028, RugoTOK_0021, RugoTOK_while, RugoTOK_use, RugoTOK_try, RugoTOK_true, RugoTOK_spawn, RugoTOK_sandbox, RugoTOK_return, RugoTOK_require, RugoTOK_rats, RugoTOK_parallel, RugoTOK_nil, RugoTOK_next, RugoTOK_import, RugoTOK_if, RugoTOK_for, RugoTOK_fn, RugoTOK_false, RugoTOK_def, RugoTOK_case, RugoTOK_break, RugoTOK_bench},
{RugoHashLit, RugoArrayLit, RugoFnExpr, RugoParallelExpr, RugoSpawnExpr, RugoTryExpr, RugoPrimary, RugoPostfix, RugoUnaryExpr, RugoMulExpr, RugoAddExpr, RugoCompExpr, RugoAndExpr, RugoOrExpr, RugoExpr, RugoAssignOrExpr, RugoReturnStmt, RugoNextStmt, RugoBreakStmt, RugoForStmt, RugoWhileStmt, RugoCaseExpr, RugoIfStmt, RugoBenchDef, RugoTestDef, RugoFuncDef, RugoSandboxStmt, RugoRequireStmt, RugoImportStmt, RugoUseStmt, RugoStatement, Rugostr_lit, Rugoraw_str_lit, Rugointeger, Rugoident, Rugofloat_lit, RugoTOK_007b, RugoTOK_005b, RugoTOK_003b, RugoTOK_002d, RugoTOK_0028, RugoTOK_0021, RugoTOK_while, RugoTOK_use, RugoTOK_try, RugoTOK_true, RugoTOK_spawn, RugoTOK_sandbox, RugoTOK_return, RugoTOK_require, RugoTOK_rats, RugoTOK_parallel, RugoTOK_nil, RugoTOK_next, RugoTOK_import, RugoTOK_if, RugoTOK_for, RugoTOK_fn, RugoTOK_false, RugoTOK_end, RugoTOK_elsif, RugoTOK_else, RugoTOK_def, RugoTOK_case, RugoTOK_break, RugoTOK_bench},
{Rugocomp_op},
{Rugostr_lit, Rugoident},
{Rugoident},
{Rugostr_lit, Rugointeger},
{Rugostr_lit},
{RugoTOK_bench},
{RugoTOK_break},
{RugoHashLit, RugoArrayLit, RugoFnExpr, RugoParallelExpr, RugoSpawnExpr, RugoTryExpr, RugoPrimary, RugoPostfix, RugoUnaryExpr, RugoMulExpr, RugoAddExpr, RugoCompExpr, RugoAndExpr, RugoOrExpr, RugoExpr, RugoCaseExpr, Rugostr_lit, Rugoraw_str_lit, Rugointeger, Rugoident, Rugofloat_lit, RugoTOK_007b, RugoTOK_005b, RugoTOK_002d, RugoTOK_0029, RugoTOK_0028, RugoTOK_0021, RugoTOK_try, RugoTOK_true, RugoTOK_spawn, RugoTOK_parallel, RugoTOK_nil, RugoTOK_fn, RugoTOK_false, RugoTOK_case},
{RugoHashLit, RugoArrayLit, RugoFnExpr, RugoParallelExpr, RugoSpawnExpr, RugoTryExpr, RugoPrimary, RugoPostfix, RugoUnaryExpr, RugoMulExpr, RugoAddExpr, RugoCompExpr, RugoAndExpr, RugoOrExpr, RugoCaseExpr, Rugostr_lit, Rugoraw_str_lit, Rugointeger, Rugoident, Rugofloat_lit, RugoTOK_007b, RugoTOK_005d, RugoTOK_005b, RugoTOK_002d, RugoTOK_0028, RugoTOK_0021, RugoTOK_try, RugoTOK_true, RugoTOK_spawn, RugoTOK_parallel, RugoTOK_nil, RugoTOK_fn, RugoTOK_false, RugoTOK_case},
{RugoHashLit, RugoArrayLit, RugoFnExpr, RugoParallelExpr, RugoSpawnExpr, RugoTryExpr, RugoPrimary, RugoPostfix, RugoUnaryExpr, RugoMulExpr, RugoAddExpr, RugoCompExpr, RugoAndExpr, RugoOrExpr, RugoExpr, RugoCaseExpr, Rugostr_lit, Rugoraw_str_lit, Rugointeger, Rugoident, Rugofloat_lit, RugoTOK_007d, RugoTOK_007b, RugoTOK_005b, RugoTOK_002d, RugoTOK_0028, RugoTOK_0021, RugoTOK_try, RugoTOK_true, RugoTOK_spawn, RugoTOK_parallel, RugoTOK_nil, RugoTOK_fn, RugoTOK_false, RugoTOK_case},
{RugoHashLit, RugoArrayLit, RugoFnExpr, RugoParallelExpr, RugoSpawnExpr, RugoTryExpr, RugoPrimary, RugoPostfix, RugoUnaryExpr, RugoMulExpr, RugoAddExpr, RugoCompExpr, RugoAndExpr, RugoOrExpr, RugoExpr, RugoCaseExpr, Rugostr_lit, Rugoraw_str_lit, Rugointeger, Rugoident, Rugofloat_lit, RugoTOK_007b, RugoTOK_005b, RugoTOK_002d, RugoTOK_0028, RugoTOK_0021, RugoTOK_try, RugoTOK_true, RugoTOK_spawn, RugoTOK_parallel, RugoTOK_nil, RugoTOK_fn, RugoTOK_false, RugoTOK_case},
{RugoHashLit, RugoArrayLit, RugoFnExpr, RugoParallelExpr, RugoSpawnExpr, RugoTryExpr, RugoPrimary, RugoPostfix, RugoUnaryExpr, RugoMulExpr, RugoAddExpr, RugoCompExpr, RugoAndExpr, RugoOrExpr, RugoCaseExpr, Rugostr_lit, Rugoraw_str_lit, Rugointeger, Rugoident, Rugofloat_lit, RugoTOK_007b, RugoTOK_005b, RugoTOK_002d, RugoTOK_0028, RugoTOK_0021, RugoTOK_try, RugoTOK_true, RugoTOK_spawn, RugoTOK_parallel, RugoTOK_nil, RugoTOK_fn, RugoTOK_false, RugoTOK_case},
{RugoHashLit, RugoArrayLit, RugoFnExpr, RugoParallelExpr, RugoSpawnExpr, RugoTryExpr, RugoPrimary, RugoPostfix, RugoUnaryExpr, RugoMulExpr, RugoAddExpr, RugoCompExpr, RugoAndExpr, RugoCaseExpr, Rugostr_lit, Rugoraw_str_lit, Rugointeger, Rugoident, Rugofloat_lit, RugoTOK_007b, RugoTOK_005b, RugoTOK_002d, RugoTOK_0028, RugoTOK_0021, RugoTOK_try, RugoTOK_true, RugoTOK_spawn, RugoTOK_parallel, RugoTOK_nil, RugoTOK_fn, RugoTOK_false, RugoTOK_case},
{RugoHashLit, RugoArrayLit, RugoFnExpr, RugoParallelExpr, RugoSpawnExpr, RugoTryExpr, RugoPrimary, RugoPostfix, RugoUnaryExpr, RugoMulExpr, RugoAddExpr, RugoCompExpr, RugoCaseExpr, Rugostr_lit, Rugoraw_str_lit, Rugointeger, Rugoident, Rugofloat_lit, RugoTOK_007b, RugoTOK_005b, RugoTOK_002d, RugoTOK_0028, RugoTOK_0021, RugoTOK_try, RugoTOK_true, RugoTOK_spawn, RugoTOK_parallel, RugoTOK_nil, RugoTOK_fn, RugoTOK_false, RugoTOK_case},
{RugoHashLit, RugoArrayLit, RugoFnExpr, RugoParallelExpr, RugoSpawnExpr, RugoTryExpr, RugoPrimary, RugoPostfix, RugoUnaryExpr, RugoMulExpr, RugoAddExpr, RugoCaseExpr, Rugostr_lit, Rugoraw_str_lit, Rugointeger, Rugoident, Rugofloat_lit, RugoTOK_007b, RugoTOK_005b, RugoTOK_002d, RugoTOK_0028, RugoTOK_0021, RugoTOK_try, RugoTOK_true, RugoTOK_spawn, RugoTOK_parallel, RugoTOK_nil, RugoTOK_fn, RugoTOK_false, RugoTOK_case},
{RugoHashLit, RugoArrayLit, RugoFnExpr, RugoParallelExpr, RugoSpawnExpr, RugoTryExpr, RugoPrimary, RugoPostfix, RugoUnaryExpr, RugoMulExpr, RugoCaseExpr, Rugostr_lit, Rugoraw_str_lit, Rugointeger, Rugoident, Rugofloat_lit, RugoTOK_007b, RugoTOK_005b, RugoTOK_002d, RugoTOK_0028, RugoTOK_0021, RugoTOK_try, RugoTOK_true, RugoTOK_spawn, RugoTOK_parallel, RugoTOK_nil, RugoTOK_fn, RugoTOK_false, RugoTOK_case},
{RugoHashLit, RugoArrayLit, RugoFnExpr, RugoParallelExpr, RugoSpawnExpr, RugoTryExpr, RugoPrimary, RugoPostfix, RugoUnaryExpr, RugoCaseExpr, Rugostr_lit, Rugoraw_str_lit, Rugointeger, Rugoident, Rugofloat_lit, RugoTOK_007b, RugoTOK_005b, RugoTOK_002d, RugoTOK_0028, RugoTOK_0021, RugoTOK_try, RugoTOK_true, RugoTOK_spawn, RugoTOK_parallel, RugoTOK_nil, RugoTOK_fn, RugoTOK_false, RugoTOK_case},
{RugoHashLit, RugoArrayLit, RugoFnExpr, RugoParallelExpr, RugoSpawnExpr, RugoTryExpr, RugoPrimary, RugoPostfix, RugoCaseExpr, Rugostr_lit, Rugoraw_str_lit, Rugointeger, Rugoident, Rugofloat_lit, RugoTOK_007b, RugoTOK_005b, RugoTOK_002d, RugoTOK_0028, RugoTOK_0021, RugoTOK_try, RugoTOK_true, RugoTOK_spawn, RugoTOK_parallel, RugoTOK_nil, RugoTOK_fn, RugoTOK_false, RugoTOK_case},
{RugoHashLit, RugoArrayLit, RugoFnExpr, RugoParallelExpr, RugoSpawnExpr, RugoTryExpr, RugoPrimary, RugoCaseExpr, Rugostr_lit, Rugoraw_str_lit, Rugointeger, Rugoident, Rugofloat_lit, RugoTOK_007b, RugoTOK_005b, RugoTOK_002d, RugoTOK_0028, RugoTOK_0021, RugoTOK_try, RugoTOK_true, RugoTOK_spawn, RugoTOK_parallel, RugoTOK_nil, RugoTOK_fn, RugoTOK_false, RugoTOK_case},
{RugoHashLit, RugoArrayLit, RugoFnExpr, RugoParallelExpr, RugoSpawnExpr, RugoTryExpr, RugoPrimary, RugoCaseExpr, Rugostr_lit, Rugoraw_str_lit, Rugointeger, Rugoident, Rugofloat_lit, RugoTOK_007b, RugoTOK_005b, RugoTOK_0028, RugoTOK_try, RugoTOK_true, RugoTOK_spawn, RugoTOK_parallel, RugoTOK_nil, RugoTOK_fn, RugoTOK_false, RugoTOK_case},
{RugoHashLit, RugoArrayLit, RugoFnExpr, RugoParallelExpr, RugoSpawnExpr, RugoTryExpr, RugoCaseExpr, Rugostr_lit, Rugoraw_str_lit, Rugointeger, Rugoident, Rugofloat_lit, RugoTOK_007b, RugoTOK_005b, RugoTOK_0028, RugoTOK_try, RugoTOK_true, RugoTOK_spawn, RugoTOK_parallel, RugoTOK_nil, RugoTOK_fn, RugoTOK_false, RugoTOK_case},
{Rugostr_lit, Rugoraw_str_lit, Rugointeger, Rugoident, Rugofloat_lit, RugoTOK_007b, RugoTOK_005b, RugoTOK_0028, RugoTOK_try, RugoTOK_true, RugoTOK_spawn, RugoTOK_parallel, RugoTOK_nil, RugoTOK_fn, RugoTOK_false, RugoTOK_case},
{RugoTOK_case},
{RugoTOK_def},
{RugoTOK_of, RugoTOK_end, RugoTOK_elsif, RugoTOK_else},
{RugoTOK_end, RugoTOK_elsif, RugoTOK_else},
}



type Parser struct{
	cache     [][]int32
	eof       bool
	errBudget int
	id        rune  // from scanSep, valid if .n != 0
	n         int   // from scanSep, valid if != 0
	off       int
	sc        *scanner.RecScanner
	src       []byte
	tok       scanner.Token // current lookahead
	tokIndex  int32 // For scanner.Token(tokIndex)
}

type Symbol int32


// scan recognizes longest UTF-8 lexemes. Lower IDs take precedence on same length.
//
//	id   0: $
//	id   1: &&
//	id   2: ->
//	id   3: =>
//	id   4: as
//	id   5: bench
//	id   6: break
//	id   7: case
//	id   8: def
//	id   9: else
//	id  10: elsif
//	id  11: end
//	id  12: false
//	id  13: fn
//	id  14: for
//	id  15: if
//	id  16: import
//	id  17: in
//	id  18: next
//	id  19: nil
//	id  20: of
//	id  21: or
//	id  22: parallel
//	id  23: rats
//	id  24: require
//	id  25: return
//	id  26: sandbox
//	id  27: spawn
//	id  28: true
//	id  29: try
//	id  30: use
//	id  31: while
//	id  32: with
//	id  33: \|\|
//	id  34: !
//	id  35: %
//	id  36: \(
//	id  37: \)
//	id  38: \*
//	id  39: \+
//	id  40: ,
//	id  41: -
//	id  42: \.
//	id  43: /
//	id  44: :
//	id  45: ;
//	id  46: =
//	id  47: \[
//	id  48: \]
//	id  49: \{
//	id  50: \}
//	id  51: ((==)|(!=)|(<=)|(>=)|(<)|(>))
//	id  52: ([0-9]+\.[0-9]+)
//	id  53: ([a-zA-Z_][a-zA-Z0-9_]*)
//	id  54: ([0-9]+)
//	id  55: (')((([^'\\])|(\\)([^\n])))*(')
//	id  56: (")((([^"\\])|(\\)([^\n])))*(")
//	id  57: ( |\t|\n|\r)
//
// ID == -1 is returned when no lexeme was recognized.
func (*Parser) scan(s []byte) (id, length int) {
	const endOfText = 0x110000
	var pos, pos0, width, width1 int
	id = -1
	var r, r1 rune
	_ = pos0
	_ = r
	_ = r1
	_ = width1
	step := func(pos int) (r rune, n int) { if pos < len(s) { c := s[pos]; if c < utf8.RuneSelf { return rune(c), 1 }; return utf8.DecodeRune(s[pos:]) }; return endOfText, 0 }
	move := func() { pos += width; if r, width = r1, width1; r != endOfText { 	r1, width1 = step(pos+width); }; }
	accept := func(x rune) bool { if r == x { move(); return true }; return false }
_ = accept
	accept2 := func(x rune) bool { if r <= x { move(); return true }; return false }
_ = accept2
	r, r1 = endOfText, endOfText
	width, width1 = 0, 0
	r, width = step(pos);	if r != endOfText {
		r1, width1 = step(pos+width); }
	if accept('\t') { goto l91 }
	if accept('\n') { goto l93 }
	if accept('\r') { goto l95 }
	if accept(' ') { goto l97 }
	if accept('!') { goto l99 }
	if accept('"') { goto l105 }
	if accept('%') { goto l131 }
	if accept('&') { goto l133 }
	if accept('\'') { goto l138 }
	if accept('(') { goto l164 }
	if accept(')') { goto l166 }
	if accept('*') { goto l168 }
	if accept('+') { goto l170 }
	if accept(',') { goto l172 }
	if accept('-') { goto l174 }
	if accept('.') { goto l180 }
	if accept('/') { goto l182 }
	if accept(':') { goto l197 }
	if accept(';') { goto l199 }
	if accept('<') { goto l201 }
	if accept('=') { goto l207 }
	if accept('>') { goto l217 }
	if accept('[') { goto l231 }
	if accept(']') { goto l233 }
	if accept('a') { goto l235 }
	if accept('b') { goto l245 }
	if accept('c') { goto l297 }
	if accept('d') { goto l319 }
	if accept('e') { goto l335 }
	if accept('f') { goto l381 }
	if accept('i') { goto l427 }
	if accept('n') { goto l473 }
	if accept('o') { goto l507 }
	if accept('p') { goto l523 }
	if accept('r') { goto l569 }
	if accept('s') { goto l651 }
	if accept('t') { goto l715 }
	if accept('u') { goto l743 }
	if accept('w') { goto l759 }
	if accept('{') { goto l805 }
	if accept('|') { goto l807 }
	if accept('}') { goto l812 }
	if r < '0' { goto l84out }
	if accept2('9') { goto l184 }
l84out:
	if r < 'A' { goto l86out }
	if accept2('Z') { goto l223 }
	if accept('_') { goto l223 }
	if r < 'g' { goto l86out }
	if accept2('h') { goto l223 }
	if r < 'j' { goto l86out }
	if accept2('m') { goto l223 }
	if accept('q') { goto l223 }
	if accept('v') { goto l223 }
	if r < 'x' { goto l86out }
	if accept2('z') { goto l223 }
l86out:
	if r == endOfText { goto l814 }
	return id, length
l91:
	id, length = 57, pos
	return id, length
l93:
	id, length = 57, pos
	return id, length
l95:
	id, length = 57, pos
	return id, length
l97:
	id, length = 57, pos
	return id, length
l99:
	id, length = 34, pos
	if accept('=') { goto l103 }
	return id, length
l103:
	id, length = 51, pos
	return id, length
l105:
	if accept('"') { goto l112 }
	if accept('\\') { goto l114 }
	if accept2('!') { goto l124 }
	if r < '#' { goto l109out }
	if accept2('[') { goto l124 }
	if r < ']' { goto l109out }
	if accept2('\U0010ffff') { goto l124 }
l109out:
	return id, length
l112:
	id, length = 56, pos
	return id, length
l114:
	if accept2('\t') { goto l117 }
	if r < '\v' { goto l114out }
	if accept2('\U0010ffff') { goto l117 }
l114out:
	return id, length
l117:
	if accept('"') { goto l112 }
	if accept('\\') { goto l114 }
	if accept2('!') { goto l124 }
	if r < '#' { goto l121out }
	if accept2('[') { goto l124 }
	if r < ']' { goto l121out }
	if accept2('\U0010ffff') { goto l124 }
l121out:
	return id, length
l124:
	if accept('"') { goto l112 }
	if accept('\\') { goto l114 }
	if accept2('!') { goto l124 }
	if r < '#' { goto l128out }
	if accept2('[') { goto l124 }
	if r < ']' { goto l128out }
	if accept2('\U0010ffff') { goto l124 }
l128out:
	return id, length
l131:
	id, length = 35, pos
	return id, length
l133:
	if accept('&') { goto l136 }
	return id, length
l136:
	id, length = 1, pos
	return id, length
l138:
	if accept('\'') { goto l145 }
	if accept('\\') { goto l147 }
	if accept2('&') { goto l157 }
	if r < '(' { goto l142out }
	if accept2('[') { goto l157 }
	if r < ']' { goto l142out }
	if accept2('\U0010ffff') { goto l157 }
l142out:
	return id, length
l145:
	id, length = 55, pos
	return id, length
l147:
	if accept2('\t') { goto l150 }
	if r < '\v' { goto l147out }
	if accept2('\U0010ffff') { goto l150 }
l147out:
	return id, length
l150:
	if accept('\'') { goto l145 }
	if accept('\\') { goto l147 }
	if accept2('&') { goto l157 }
	if r < '(' { goto l154out }
	if accept2('[') { goto l157 }
	if r < ']' { goto l154out }
	if accept2('\U0010ffff') { goto l157 }
l154out:
	return id, length
l157:
	if accept('\'') { goto l145 }
	if accept('\\') { goto l147 }
	if accept2('&') { goto l157 }
	if r < '(' { goto l161out }
	if accept2('[') { goto l157 }
	if r < ']' { goto l161out }
	if accept2('\U0010ffff') { goto l157 }
l161out:
	return id, length
l164:
	id, length = 36, pos
	return id, length
l166:
	id, length = 37, pos
	return id, length
l168:
	id, length = 38, pos
	return id, length
l170:
	id, length = 39, pos
	return id, length
l172:
	id, length = 40, pos
	return id, length
l174:
	id, length = 41, pos
	if accept('>') { goto l178 }
	return id, length
l178:
	id, length = 2, pos
	return id, length
l180:
	id, length = 42, pos
	return id, length
l182:
	id, length = 43, pos
	return id, length
l184:
	id, length = 54, pos
	if accept('.') { goto l190 }
	if r < '0' { goto l187out }
	if accept2('9') { goto l184 }
l187out:
	return id, length
l190:
	if r < '0' { goto l190out }
	if accept2('9') { goto l193 }
l190out:
	return id, length
l193:
	id, length = 52, pos
	if r < '0' { goto l194out }
	if accept2('9') { goto l193 }
l194out:
	return id, length
l197:
	id, length = 44, pos
	return id, length
l199:
	id, length = 45, pos
	return id, length
l201:
	id, length = 51, pos
	if accept('=') { goto l205 }
	return id, length
l205:
	id, length = 51, pos
	return id, length
l207:
	id, length = 46, pos
	if accept('=') { goto l213 }
	if accept('>') { goto l215 }
	return id, length
l213:
	id, length = 51, pos
	return id, length
l215:
	id, length = 3, pos
	return id, length
l217:
	id, length = 51, pos
	if accept('=') { goto l221 }
	return id, length
l221:
	id, length = 51, pos
	return id, length
l223:
	id, length = 53, pos
	if r < '0' { goto l224out }
	if accept2('9') { goto l227 }
	if r < 'A' { goto l224out }
	if accept2('Z') { goto l227 }
	if accept('_') { goto l227 }
	if r < 'a' { goto l224out }
	if accept2('z') { goto l227 }
l224out:
	return id, length
l227:
	id, length = 53, pos
	if r < '0' { goto l228out }
	if accept2('9') { goto l227 }
	if r < 'A' { goto l228out }
	if accept2('Z') { goto l227 }
	if accept('_') { goto l227 }
	if r < 'a' { goto l228out }
	if accept2('z') { goto l227 }
l228out:
	return id, length
l231:
	id, length = 47, pos
	return id, length
l233:
	id, length = 48, pos
	return id, length
l235:
	id, length = 53, pos
	if accept('s') { goto l241 }
	if r < '0' { goto l238out }
	if accept2('9') { goto l227 }
	if r < 'A' { goto l238out }
	if accept2('Z') { goto l227 }
	if accept('_') { goto l227 }
	if r < 'a' { goto l238out }
	if accept2('r') { goto l227 }
	if r < 't' { goto l238out }
	if accept2('z') { goto l227 }
l238out:
	return id, length
l241:
	id, length = 4, pos
	if r < '0' { goto l242out }
	if accept2('9') { goto l227 }
	if r < 'A' { goto l242out }
	if accept2('Z') { goto l227 }
	if accept('_') { goto l227 }
	if r < 'a' { goto l242out }
	if accept2('z') { goto l227 }
l242out:
	return id, length
l245:
	id, length = 53, pos
	if accept('e') { goto l253 }
	if accept('r') { goto l275 }
	if r < '0' { goto l250out }
	if accept2('9') { goto l227 }
	if r < 'A' { goto l250out }
	if accept2('Z') { goto l227 }
	if accept('_') { goto l227 }
	if r < 'a' { goto l250out }
	if accept2('d') { goto l227 }
	if r < 'f' { goto l250out }
	if accept2('q') { goto l227 }
	if r < 's' { goto l250out }
	if accept2('z') { goto l227 }
l250out:
	return id, length
l253:
	id, length = 53, pos
	if accept('n') { goto l259 }
	if r < '0' { goto l256out }
	if accept2('9') { goto l227 }
	if r < 'A' { goto l256out }
	if accept2('Z') { goto l227 }
	if accept('_') { goto l227 }
	if r < 'a' { goto l256out }
	if accept2('m') { goto l227 }
	if r < 'o' { goto l256out }
	if accept2('z') { goto l227 }
l256out:
	return id, length
l259:
	id, length = 53, pos
	if accept('c') { goto l265 }
	if r < '0' { goto l262out }
	if accept2('9') { goto l227 }
	if r < 'A' { goto l262out }
	if accept2('Z') { goto l227 }
	if accept('_') { goto l227 }
	if r < 'a' { goto l262out }
	if accept2('b') { goto l227 }
	if r < 'd' { goto l262out }
	if accept2('z') { goto l227 }
l262out:
	return id, length
l265:
	id, length = 53, pos
	if accept('h') { goto l271 }
	if r < '0' { goto l268out }
	if accept2('9') { goto l227 }
	if r < 'A' { goto l268out }
	if accept2('Z') { goto l227 }
	if accept('_') { goto l227 }
	if r < 'a' { goto l268out }
	if accept2('g') { goto l227 }
	if r < 'i' { goto l268out }
	if accept2('z') { goto l227 }
l268out:
	return id, length
l271:
	id, length = 5, pos
	if r < '0' { goto l272out }
	if accept2('9') { goto l227 }
	if r < 'A' { goto l272out }
	if accept2('Z') { goto l227 }
	if accept('_') { goto l227 }
	if r < 'a' { goto l272out }
	if accept2('z') { goto l227 }
l272out:
	return id, length
l275:
	id, length = 53, pos
	if accept('e') { goto l281 }
	if r < '0' { goto l278out }
	if accept2('9') { goto l227 }
	if r < 'A' { goto l278out }
	if accept2('Z') { goto l227 }
	if accept('_') { goto l227 }
	if r < 'a' { goto l278out }
	if accept2('d') { goto l227 }
	if r < 'f' { goto l278out }
	if accept2('z') { goto l227 }
l278out:
	return id, length
l281:
	id, length = 53, pos
	if accept('a') { goto l287 }
	if r < '0' { goto l284out }
	if accept2('9') { goto l227 }
	if r < 'A' { goto l284out }
	if accept2('Z') { goto l227 }
	if accept('_') { goto l227 }
	if r < 'b' { goto l284out }
	if accept2('z') { goto l227 }
l284out:
	return id, length
l287:
	id, length = 53, pos
	if accept('k') { goto l293 }
	if r < '0' { goto l290out }
	if accept2('9') { goto l227 }
	if r < 'A' { goto l290out }
	if accept2('Z') { goto l227 }
	if accept('_') { goto l227 }
	if r < 'a' { goto l290out }
	if accept2('j') { goto l227 }
	if r < 'l' { goto l290out }
	if accept2('z') { goto l227 }
l290out:
	return id, length
l293:
	id, length = 6, pos
	if r < '0' { goto l294out }
	if accept2('9') { goto l227 }
	if r < 'A' { goto l294out }
	if accept2('Z') { goto l227 }
	if accept('_') { goto l227 }
	if r < 'a' { goto l294out }
	if accept2('z') { goto l227 }
l294out:
	return id, length
l297:
	id, length = 53, pos
	if accept('a') { goto l303 }
	if r < '0' { goto l300out }
	if accept2('9') { goto l227 }
	if r < 'A' { goto l300out }
	if accept2('Z') { goto l227 }
	if accept('_') { goto l227 }
	if r < 'b' { goto l300out }
	if accept2('z') { goto l227 }
l300out:
	return id, length
l303:
	id, length = 53, pos
	if accept('s') { goto l309 }
	if r < '0' { goto l306out }
	if accept2('9') { goto l227 }
	if r < 'A' { goto l306out }
	if accept2('Z') { goto l227 }
	if accept('_') { goto l227 }
	if r < 'a' { goto l306out }
	if accept2('r') { goto l227 }
	if r < 't' { goto l306out }
	if accept2('z') { goto l227 }
l306out:
	return id, length
l309:
	id, length = 53, pos
	if accept('e') { goto l315 }
	if r < '0' { goto l312out }
	if accept2('9') { goto l227 }
	if r < 'A' { goto l312out }
	if accept2('Z') { goto l227 }
	if accept('_') { goto l227 }
	if r < 'a' { goto l312out }
	if accept2('d') { goto l227 }
	if r < 'f' { goto l312out }
	if accept2('z') { goto l227 }
l312out:
	return id, length
l315:
	id, length = 7, pos
	if r < '0' { goto l316out }
	if accept2('9') { goto l227 }
	if r < 'A' { goto l316out }
	if accept2('Z') { goto l227 }
	if accept('_') { goto l227 }
	if r < 'a' { goto l316out }
	if accept2('z') { goto l227 }
l316out:
	return id, length
l319:
	id, length = 53, pos
	if accept('e') { goto l325 }
	if r < '0' { goto l322out }
	if accept2('9') { goto l227 }
	if r < 'A' { goto l322out }
	if accept2('Z') { goto l227 }
	if accept('_') { goto l227 }
	if r < 'a' { goto l322out }
	if accept2('d') { goto l227 }
	if r < 'f' { goto l322out }
	if accept2('z') { goto l227 }
l322out:
	return id, length
l325:
	id, length = 53, pos
	if accept('f') { goto l331 }
	if r < '0' { goto l328out }
	if accept2('9') { goto l227 }
	if r < 'A' { goto l328out }
	if accept2('Z') { goto l227 }
	if accept('_') { goto l227 }
	if r < 'a' { goto l328out }
	if accept2('e') { goto l227 }
	if r < 'g' { goto l328out }
	if accept2('z') { goto l227 }
l328out:
	return id, length
l331:
	id, length = 8, pos
	if r < '0' { goto l332out }
	if accept2('9') { goto l227 }
	if r < 'A' { goto l332out }
	if accept2('Z') { goto l227 }
	if accept('_') { goto l227 }
	if r < 'a' { goto l332out }
	if accept2('z') { goto l227 }
l332out:
	return id, length
l335:
	id, length = 53, pos
	if accept('l') { goto l343 }
	if accept('n') { goto l371 }
	if r < '0' { goto l340out }
	if accept2('9') { goto l227 }
	if r < 'A' { goto l340out }
	if accept2('Z') { goto l227 }
	if accept('_') { goto l227 }
	if r < 'a' { goto l340out }
	if accept2('k') { goto l227 }
	if accept('m') { goto l227 }
	if r < 'o' { goto l340out }
	if accept2('z') { goto l227 }
l340out:
	return id, length
l343:
	id, length = 53, pos
	if accept('s') { goto l349 }
	if r < '0' { goto l346out }
	if accept2('9') { goto l227 }
	if r < 'A' { goto l346out }
	if accept2('Z') { goto l227 }
	if accept('_') { goto l227 }
	if r < 'a' { goto l346out }
	if accept2('r') { goto l227 }
	if r < 't' { goto l346out }
	if accept2('z') { goto l227 }
l346out:
	return id, length
l349:
	id, length = 53, pos
	if accept('e') { goto l357 }
	if accept('i') { goto l361 }
	if r < '0' { goto l354out }
	if accept2('9') { goto l227 }
	if r < 'A' { goto l354out }
	if accept2('Z') { goto l227 }
	if accept('_') { goto l227 }
	if r < 'a' { goto l354out }
	if accept2('d') { goto l227 }
	if r < 'f' { goto l354out }
	if accept2('h') { goto l227 }
	if r < 'j' { goto l354out }
	if accept2('z') { goto l227 }
l354out:
	return id, length
l357:
	id, length = 9, pos
	if r < '0' { goto l358out }
	if accept2('9') { goto l227 }
	if r < 'A' { goto l358out }
	if accept2('Z') { goto l227 }
	if accept('_') { goto l227 }
	if r < 'a' { goto l358out }
	if accept2('z') { goto l227 }
l358out:
	return id, length
l361:
	id, length = 53, pos
	if accept('f') { goto l367 }
	if r < '0' { goto l364out }
	if accept2('9') { goto l227 }
	if r < 'A' { goto l364out }
	if accept2('Z') { goto l227 }
	if accept('_') { goto l227 }
	if r < 'a' { goto l364out }
	if accept2('e') { goto l227 }
	if r < 'g' { goto l364out }
	if accept2('z') { goto l227 }
l364out:
	return id, length
l367:
	id, length = 10, pos
	if r < '0' { goto l368out }
	if accept2('9') { goto l227 }
	if r < 'A' { goto l368out }
	if accept2('Z') { goto l227 }
	if accept('_') { goto l227 }
	if r < 'a' { goto l368out }
	if accept2('z') { goto l227 }
l368out:
	return id, length
l371:
	id, length = 53, pos
	if accept('d') { goto l377 }
	if r < '0' { goto l374out }
	if accept2('9') { goto l227 }
	if r < 'A' { goto l374out }
	if accept2('Z') { goto l227 }
	if accept('_') { goto l227 }
	if r < 'a' { goto l374out }
	if accept2('c') { goto l227 }
	if r < 'e' { goto l374out }
	if accept2('z') { goto l227 }
l374out:
	return id, length
l377:
	id, length = 11, pos
	if r < '0' { goto l378out }
	if accept2('9') { goto l227 }
	if r < 'A' { goto l378out }
	if accept2('Z') { goto l227 }
	if accept('_') { goto l227 }
	if r < 'a' { goto l378out }
	if accept2('z') { goto l227 }
l378out:
	return id, length
l381:
	id, length = 53, pos
	if accept('a') { goto l391 }
	if accept('n') { goto l413 }
	if accept('o') { goto l417 }
	if r < '0' { goto l388out }
	if accept2('9') { goto l227 }
	if r < 'A' { goto l388out }
	if accept2('Z') { goto l227 }
	if accept('_') { goto l227 }
	if r < 'b' { goto l388out }
	if accept2('m') { goto l227 }
	if r < 'p' { goto l388out }
	if accept2('z') { goto l227 }
l388out:
	return id, length
l391:
	id, length = 53, pos
	if accept('l') { goto l397 }
	if r < '0' { goto l394out }
	if accept2('9') { goto l227 }
	if r < 'A' { goto l394out }
	if accept2('Z') { goto l227 }
	if accept('_') { goto l227 }
	if r < 'a' { goto l394out }
	if accept2('k') { goto l227 }
	if r < 'm' { goto l394out }
	if accept2('z') { goto l227 }
l394out:
	return id, length
l397:
	id, length = 53, pos
	if accept('s') { goto l403 }
	if r < '0' { goto l400out }
	if accept2('9') { goto l227 }
	if r < 'A' { goto l400out }
	if accept2('Z') { goto l227 }
	if accept('_') { goto l227 }
	if r < 'a' { goto l400out }
	if accept2('r') { goto l227 }
	if r < 't' { goto l400out }
	if accept2('z') { goto l227 }
l400out:
	return id, length
l403:
	id, length = 53, pos
	if accept('e') { goto l409 }
	if r < '0' { goto l406out }
	if accept2('9') { goto l227 }
	if r < 'A' { goto l406out }
	if accept2('Z') { goto l227 }
	if accept('_') { goto l227 }
	if r < 'a' { goto l406out }
	if accept2('d') { goto l227 }
	if r < 'f' { goto l406out }
	if accept2('z') { goto l227 }
l406out:
	return id, length
l409:
	id, length = 12, pos
	if r < '0' { goto l410out }
	if accept2('9') { goto l227 }
	if r < 'A' { goto l410out }
	if accept2('Z') { goto l227 }
	if accept('_') { goto l227 }
	if r < 'a' { goto l410out }
	if accept2('z') { goto l227 }
l410out:
	return id, length
l413:
	id, length = 13, pos
	if r < '0' { goto l414out }
	if accept2('9') { goto l227 }
	if r < 'A' { goto l414out }
	if accept2('Z') { goto l227 }
	if accept('_') { goto l227 }
	if r < 'a' { goto l414out }
	if accept2('z') { goto l227 }
l414out:
	return id, length
l417:
	id, length = 53, pos
	if accept('r') { goto l423 }
	if r < '0' { goto l420out }
	if accept2('9') { goto l227 }
	if r < 'A' { goto l420out }
	if accept2('Z') { goto l227 }
	if accept('_') { goto l227 }
	if r < 'a' { goto l420out }
	if accept2('q') { goto l227 }
	if r < 's' { goto l420out }
	if accept2('z') { goto l227 }
l420out:
	return id, length
l423:
	id, length = 14, pos
	if r < '0' { goto l424out }
	if accept2('9') { goto l227 }
	if r < 'A' { goto l424out }
	if accept2('Z') { goto l227 }
	if accept('_') { goto l227 }
	if r < 'a' { goto l424out }
	if accept2('z') { goto l227 }
l424out:
	return id, length
l427:
	id, length = 53, pos
	if accept('f') { goto l437 }
	if accept('m') { goto l441 }
	if accept('n') { goto l469 }
	if r < '0' { goto l434out }
	if accept2('9') { goto l227 }
	if r < 'A' { goto l434out }
	if accept2('Z') { goto l227 }
	if accept('_') { goto l227 }
	if r < 'a' { goto l434out }
	if accept2('e') { goto l227 }
	if r < 'g' { goto l434out }
	if accept2('l') { goto l227 }
	if r < 'o' { goto l434out }
	if accept2('z') { goto l227 }
l434out:
	return id, length
l437:
	id, length = 15, pos
	if r < '0' { goto l438out }
	if accept2('9') { goto l227 }
	if r < 'A' { goto l438out }
	if accept2('Z') { goto l227 }
	if accept('_') { goto l227 }
	if r < 'a' { goto l438out }
	if accept2('z') { goto l227 }
l438out:
	return id, length
l441:
	id, length = 53, pos
	if accept('p') { goto l447 }
	if r < '0' { goto l444out }
	if accept2('9') { goto l227 }
	if r < 'A' { goto l444out }
	if accept2('Z') { goto l227 }
	if accept('_') { goto l227 }
	if r < 'a' { goto l444out }
	if accept2('o') { goto l227 }
	if r < 'q' { goto l444out }
	if accept2('z') { goto l227 }
l444out:
	return id, length
l447:
	id, length = 53, pos
	if accept('o') { goto l453 }
	if r < '0' { goto l450out }
	if accept2('9') { goto l227 }
	if r < 'A' { goto l450out }
	if accept2('Z') { goto l227 }
	if accept('_') { goto l227 }
	if r < 'a' { goto l450out }
	if accept2('n') { goto l227 }
	if r < 'p' { goto l450out }
	if accept2('z') { goto l227 }
l450out:
	return id, length
l453:
	id, length = 53, pos
	if accept('r') { goto l459 }
	if r < '0' { goto l456out }
	if accept2('9') { goto l227 }
	if r < 'A' { goto l456out }
	if accept2('Z') { goto l227 }
	if accept('_') { goto l227 }
	if r < 'a' { goto l456out }
	if accept2('q') { goto l227 }
	if r < 's' { goto l456out }
	if accept2('z') { goto l227 }
l456out:
	return id, length
l459:
	id, length = 53, pos
	if accept('t') { goto l465 }
	if r < '0' { goto l462out }
	if accept2('9') { goto l227 }
	if r < 'A' { goto l462out }
	if accept2('Z') { goto l227 }
	if accept('_') { goto l227 }
	if r < 'a' { goto l462out }
	if accept2('s') { goto l227 }
	if r < 'u' { goto l462out }
	if accept2('z') { goto l227 }
l462out:
	return id, length
l465:
	id, length = 16, pos
	if r < '0' { goto l466out }
	if accept2('9') { goto l227 }
	if r < 'A' { goto l466out }
	if accept2('Z') { goto l227 }
	if accept('_') { goto l227 }
	if r < 'a' { goto l466out }
	if accept2('z') { goto l227 }
l466out:
	return id, length
l469:
	id, length = 17, pos
	if r < '0' { goto l470out }
	if accept2('9') { goto l227 }
	if r < 'A' { goto l470out }
	if accept2('Z') { goto l227 }
	if accept('_') { goto l227 }
	if r < 'a' { goto l470out }
	if accept2('z') { goto l227 }
l470out:
	return id, length
l473:
	id, length = 53, pos
	if accept('e') { goto l481 }
	if accept('i') { goto l497 }
	if r < '0' { goto l478out }
	if accept2('9') { goto l227 }
	if r < 'A' { goto l478out }
	if accept2('Z') { goto l227 }
	if accept('_') { goto l227 }
	if r < 'a' { goto l478out }
	if accept2('d') { goto l227 }
	if r < 'f' { goto l478out }
	if accept2('h') { goto l227 }
	if r < 'j' { goto l478out }
	if accept2('z') { goto l227 }
l478out:
	return id, length
l481:
	id, length = 53, pos
	if accept('x') { goto l487 }
	if r < '0' { goto l484out }
	if accept2('9') { goto l227 }
	if r < 'A' { goto l484out }
	if accept2('Z') { goto l227 }
	if accept('_') { goto l227 }
	if r < 'a' { goto l484out }
	if accept2('w') { goto l227 }
	if r < 'y' { goto l484out }
	if accept2('z') { goto l227 }
l484out:
	return id, length
l487:
	id, length = 53, pos
	if accept('t') { goto l493 }
	if r < '0' { goto l490out }
	if accept2('9') { goto l227 }
	if r < 'A' { goto l490out }
	if accept2('Z') { goto l227 }
	if accept('_') { goto l227 }
	if r < 'a' { goto l490out }
	if accept2('s') { goto l227 }
	if r < 'u' { goto l490out }
	if accept2('z') { goto l227 }
l490out:
	return id, length
l493:
	id, length = 18, pos
	if r < '0' { goto l494out }
	if accept2('9') { goto l227 }
	if r < 'A' { goto l494out }
	if accept2('Z') { goto l227 }
	if accept('_') { goto l227 }
	if r < 'a' { goto l494out }
	if accept2('z') { goto l227 }
l494out:
	return id, length
l497:
	id, length = 53, pos
	if accept('l') { goto l503 }
	if r < '0' { goto l500out }
	if accept2('9') { goto l227 }
	if r < 'A' { goto l500out }
	if accept2('Z') { goto l227 }
	if accept('_') { goto l227 }
	if r < 'a' { goto l500out }
	if accept2('k') { goto l227 }
	if r < 'm' { goto l500out }
	if accept2('z') { goto l227 }
l500out:
	return id, length
l503:
	id, length = 19, pos
	if r < '0' { goto l504out }
	if accept2('9') { goto l227 }
	if r < 'A' { goto l504out }
	if accept2('Z') { goto l227 }
	if accept('_') { goto l227 }
	if r < 'a' { goto l504out }
	if accept2('z') { goto l227 }
l504out:
	return id, length
l507:
	id, length = 53, pos
	if accept('f') { goto l515 }
	if accept('r') { goto l519 }
	if r < '0' { goto l512out }
	if accept2('9') { goto l227 }
	if r < 'A' { goto l512out }
	if accept2('Z') { goto l227 }
	if accept('_') { goto l227 }
	if r < 'a' { goto l512out }
	if accept2('e') { goto l227 }
	if r < 'g' { goto l512out }
	if accept2('q') { goto l227 }
	if r < 's' { goto l512out }
	if accept2('z') { goto l227 }
l512out:
	return id, length
l515:
	id, length = 20, pos
	if r < '0' { goto l516out }
	if accept2('9') { goto l227 }
	if r < 'A' { goto l516out }
	if accept2('Z') { goto l227 }
	if accept('_') { goto l227 }
	if r < 'a' { goto l516out }
	if accept2('z') { goto l227 }
l516out:
	return id, length
l519:
	id, length = 21, pos
	if r < '0' { goto l520out }
	if accept2('9') { goto l227 }
	if r < 'A' { goto l520out }
	if accept2('Z') { goto l227 }
	if accept('_') { goto l227 }
	if r < 'a' { goto l520out }
	if accept2('z') { goto l227 }
l520out:
	return id, length
l523:
	id, length = 53, pos
	if accept('a') { goto l529 }
	if r < '0' { goto l526out }
	if accept2('9') { goto l227 }
	if r < 'A' { goto l526out }
	if accept2('Z') { goto l227 }
	if accept('_') { goto l227 }
	if r < 'b' { goto l526out }
	if accept2('z') { goto l227 }
l526out:
	return id, length
l529:
	id, length = 53, pos
	if accept('r') { goto l535 }
	if r < '0' { goto l532out }
	if accept2('9') { goto l227 }
	if r < 'A' { goto l532out }
	if accept2('Z') { goto l227 }
	if accept('_') { goto l227 }
	if r < 'a' { goto l532out }
	if accept2('q') { goto l227 }
	if r < 's' { goto l532out }
	if accept2('z') { goto l227 }
l532out:
	return id, length
l535:
	id, length = 53, pos
	if accept('a') { goto l541 }
	if r < '0' { goto l538out }
	if accept2('9') { goto l227 }
	if r < 'A' { goto l538out }
	if accept2('Z') { goto l227 }
	if accept('_') { goto l227 }
	if r < 'b' { goto l538out }
	if accept2('z') { goto l227 }
l538out:
	return id, length
l541:
	id, length = 53, pos
	if accept('l') { goto l547 }
	if r < '0' { goto l544out }
	if accept2('9') { goto l227 }
	if r < 'A' { goto l544out }
	if accept2('Z') { goto l227 }
	if accept('_') { goto l227 }
	if r < 'a' { goto l544out }
	if accept2('k') { goto l227 }
	if r < 'm' { goto l544out }
	if accept2('z') { goto l227 }
l544out:
	return id, length
l547:
	id, length = 53, pos
	if accept('l') { goto l553 }
	if r < '0' { goto l550out }
	if accept2('9') { goto l227 }
	if r < 'A' { goto l550out }
	if accept2('Z') { goto l227 }
	if accept('_') { goto l227 }
	if r < 'a' { goto l550out }
	if accept2('k') { goto l227 }
	if r < 'm' { goto l550out }
	if accept2('z') { goto l227 }
l550out:
	return id, length
l553:
	id, length = 53, pos
	if accept('e') { goto l559 }
	if r < '0' { goto l556out }
	if accept2('9') { goto l227 }
	if r < 'A' { goto l556out }
	if accept2('Z') { goto l227 }
	if accept('_') { goto l227 }
	if r < 'a' { goto l556out }
	if accept2('d') { goto l227 }
	if r < 'f' { goto l556out }
	if accept2('z') { goto l227 }
l556out:
	return id, length
l559:
	id, length = 53, pos
	if accept('l') { goto l565 }
	if r < '0' { goto l562out }
	if accept2('9') { goto l227 }
	if r < 'A' { goto l562out }
	if accept2('Z') { goto l227 }
	if accept('_') { goto l227 }
	if r < 'a' { goto l562out }
	if accept2('k') { goto l227 }
	if r < 'm' { goto l562out }
	if accept2('z') { goto l227 }
l562out:
	return id, length
l565:
	id, length = 22, pos
	if r < '0' { goto l566out }
	if accept2('9') { goto l227 }
	if r < 'A' { goto l566out }
	if accept2('Z') { goto l227 }
	if accept('_') { goto l227 }
	if r < 'a' { goto l566out }
	if accept2('z') { goto l227 }
l566out:
	return id, length
l569:
	id, length = 53, pos
	if accept('a') { goto l577 }
	if accept('e') { goto l593 }
	if r < '0' { goto l574out }
	if accept2('9') { goto l227 }
	if r < 'A' { goto l574out }
	if accept2('Z') { goto l227 }
	if accept('_') { goto l227 }
	if r < 'b' { goto l574out }
	if accept2('d') { goto l227 }
	if r < 'f' { goto l574out }
	if accept2('z') { goto l227 }
l574out:
	return id, length
l577:
	id, length = 53, pos
	if accept('t') { goto l583 }
	if r < '0' { goto l580out }
	if accept2('9') { goto l227 }
	if r < 'A' { goto l580out }
	if accept2('Z') { goto l227 }
	if accept('_') { goto l227 }
	if r < 'a' { goto l580out }
	if accept2('s') { goto l227 }
	if r < 'u' { goto l580out }
	if accept2('z') { goto l227 }
l580out:
	return id, length
l583:
	id, length = 53, pos
	if accept('s') { goto l589 }
	if r < '0' { goto l586out }
	if accept2('9') { goto l227 }
	if r < 'A' { goto l586out }
	if accept2('Z') { goto l227 }
	if accept('_') { goto l227 }
	if r < 'a' { goto l586out }
	if accept2('r') { goto l227 }
	if r < 't' { goto l586out }
	if accept2('z') { goto l227 }
l586out:
	return id, length
l589:
	id, length = 23, pos
	if r < '0' { goto l590out }
	if accept2('9') { goto l227 }
	if r < 'A' { goto l590out }
	if accept2('Z') { goto l227 }
	if accept('_') { goto l227 }
	if r < 'a' { goto l590out }
	if accept2('z') { goto l227 }
l590out:
	return id, length
l593:
	id, length = 53, pos
	if accept('q') { goto l601 }
	if accept('t') { goto l629 }
	if r < '0' { goto l598out }
	if accept2('9') { goto l227 }
	if r < 'A' { goto l598out }
	if accept2('Z') { goto l227 }
	if accept('_') { goto l227 }
	if r < 'a' { goto l598out }
	if accept2('p') { goto l227 }
	if r < 'r' { goto l598out }
	if accept2('s') { goto l227 }
	if r < 'u' { goto l598out }
	if accept2('z') { goto l227 }
l598out:
	return id, length
l601:
	id, length = 53, pos
	if accept('u') { goto l607 }
	if r < '0' { goto l604out }
	if accept2('9') { goto l227 }
	if r < 'A' { goto l604out }
	if accept2('Z') { goto l227 }
	if accept('_') { goto l227 }
	if r < 'a' { goto l604out }
	if accept2('t') { goto l227 }
	if r < 'v' { goto l604out }
	if accept2('z') { goto l227 }
l604out:
	return id, length
l607:
	id, length = 53, pos
	if accept('i') { goto l613 }
	if r < '0' { goto l610out }
	if accept2('9') { goto l227 }
	if r < 'A' { goto l610out }
	if accept2('Z') { goto l227 }
	if accept('_') { goto l227 }
	if r < 'a' { goto l610out }
	if accept2('h') { goto l227 }
	if r < 'j' { goto l610out }
	if accept2('z') { goto l227 }
l610out:
	return id, length
l613:
	id, length = 53, pos
	if accept('r') { goto l619 }
	if r < '0' { goto l616out }
	if accept2('9') { goto l227 }
	if r < 'A' { goto l616out }
	if accept2('Z') { goto l227 }
	if accept('_') { goto l227 }
	if r < 'a' { goto l616out }
	if accept2('q') { goto l227 }
	if r < 's' { goto l616out }
	if accept2('z') { goto l227 }
l616out:
	return id, length
l619:
	id, length = 53, pos
	if accept('e') { goto l625 }
	if r < '0' { goto l622out }
	if accept2('9') { goto l227 }
	if r < 'A' { goto l622out }
	if accept2('Z') { goto l227 }
	if accept('_') { goto l227 }
	if r < 'a' { goto l622out }
	if accept2('d') { goto l227 }
	if r < 'f' { goto l622out }
	if accept2('z') { goto l227 }
l622out:
	return id, length
l625:
	id, length = 24, pos
	if r < '0' { goto l626out }
	if accept2('9') { goto l227 }
	if r < 'A' { goto l626out }
	if accept2('Z') { goto l227 }
	if accept('_') { goto l227 }
	if r < 'a' { goto l626out }
	if accept2('z') { goto l227 }
l626out:
	return id, length
l629:
	id, length = 53, pos
	if accept('u') { goto l635 }
	if r < '0' { goto l632out }
	if accept2('9') { goto l227 }
	if r < 'A' { goto l632out }
	if accept2('Z') { goto l227 }
	if accept('_') { goto l227 }
	if r < 'a' { goto l632out }
	if accept2('t') { goto l227 }
	if r < 'v' { goto l632out }
	if accept2('z') { goto l227 }
l632out:
	return id, length
l635:
	id, length = 53, pos
	if accept('r') { goto l641 }
	if r < '0' { goto l638out }
	if accept2('9') { goto l227 }
	if r < 'A' { goto l638out }
	if accept2('Z') { goto l227 }
	if accept('_') { goto l227 }
	if r < 'a' { goto l638out }
	if accept2('q') { goto l227 }
	if r < 's' { goto l638out }
	if accept2('z') { goto l227 }
l638out:
	return id, length
l641:
	id, length = 53, pos
	if accept('n') { goto l647 }
	if r < '0' { goto l644out }
	if accept2('9') { goto l227 }
	if r < 'A' { goto l644out }
	if accept2('Z') { goto l227 }
	if accept('_') { goto l227 }
	if r < 'a' { goto l644out }
	if accept2('m') { goto l227 }
	if r < 'o' { goto l644out }
	if accept2('z') { goto l227 }
l644out:
	return id, length
l647:
	id, length = 25, pos
	if r < '0' { goto l648out }
	if accept2('9') { goto l227 }
	if r < 'A' { goto l648out }
	if accept2('Z') { goto l227 }
	if accept('_') { goto l227 }
	if r < 'a' { goto l648out }
	if accept2('z') { goto l227 }
l648out:
	return id, length
l651:
	id, length = 53, pos
	if accept('a') { goto l659 }
	if accept('p') { goto l693 }
	if r < '0' { goto l656out }
	if accept2('9') { goto l227 }
	if r < 'A' { goto l656out }
	if accept2('Z') { goto l227 }
	if accept('_') { goto l227 }
	if r < 'b' { goto l656out }
	if accept2('o') { goto l227 }
	if r < 'q' { goto l656out }
	if accept2('z') { goto l227 }
l656out:
	return id, length
l659:
	id, length = 53, pos
	if accept('n') { goto l665 }
	if r < '0' { goto l662out }
	if accept2('9') { goto l227 }
	if r < 'A' { goto l662out }
	if accept2('Z') { goto l227 }
	if accept('_') { goto l227 }
	if r < 'a' { goto l662out }
	if accept2('m') { goto l227 }
	if r < 'o' { goto l662out }
	if accept2('z') { goto l227 }
l662out:
	return id, length
l665:
	id, length = 53, pos
	if accept('d') { goto l671 }
	if r < '0' { goto l668out }
	if accept2('9') { goto l227 }
	if r < 'A' { goto l668out }
	if accept2('Z') { goto l227 }
	if accept('_') { goto l227 }
	if r < 'a' { goto l668out }
	if accept2('c') { goto l227 }
	if r < 'e' { goto l668out }
	if accept2('z') { goto l227 }
l668out:
	return id, length
l671:
	id, length = 53, pos
	if accept('b') { goto l677 }
	if r < '0' { goto l674out }
	if accept2('9') { goto l227 }
	if r < 'A' { goto l674out }
	if accept2('Z') { goto l227 }
	if accept('_') { goto l227 }
	if accept('a') { goto l227 }
	if r < 'c' { goto l674out }
	if accept2('z') { goto l227 }
l674out:
	return id, length
l677:
	id, length = 53, pos
	if accept('o') { goto l683 }
	if r < '0' { goto l680out }
	if accept2('9') { goto l227 }
	if r < 'A' { goto l680out }
	if accept2('Z') { goto l227 }
	if accept('_') { goto l227 }
	if r < 'a' { goto l680out }
	if accept2('n') { goto l227 }
	if r < 'p' { goto l680out }
	if accept2('z') { goto l227 }
l680out:
	return id, length
l683:
	id, length = 53, pos
	if accept('x') { goto l689 }
	if r < '0' { goto l686out }
	if accept2('9') { goto l227 }
	if r < 'A' { goto l686out }
	if accept2('Z') { goto l227 }
	if accept('_') { goto l227 }
	if r < 'a' { goto l686out }
	if accept2('w') { goto l227 }
	if r < 'y' { goto l686out }
	if accept2('z') { goto l227 }
l686out:
	return id, length
l689:
	id, length = 26, pos
	if r < '0' { goto l690out }
	if accept2('9') { goto l227 }
	if r < 'A' { goto l690out }
	if accept2('Z') { goto l227 }
	if accept('_') { goto l227 }
	if r < 'a' { goto l690out }
	if accept2('z') { goto l227 }
l690out:
	return id, length
l693:
	id, length = 53, pos
	if accept('a') { goto l699 }
	if r < '0' { goto l696out }
	if accept2('9') { goto l227 }
	if r < 'A' { goto l696out }
	if accept2('Z') { goto l227 }
	if accept('_') { goto l227 }
	if r < 'b' { goto l696out }
	if accept2('z') { goto l227 }
l696out:
	return id, length
l699:
	id, length = 53, pos
	if accept('w') { goto l705 }
	if r < '0' { goto l702out }
	if accept2('9') { goto l227 }
	if r < 'A' { goto l702out }
	if accept2('Z') { goto l227 }
	if accept('_') { goto l227 }
	if r < 'a' { goto l702out }
	if accept2('v') { goto l227 }
	if r < 'x' { goto l702out }
	if accept2('z') { goto l227 }
l702out:
	return id, length
l705:
	id, length = 53, pos
	if accept('n') { goto l711 }
	if r < '0' { goto l708out }
	if accept2('9') { goto l227 }
	if r < 'A' { goto l708out }
	if accept2('Z') { goto l227 }
	if accept('_') { goto l227 }
	if r < 'a' { goto l708out }
	if accept2('m') { goto l227 }
	if r < 'o' { goto l708out }
	if accept2('z') { goto l227 }
l708out:
	return id, length
l711:
	id, length = 27, pos
	if r < '0' { goto l712out }
	if accept2('9') { goto l227 }
	if r < 'A' { goto l712out }
	if accept2('Z') { goto l227 }
	if accept('_') { goto l227 }
	if r < 'a' { goto l712out }
	if accept2('z') { goto l227 }
l712out:
	return id, length
l715:
	id, length = 53, pos
	if accept('r') { goto l721 }
	if r < '0' { goto l718out }
	if accept2('9') { goto l227 }
	if r < 'A' { goto l718out }
	if accept2('Z') { goto l227 }
	if accept('_') { goto l227 }
	if r < 'a' { goto l718out }
	if accept2('q') { goto l227 }
	if r < 's' { goto l718out }
	if accept2('z') { goto l227 }
l718out:
	return id, length
l721:
	id, length = 53, pos
	if accept('u') { goto l729 }
	if accept('y') { goto l739 }
	if r < '0' { goto l726out }
	if accept2('9') { goto l227 }
	if r < 'A' { goto l726out }
	if accept2('Z') { goto l227 }
	if accept('_') { goto l227 }
	if r < 'a' { goto l726out }
	if accept2('t') { goto l227 }
	if r < 'v' { goto l726out }
	if accept2('x') { goto l227 }
	if accept('z') { goto l227 }
l726out:
	return id, length
l729:
	id, length = 53, pos
	if accept('e') { goto l735 }
	if r < '0' { goto l732out }
	if accept2('9') { goto l227 }
	if r < 'A' { goto l732out }
	if accept2('Z') { goto l227 }
	if accept('_') { goto l227 }
	if r < 'a' { goto l732out }
	if accept2('d') { goto l227 }
	if r < 'f' { goto l732out }
	if accept2('z') { goto l227 }
l732out:
	return id, length
l735:
	id, length = 28, pos
	if r < '0' { goto l736out }
	if accept2('9') { goto l227 }
	if r < 'A' { goto l736out }
	if accept2('Z') { goto l227 }
	if accept('_') { goto l227 }
	if r < 'a' { goto l736out }
	if accept2('z') { goto l227 }
l736out:
	return id, length
l739:
	id, length = 29, pos
	if r < '0' { goto l740out }
	if accept2('9') { goto l227 }
	if r < 'A' { goto l740out }
	if accept2('Z') { goto l227 }
	if accept('_') { goto l227 }
	if r < 'a' { goto l740out }
	if accept2('z') { goto l227 }
l740out:
	return id, length
l743:
	id, length = 53, pos
	if accept('s') { goto l749 }
	if r < '0' { goto l746out }
	if accept2('9') { goto l227 }
	if r < 'A' { goto l746out }
	if accept2('Z') { goto l227 }
	if accept('_') { goto l227 }
	if r < 'a' { goto l746out }
	if accept2('r') { goto l227 }
	if r < 't' { goto l746out }
	if accept2('z') { goto l227 }
l746out:
	return id, length
l749:
	id, length = 53, pos
	if accept('e') { goto l755 }
	if r < '0' { goto l752out }
	if accept2('9') { goto l227 }
	if r < 'A' { goto l752out }
	if accept2('Z') { goto l227 }
	if accept('_') { goto l227 }
	if r < 'a' { goto l752out }
	if accept2('d') { goto l227 }
	if r < 'f' { goto l752out }
	if accept2('z') { goto l227 }
l752out:
	return id, length
l755:
	id, length = 30, pos
	if r < '0' { goto l756out }
	if accept2('9') { goto l227 }
	if r < 'A' { goto l756out }
	if accept2('Z') { goto l227 }
	if accept('_') { goto l227 }
	if r < 'a' { goto l756out }
	if accept2('z') { goto l227 }
l756out:
	return id, length
l759:
	id, length = 53, pos
	if accept('h') { goto l767 }
	if accept('i') { goto l789 }
	if r < '0' { goto l764out }
	if accept2('9') { goto l227 }
	if r < 'A' { goto l764out }
	if accept2('Z') { goto l227 }
	if accept('_') { goto l227 }
	if r < 'a' { goto l764out }
	if accept2('g') { goto l227 }
	if r < 'j' { goto l764out }
	if accept2('z') { goto l227 }
l764out:
	return id, length
l767:
	id, length = 53, pos
	if accept('i') { goto l773 }
	if r < '0' { goto l770out }
	if accept2('9') { goto l227 }
	if r < 'A' { goto l770out }
	if accept2('Z') { goto l227 }
	if accept('_') { goto l227 }
	if r < 'a' { goto l770out }
	if accept2('h') { goto l227 }
	if r < 'j' { goto l770out }
	if accept2('z') { goto l227 }
l770out:
	return id, length
l773:
	id, length = 53, pos
	if accept('l') { goto l779 }
	if r < '0' { goto l776out }
	if accept2('9') { goto l227 }
	if r < 'A' { goto l776out }
	if accept2('Z') { goto l227 }
	if accept('_') { goto l227 }
	if r < 'a' { goto l776out }
	if accept2('k') { goto l227 }
	if r < 'm' { goto l776out }
	if accept2('z') { goto l227 }
l776out:
	return id, length
l779:
	id, length = 53, pos
	if accept('e') { goto l785 }
	if r < '0' { goto l782out }
	if accept2('9') { goto l227 }
	if r < 'A' { goto l782out }
	if accept2('Z') { goto l227 }
	if accept('_') { goto l227 }
	if r < 'a' { goto l782out }
	if accept2('d') { goto l227 }
	if r < 'f' { goto l782out }
	if accept2('z') { goto l227 }
l782out:
	return id, length
l785:
	id, length = 31, pos
	if r < '0' { goto l786out }
	if accept2('9') { goto l227 }
	if r < 'A' { goto l786out }
	if accept2('Z') { goto l227 }
	if accept('_') { goto l227 }
	if r < 'a' { goto l786out }
	if accept2('z') { goto l227 }
l786out:
	return id, length
l789:
	id, length = 53, pos
	if accept('t') { goto l795 }
	if r < '0' { goto l792out }
	if accept2('9') { goto l227 }
	if r < 'A' { goto l792out }
	if accept2('Z') { goto l227 }
	if accept('_') { goto l227 }
	if r < 'a' { goto l792out }
	if accept2('s') { goto l227 }
	if r < 'u' { goto l792out }
	if accept2('z') { goto l227 }
l792out:
	return id, length
l795:
	id, length = 53, pos
	if accept('h') { goto l801 }
	if r < '0' { goto l798out }
	if accept2('9') { goto l227 }
	if r < 'A' { goto l798out }
	if accept2('Z') { goto l227 }
	if accept('_') { goto l227 }
	if r < 'a' { goto l798out }
	if accept2('g') { goto l227 }
	if r < 'i' { goto l798out }
	if accept2('z') { goto l227 }
l798out:
	return id, length
l801:
	id, length = 32, pos
	if r < '0' { goto l802out }
	if accept2('9') { goto l227 }
	if r < 'A' { goto l802out }
	if accept2('Z') { goto l227 }
	if accept('_') { goto l227 }
	if r < 'a' { goto l802out }
	if accept2('z') { goto l227 }
l802out:
	return id, length
l805:
	id, length = 49, pos
	return id, length
l807:
	if accept('|') { goto l810 }
	return id, length
l810:
	id, length = 33, pos
	return id, length
l812:
	id, length = 50, pos
	return id, length
l814:
	id, length = 0, pos
	return id, length
}


// Scan is used internally from Parse.
func(p *Parser) Scan() (r scanner.Token) {
		return p.sc.Scan()
}

// init initalizes 'p' with content in 'src', assuming it comes from 'name'.
// 'src' becomes "owned" by 'p'. init invalidates any pre-existing ASTs produced by 'p'. Mutating
// 'src' invalidates the current AST returned from any parsing function called after init.
func (p *Parser) init(name string, src []byte) (err error) {
	p.eof = false
	p.errBudget = 10
	p.n = 0
	p.off = 0
	p.src = src
	p.tok = scanner.Token{}
	p.tokIndex = 0
	p.sc = scanner.NewRecScanner(name, p.src, p.scan, int(Rugowhite_space))
	return nil
}



// AddExpr grammar:
//
//	
//	AddExpr     = MulExpr { ('+' | '-') MulExpr } .
//
//	State 0
//		on  "case", "false", "fn", "nil", "parallel", "spawn", "true", "try", '!', '(', '-', '[', '{', float_lit, ident, integer, raw_str_lit, str_lit, CaseExpr, UnaryExpr, Postfix, Primary, TryExpr, SpawnExpr, ParallelExpr, FnExpr, ArrayLit, HashLit
//			call MulExpr and goto state 1
//	State 1
//		Accept
//		on  '+', '-'
//			shift and goto state 0
// AddExpr is used internally from Parse.
func (p *Parser) AddExpr() (r []int32) {
		accept, errorSet := false, 0
		r = append(p.get(), -int32(RugoAddExpr), 0)
state0:
accept, errorSet = false, 61
switch Symbol(p.tok.Ch) {
	case  RugoTOK_case, RugoTOK_false, RugoTOK_fn, RugoTOK_nil, RugoTOK_parallel, RugoTOK_spawn, RugoTOK_true, RugoTOK_try, RugoTOK_0021, RugoTOK_0028, RugoTOK_002d, RugoTOK_005b, RugoTOK_007b, Rugofloat_lit, Rugoident, Rugointeger, Rugoraw_str_lit, Rugostr_lit, RugoCaseExpr, RugoUnaryExpr, RugoPostfix, RugoPrimary, RugoTryExpr, RugoSpawnExpr, RugoParallelExpr, RugoFnExpr, RugoArrayLit, RugoHashLit:
r = p.add(r, p.MulExpr())
goto state1
}
return p.stop(r, accept, errorSet)
state1:
accept, errorSet = true, 28
switch Symbol(p.tok.Ch) {
	case  RugoTOK_002b, RugoTOK_002d:
r = append(r, p.shift())
goto state0
}
return p.stop(r, accept, errorSet)
}


// AndExpr grammar:
//
//	
//	AndExpr     = CompExpr { "&&" CompExpr } .
//
//	State 0
//		on  "case", "false", "fn", "nil", "parallel", "spawn", "true", "try", '!', '(', '-', '[', '{', float_lit, ident, integer, raw_str_lit, str_lit, CaseExpr, AddExpr, MulExpr, UnaryExpr, Postfix, Primary, TryExpr, SpawnExpr, ParallelExpr, FnExpr, ArrayLit, HashLit
//			call CompExpr and goto state 1
//	State 1
//		Accept
//		on  "&&"
//			shift and goto state 0
// AndExpr is used internally from Parse.
func (p *Parser) AndExpr() (r []int32) {
		accept, errorSet := false, 0
		r = append(p.get(), -int32(RugoAndExpr), 0)
state0:
accept, errorSet = false, 59
switch Symbol(p.tok.Ch) {
	case  RugoTOK_case, RugoTOK_false, RugoTOK_fn, RugoTOK_nil, RugoTOK_parallel, RugoTOK_spawn, RugoTOK_true, RugoTOK_try, RugoTOK_0021, RugoTOK_0028, RugoTOK_002d, RugoTOK_005b, RugoTOK_007b, Rugofloat_lit, Rugoident, Rugointeger, Rugoraw_str_lit, Rugostr_lit, RugoCaseExpr, RugoAddExpr, RugoMulExpr, RugoUnaryExpr, RugoPostfix, RugoPrimary, RugoTryExpr, RugoSpawnExpr, RugoParallelExpr, RugoFnExpr, RugoArrayLit, RugoHashLit:
r = p.add(r, p.CompExpr())
goto state1
}
return p.stop(r, accept, errorSet)
state1:
accept, errorSet = true, 8
switch Symbol(p.tok.Ch) {
	case  RugoTOK_00260026:
r = append(r, p.shift())
goto state0
}
return p.stop(r, accept, errorSet)
}


// ArgList grammar:
//
//	
//	ArgList     = Expr { ',' Expr } .
//
//	State 0
//		on  "case", "false", "fn", "nil", "parallel", "spawn", "true", "try", '!', '(', '-', '[', '{', float_lit, ident, integer, raw_str_lit, str_lit, CaseExpr, OrExpr, AndExpr, CompExpr, AddExpr, MulExpr, UnaryExpr, Postfix, Primary, TryExpr, SpawnExpr, ParallelExpr, FnExpr, ArrayLit, HashLit
//			call Expr and goto state 1
//	State 1
//		Accept
//		on  ','
//			shift and goto state 0
// ArgList is used internally from Parse.
func (p *Parser) ArgList() (r []int32) {
		accept, errorSet := false, 0
		r = append(p.get(), -int32(RugoArgList), 0)
state0:
accept, errorSet = false, 56
switch Symbol(p.tok.Ch) {
	case  RugoTOK_case, RugoTOK_false, RugoTOK_fn, RugoTOK_nil, RugoTOK_parallel, RugoTOK_spawn, RugoTOK_true, RugoTOK_try, RugoTOK_0021, RugoTOK_0028, RugoTOK_002d, RugoTOK_005b, RugoTOK_007b, Rugofloat_lit, Rugoident, Rugointeger, Rugoraw_str_lit, Rugostr_lit, RugoCaseExpr, RugoOrExpr, RugoAndExpr, RugoCompExpr, RugoAddExpr, RugoMulExpr, RugoUnaryExpr, RugoPostfix, RugoPrimary, RugoTryExpr, RugoSpawnExpr, RugoParallelExpr, RugoFnExpr, RugoArrayLit, RugoHashLit:
r = p.add(r, p.Expr())
goto state1
}
return p.stop(r, accept, errorSet)
state1:
accept, errorSet = true, 33
switch Symbol(p.tok.Ch) {
	case  RugoTOK_002c:
r = append(r, p.shift())
goto state0
}
return p.stop(r, accept, errorSet)
}


// ArrayLit grammar:
//
//	
//	
//	ArrayLit    = '[' [ Expr { ',' Expr } ] ']' .
//
//	State 0
//		on  '['
//			shift and goto state 1
//	State 1
//		on  ']'
//			shift and goto state 2
//		on  "case", "false", "fn", "nil", "parallel", "spawn", "true", "try", '!', '(', '-', '[', '{', float_lit, ident, integer, raw_str_lit, str_lit, CaseExpr, OrExpr, AndExpr, CompExpr, AddExpr, MulExpr, UnaryExpr, Postfix, Primary, TryExpr, SpawnExpr, ParallelExpr, FnExpr, ArrayLit, HashLit
//			call Expr and goto state 3
//	State 2
//		Accept
//	State 3
//		on  ']'
//			shift and goto state 2
//		on  ','
//			shift and goto state 4
//	State 4
//		on  "case", "false", "fn", "nil", "parallel", "spawn", "true", "try", '!', '(', '-', '[', '{', float_lit, ident, integer, raw_str_lit, str_lit, CaseExpr, OrExpr, AndExpr, CompExpr, AddExpr, MulExpr, UnaryExpr, Postfix, Primary, TryExpr, SpawnExpr, ParallelExpr, FnExpr, ArrayLit, HashLit
//			call Expr and goto state 3
// ArrayLit is used internally from Parse.
func (p *Parser) ArrayLit() (r []int32) {
		accept, errorSet := false, 0
		r = append(p.get(), -int32(RugoArrayLit), 0)
// state0:
accept, errorSet = false, 37
switch Symbol(p.tok.Ch) {
	case  RugoTOK_005b:
r = append(r, p.shift())
goto state1
}
return p.stop(r, accept, errorSet)
state1:
accept, errorSet = false, 53
switch Symbol(p.tok.Ch) {
	case  RugoTOK_005d:
r = append(r, p.shift())
goto state2
	case  RugoTOK_case, RugoTOK_false, RugoTOK_fn, RugoTOK_nil, RugoTOK_parallel, RugoTOK_spawn, RugoTOK_true, RugoTOK_try, RugoTOK_0021, RugoTOK_0028, RugoTOK_002d, RugoTOK_005b, RugoTOK_007b, Rugofloat_lit, Rugoident, Rugointeger, Rugoraw_str_lit, Rugostr_lit, RugoCaseExpr, RugoOrExpr, RugoAndExpr, RugoCompExpr, RugoAddExpr, RugoMulExpr, RugoUnaryExpr, RugoPostfix, RugoPrimary, RugoTryExpr, RugoSpawnExpr, RugoParallelExpr, RugoFnExpr, RugoArrayLit, RugoHashLit:
r = p.add(r, p.Expr())
goto state3
}
return p.stop(r, accept, errorSet)
state2:
accept, errorSet = true, 0
return p.stop(r, accept, errorSet)
state3:
accept, errorSet = false, 31
switch Symbol(p.tok.Ch) {
	case  RugoTOK_005d:
r = append(r, p.shift())
goto state2
	case  RugoTOK_002c:
r = append(r, p.shift())
goto state4
}
return p.stop(r, accept, errorSet)
state4:
accept, errorSet = false, 56
switch Symbol(p.tok.Ch) {
	case  RugoTOK_case, RugoTOK_false, RugoTOK_fn, RugoTOK_nil, RugoTOK_parallel, RugoTOK_spawn, RugoTOK_true, RugoTOK_try, RugoTOK_0021, RugoTOK_0028, RugoTOK_002d, RugoTOK_005b, RugoTOK_007b, Rugofloat_lit, Rugoident, Rugointeger, Rugoraw_str_lit, Rugostr_lit, RugoCaseExpr, RugoOrExpr, RugoAndExpr, RugoCompExpr, RugoAddExpr, RugoMulExpr, RugoUnaryExpr, RugoPostfix, RugoPrimary, RugoTryExpr, RugoSpawnExpr, RugoParallelExpr, RugoFnExpr, RugoArrayLit, RugoHashLit:
r = p.add(r, p.Expr())
goto state3
}
return p.stop(r, accept, errorSet)
}


// AssignOrExpr grammar:
//
//	
//	AssignOrExpr = Expr [ '=' Expr ] .
//
//	State 0
//		on  "case", "false", "fn", "nil", "parallel", "spawn", "true", "try", '!', '(', '-', '[', '{', float_lit, ident, integer, raw_str_lit, str_lit, CaseExpr, OrExpr, AndExpr, CompExpr, AddExpr, MulExpr, UnaryExpr, Postfix, Primary, TryExpr, SpawnExpr, ParallelExpr, FnExpr, ArrayLit, HashLit
//			call Expr and goto state 1
//	State 1
//		Accept
//		on  '='
//			shift and goto state 2
//	State 2
//		on  "case", "false", "fn", "nil", "parallel", "spawn", "true", "try", '!', '(', '-', '[', '{', float_lit, ident, integer, raw_str_lit, str_lit, CaseExpr, OrExpr, AndExpr, CompExpr, AddExpr, MulExpr, UnaryExpr, Postfix, Primary, TryExpr, SpawnExpr, ParallelExpr, FnExpr, ArrayLit, HashLit
//			call Expr and goto state 3
//	State 3
//		Accept
// AssignOrExpr is used internally from Parse.
func (p *Parser) AssignOrExpr() (r []int32) {
		accept, errorSet := false, 0
		r = append(p.get(), -int32(RugoAssignOrExpr), 0)
// state0:
accept, errorSet = false, 56
switch Symbol(p.tok.Ch) {
	case  RugoTOK_case, RugoTOK_false, RugoTOK_fn, RugoTOK_nil, RugoTOK_parallel, RugoTOK_spawn, RugoTOK_true, RugoTOK_try, RugoTOK_0021, RugoTOK_0028, RugoTOK_002d, RugoTOK_005b, RugoTOK_007b, Rugofloat_lit, Rugoident, Rugointeger, Rugoraw_str_lit, Rugostr_lit, RugoCaseExpr, RugoOrExpr, RugoAndExpr, RugoCompExpr, RugoAddExpr, RugoMulExpr, RugoUnaryExpr, RugoPostfix, RugoPrimary, RugoTryExpr, RugoSpawnExpr, RugoParallelExpr, RugoFnExpr, RugoArrayLit, RugoHashLit:
r = p.add(r, p.Expr())
goto state1
}
return p.stop(r, accept, errorSet)
state1:
accept, errorSet = true, 35
switch Symbol(p.tok.Ch) {
	case  RugoTOK_003d:
r = append(r, p.shift())
goto state2
}
return p.stop(r, accept, errorSet)
state2:
accept, errorSet = false, 56
switch Symbol(p.tok.Ch) {
	case  RugoTOK_case, RugoTOK_false, RugoTOK_fn, RugoTOK_nil, RugoTOK_parallel, RugoTOK_spawn, RugoTOK_true, RugoTOK_try, RugoTOK_0021, RugoTOK_0028, RugoTOK_002d, RugoTOK_005b, RugoTOK_007b, Rugofloat_lit, Rugoident, Rugointeger, Rugoraw_str_lit, Rugostr_lit, RugoCaseExpr, RugoOrExpr, RugoAndExpr, RugoCompExpr, RugoAddExpr, RugoMulExpr, RugoUnaryExpr, RugoPostfix, RugoPrimary, RugoTryExpr, RugoSpawnExpr, RugoParallelExpr, RugoFnExpr, RugoArrayLit, RugoHashLit:
r = p.add(r, p.Expr())
goto state3
}
return p.stop(r, accept, errorSet)
state3:
accept, errorSet = true, 0
return p.stop(r, accept, errorSet)
}


// BenchDef grammar:
//
//	
//	BenchDef    = "bench" str_lit Body "end" .
//
//	State 0
//		on  "bench"
//			shift and goto state 1
//	State 1
//		on  str_lit
//			shift and goto state 2
//	State 2
//		on  "end"
//			shift and goto state 3
//		on  "bench", "break", "case", "def", "false", "fn", "for", "if", "import", "next", "nil", "parallel", "rats", "require", "return", "sandbox", "spawn", "true", "try", "use", "while", '!', '(', '-', ';', '[', '{', float_lit, ident, integer, raw_str_lit, str_lit, Statement, UseStmt, ImportStmt, RequireStmt, SandboxStmt, FuncDef, TestDef, BenchDef, IfStmt, CaseExpr, WhileStmt, ForStmt, BreakStmt, NextStmt, ReturnStmt, AssignOrExpr, Expr, OrExpr, AndExpr, CompExpr, AddExpr, MulExpr, UnaryExpr, Postfix, Primary, TryExpr, SpawnExpr, ParallelExpr, FnExpr, ArrayLit, HashLit
//			call Body and goto state 4
//	State 3
//		Accept
//	State 4
//		on  "end"
//			shift and goto state 3
// BenchDef is used internally from Parse.
func (p *Parser) BenchDef() (r []int32) {
		accept, errorSet := false, 0
		r = append(p.get(), -int32(RugoBenchDef), 0)
// state0:
accept, errorSet = false, 50
switch Symbol(p.tok.Ch) {
	case  RugoTOK_bench:
r = append(r, p.shift())
goto state1
}
return p.stop(r, accept, errorSet)
state1:
accept, errorSet = false, 49
switch Symbol(p.tok.Ch) {
	case  Rugostr_lit:
r = append(r, p.shift())
goto state2
}
return p.stop(r, accept, errorSet)
state2:
accept, errorSet = false, 41
switch Symbol(p.tok.Ch) {
	case  RugoTOK_end:
r = append(r, p.shift())
goto state3
	case  RugoTOK_bench, RugoTOK_break, RugoTOK_case, RugoTOK_def, RugoTOK_false, RugoTOK_fn, RugoTOK_for, RugoTOK_if, RugoTOK_import, RugoTOK_next, RugoTOK_nil, RugoTOK_parallel, RugoTOK_rats, RugoTOK_require, RugoTOK_return, RugoTOK_sandbox, RugoTOK_spawn, RugoTOK_true, RugoTOK_try, RugoTOK_use, RugoTOK_while, RugoTOK_0021, RugoTOK_0028, RugoTOK_002d, RugoTOK_003b, RugoTOK_005b, RugoTOK_007b, Rugofloat_lit, Rugoident, Rugointeger, Rugoraw_str_lit, Rugostr_lit, RugoStatement, RugoUseStmt, RugoImportStmt, RugoRequireStmt, RugoSandboxStmt, RugoFuncDef, RugoTestDef, RugoBenchDef, RugoIfStmt, RugoCaseExpr, RugoWhileStmt, RugoForStmt, RugoBreakStmt, RugoNextStmt, RugoReturnStmt, RugoAssignOrExpr, RugoExpr, RugoOrExpr, RugoAndExpr, RugoCompExpr, RugoAddExpr, RugoMulExpr, RugoUnaryExpr, RugoPostfix, RugoPrimary, RugoTryExpr, RugoSpawnExpr, RugoParallelExpr, RugoFnExpr, RugoArrayLit, RugoHashLit:
r = p.add(r, p.Body())
goto state4
}
return p.stop(r, accept, errorSet)
state3:
accept, errorSet = true, 0
return p.stop(r, accept, errorSet)
state4:
accept, errorSet = false, 0
switch Symbol(p.tok.Ch) {
	case  RugoTOK_end:
r = append(r, p.shift())
goto state3
}
return p.stop(r, accept, errorSet)
}


// Body grammar:
//
//	
//	Body        = { Statement | ';' } .
//
//	State 0
//		Accept
//		on  ';'
//			shift and goto state 1
//		on  "bench", "break", "case", "def", "false", "fn", "for", "if", "import", "next", "nil", "parallel", "rats", "require", "return", "sandbox", "spawn", "true", "try", "use", "while", '!', '(', '-', '[', '{', float_lit, ident, integer, raw_str_lit, str_lit, UseStmt, ImportStmt, RequireStmt, SandboxStmt, FuncDef, TestDef, BenchDef, IfStmt, CaseExpr, WhileStmt, ForStmt, BreakStmt, NextStmt, ReturnStmt, AssignOrExpr, Expr, OrExpr, AndExpr, CompExpr, AddExpr, MulExpr, UnaryExpr, Postfix, Primary, TryExpr, SpawnExpr, ParallelExpr, FnExpr, ArrayLit, HashLit
//			call Statement and goto state 1
//	State 1
//		Accept
//		on  ';'
//			shift and goto state 1
//		on  "bench", "break", "case", "def", "false", "fn", "for", "if", "import", "next", "nil", "parallel", "rats", "require", "return", "sandbox", "spawn", "true", "try", "use", "while", '!', '(', '-', '[', '{', float_lit, ident, integer, raw_str_lit, str_lit, UseStmt, ImportStmt, RequireStmt, SandboxStmt, FuncDef, TestDef, BenchDef, IfStmt, CaseExpr, WhileStmt, ForStmt, BreakStmt, NextStmt, ReturnStmt, AssignOrExpr, Expr, OrExpr, AndExpr, CompExpr, AddExpr, MulExpr, UnaryExpr, Postfix, Primary, TryExpr, SpawnExpr, ParallelExpr, FnExpr, ArrayLit, HashLit
//			call Statement and goto state 1
// Body is used internally from Parse.
func (p *Parser) Body() (r []int32) {
		accept, errorSet := false, 0
		r = append(p.get(), -int32(RugoBody), 0)
// state0:
accept, errorSet = true, 42
switch Symbol(p.tok.Ch) {
	case  RugoTOK_003b:
r = append(r, p.shift())
goto state1
	case  RugoTOK_bench, RugoTOK_break, RugoTOK_case, RugoTOK_def, RugoTOK_false, RugoTOK_fn, RugoTOK_for, RugoTOK_if, RugoTOK_import, RugoTOK_next, RugoTOK_nil, RugoTOK_parallel, RugoTOK_rats, RugoTOK_require, RugoTOK_return, RugoTOK_sandbox, RugoTOK_spawn, RugoTOK_true, RugoTOK_try, RugoTOK_use, RugoTOK_while, RugoTOK_0021, RugoTOK_0028, RugoTOK_002d, RugoTOK_005b, RugoTOK_007b, Rugofloat_lit, Rugoident, Rugointeger, Rugoraw_str_lit, Rugostr_lit, RugoUseStmt, RugoImportStmt, RugoRequireStmt, RugoSandboxStmt, RugoFuncDef, RugoTestDef, RugoBenchDef, RugoIfStmt, RugoCaseExpr, RugoWhileStmt, RugoForStmt, RugoBreakStmt, RugoNextStmt, RugoReturnStmt, RugoAssignOrExpr, RugoExpr, RugoOrExpr, RugoAndExpr, RugoCompExpr, RugoAddExpr, RugoMulExpr, RugoUnaryExpr, RugoPostfix, RugoPrimary, RugoTryExpr, RugoSpawnExpr, RugoParallelExpr, RugoFnExpr, RugoArrayLit, RugoHashLit:
r = p.add(r, p.Statement())
goto state1
}
return p.stop(r, accept, errorSet)
state1:
accept, errorSet = true, 42
switch Symbol(p.tok.Ch) {
	case  RugoTOK_003b:
r = append(r, p.shift())
goto state1
	case  RugoTOK_bench, RugoTOK_break, RugoTOK_case, RugoTOK_def, RugoTOK_false, RugoTOK_fn, RugoTOK_for, RugoTOK_if, RugoTOK_import, RugoTOK_next, RugoTOK_nil, RugoTOK_parallel, RugoTOK_rats, RugoTOK_require, RugoTOK_return, RugoTOK_sandbox, RugoTOK_spawn, RugoTOK_true, RugoTOK_try, RugoTOK_use, RugoTOK_while, RugoTOK_0021, RugoTOK_0028, RugoTOK_002d, RugoTOK_005b, RugoTOK_007b, Rugofloat_lit, Rugoident, Rugointeger, Rugoraw_str_lit, Rugostr_lit, RugoUseStmt, RugoImportStmt, RugoRequireStmt, RugoSandboxStmt, RugoFuncDef, RugoTestDef, RugoBenchDef, RugoIfStmt, RugoCaseExpr, RugoWhileStmt, RugoForStmt, RugoBreakStmt, RugoNextStmt, RugoReturnStmt, RugoAssignOrExpr, RugoExpr, RugoOrExpr, RugoAndExpr, RugoCompExpr, RugoAddExpr, RugoMulExpr, RugoUnaryExpr, RugoPostfix, RugoPrimary, RugoTryExpr, RugoSpawnExpr, RugoParallelExpr, RugoFnExpr, RugoArrayLit, RugoHashLit:
r = p.add(r, p.Statement())
goto state1
}
return p.stop(r, accept, errorSet)
}


// BreakStmt grammar:
//
//	
//	BreakStmt   = "break" .
//
//	State 0
//		on  "break"
//			shift and goto state 1
//	State 1
//		Accept
// BreakStmt is used internally from Parse.
func (p *Parser) BreakStmt() (r []int32) {
		accept, errorSet := false, 0
		r = append(p.get(), -int32(RugoBreakStmt), 0)
// state0:
accept, errorSet = false, 51
switch Symbol(p.tok.Ch) {
	case  RugoTOK_break:
r = append(r, p.shift())
goto state1
}
return p.stop(r, accept, errorSet)
state1:
accept, errorSet = true, 0
return p.stop(r, accept, errorSet)
}


// CaseExpr grammar:
//
//	
//	CaseExpr    = "case" Expr { "of" ExprList ( "->" Expr | Body ) } { "elsif" Expr ( "->" Expr | Body ) } [ "else" ( "->" Expr | Body ) ] "end" .
//
//	State 0
//		on  "case"
//			shift and goto state 1
//	State 1
//		on  "case", "false", "fn", "nil", "parallel", "spawn", "true", "try", '!', '(', '-', '[', '{', float_lit, ident, integer, raw_str_lit, str_lit, CaseExpr, OrExpr, AndExpr, CompExpr, AddExpr, MulExpr, UnaryExpr, Postfix, Primary, TryExpr, SpawnExpr, ParallelExpr, FnExpr, ArrayLit, HashLit
//			call Expr and goto state 2
//	State 2
//		on  "of"
//			shift and goto state 11
//		on  "else"
//			shift and goto state 3
//		on  "end"
//			shift and goto state 6
//		on  "elsif"
//			shift and goto state 7
//	State 3
//		on  "->"
//			shift and goto state 4
//		on  "end"
//			shift and goto state 6
//		on  "bench", "break", "case", "def", "false", "fn", "for", "if", "import", "next", "nil", "parallel", "rats", "require", "return", "sandbox", "spawn", "true", "try", "use", "while", '!', '(', '-', ';', '[', '{', float_lit, ident, integer, raw_str_lit, str_lit, Statement, UseStmt, ImportStmt, RequireStmt, SandboxStmt, FuncDef, TestDef, BenchDef, IfStmt, CaseExpr, WhileStmt, ForStmt, BreakStmt, NextStmt, ReturnStmt, AssignOrExpr, Expr, OrExpr, AndExpr, CompExpr, AddExpr, MulExpr, UnaryExpr, Postfix, Primary, TryExpr, SpawnExpr, ParallelExpr, FnExpr, ArrayLit, HashLit
//			call Body and goto state 5
//	State 4
//		on  "case", "false", "fn", "nil", "parallel", "spawn", "true", "try", '!', '(', '-', '[', '{', float_lit, ident, integer, raw_str_lit, str_lit, CaseExpr, OrExpr, AndExpr, CompExpr, AddExpr, MulExpr, UnaryExpr, Postfix, Primary, TryExpr, SpawnExpr, ParallelExpr, FnExpr, ArrayLit, HashLit
//			call Expr and goto state 5
//	State 5
//		on  "end"
//			shift and goto state 6
//	State 6
//		Accept
//	State 7
//		on  "case", "false", "fn", "nil", "parallel", "spawn", "true", "try", '!', '(', '-', '[', '{', float_lit, ident, integer, raw_str_lit, str_lit, CaseExpr, OrExpr, AndExpr, CompExpr, AddExpr, MulExpr, UnaryExpr, Postfix, Primary, TryExpr, SpawnExpr, ParallelExpr, FnExpr, ArrayLit, HashLit
//			call Expr and goto state 8
//	State 8
//		on  "else"
//			shift and goto state 3
//		on  "end"
//			shift and goto state 6
//		on  "elsif"
//			shift and goto state 7
//		on  "->"
//			shift and goto state 9
//		on  "bench", "break", "case", "def", "false", "fn", "for", "if", "import", "next", "nil", "parallel", "rats", "require", "return", "sandbox", "spawn", "true", "try", "use", "while", '!', '(', '-', ';', '[', '{', float_lit, ident, integer, raw_str_lit, str_lit, Statement, UseStmt, ImportStmt, RequireStmt, SandboxStmt, FuncDef, TestDef, BenchDef, IfStmt, CaseExpr, WhileStmt, ForStmt, BreakStmt, NextStmt, ReturnStmt, AssignOrExpr, Expr, OrExpr, AndExpr, CompExpr, AddExpr, MulExpr, UnaryExpr, Postfix, Primary, TryExpr, SpawnExpr, ParallelExpr, FnExpr, ArrayLit, HashLit
//			call Body and goto state 10
//	State 9
//		on  "case", "false", "fn", "nil", "parallel", "spawn", "true", "try", '!', '(', '-', '[', '{', float_lit, ident, integer, raw_str_lit, str_lit, CaseExpr, OrExpr, AndExpr, CompExpr, AddExpr, MulExpr, UnaryExpr, Postfix, Primary, TryExpr, SpawnExpr, ParallelExpr, FnExpr, ArrayLit, HashLit
//			call Expr and goto state 10
//	State 10
//		on  "else"
//			shift and goto state 3
//		on  "end"
//			shift and goto state 6
//		on  "elsif"
//			shift and goto state 7
//	State 11
//		on  "case", "false", "fn", "nil", "parallel", "spawn", "true", "try", '!', '(', '-', '[', '{', float_lit, ident, integer, raw_str_lit, str_lit, CaseExpr, Expr, OrExpr, AndExpr, CompExpr, AddExpr, MulExpr, UnaryExpr, Postfix, Primary, TryExpr, SpawnExpr, ParallelExpr, FnExpr, ArrayLit, HashLit
//			call ExprList and goto state 12
//	State 12
//		on  "of"
//			shift and goto state 11
//		on  "->"
//			shift and goto state 1
//		on  "else"
//			shift and goto state 3
//		on  "end"
//			shift and goto state 6
//		on  "elsif"
//			shift and goto state 7
//		on  "bench", "break", "case", "def", "false", "fn", "for", "if", "import", "next", "nil", "parallel", "rats", "require", "return", "sandbox", "spawn", "true", "try", "use", "while", '!', '(', '-', ';', '[', '{', float_lit, ident, integer, raw_str_lit, str_lit, Statement, UseStmt, ImportStmt, RequireStmt, SandboxStmt, FuncDef, TestDef, BenchDef, IfStmt, CaseExpr, WhileStmt, ForStmt, BreakStmt, NextStmt, ReturnStmt, AssignOrExpr, Expr, OrExpr, AndExpr, CompExpr, AddExpr, MulExpr, UnaryExpr, Postfix, Primary, TryExpr, SpawnExpr, ParallelExpr, FnExpr, ArrayLit, HashLit
//			call Body and goto state 2
// CaseExpr is used internally from Parse.
func (p *Parser) CaseExpr() (r []int32) {
		accept, errorSet := false, 0
		r = append(p.get(), -int32(RugoCaseExpr), 0)
// state0:
accept, errorSet = false, 67
switch Symbol(p.tok.Ch) {
	case  RugoTOK_case:
r = append(r, p.shift())
goto state1
}
return p.stop(r, accept, errorSet)
state1:
accept, errorSet = false, 56
switch Symbol(p.tok.Ch) {
	case  RugoTOK_case, RugoTOK_false, RugoTOK_fn, RugoTOK_nil, RugoTOK_parallel, RugoTOK_spawn, RugoTOK_true, RugoTOK_try, RugoTOK_0021, RugoTOK_0028, RugoTOK_002d, RugoTOK_005b, RugoTOK_007b, Rugofloat_lit, Rugoident, Rugointeger, Rugoraw_str_lit, Rugostr_lit, RugoCaseExpr, RugoOrExpr, RugoAndExpr, RugoCompExpr, RugoAddExpr, RugoMulExpr, RugoUnaryExpr, RugoPostfix, RugoPrimary, RugoTryExpr, RugoSpawnExpr, RugoParallelExpr, RugoFnExpr, RugoArrayLit, RugoHashLit:
r = p.add(r, p.Expr())
goto state2
}
return p.stop(r, accept, errorSet)
state2:
accept, errorSet = false, 69
switch Symbol(p.tok.Ch) {
	case  RugoTOK_of:
r = append(r, p.shift())
goto state11
	case  RugoTOK_else:
r = append(r, p.shift())
goto state3
	case  RugoTOK_end:
r = append(r, p.shift())
goto state6
	case  RugoTOK_elsif:
r = append(r, p.shift())
goto state7
}
return p.stop(r, accept, errorSet)
state3:
accept, errorSet = false, 9
switch Symbol(p.tok.Ch) {
	case  RugoTOK_002d003e:
r = append(r, p.shift())
goto state4
	case  RugoTOK_end:
r = append(r, p.shift())
goto state6
	case  RugoTOK_bench, RugoTOK_break, RugoTOK_case, RugoTOK_def, RugoTOK_false, RugoTOK_fn, RugoTOK_for, RugoTOK_if, RugoTOK_import, RugoTOK_next, RugoTOK_nil, RugoTOK_parallel, RugoTOK_rats, RugoTOK_require, RugoTOK_return, RugoTOK_sandbox, RugoTOK_spawn, RugoTOK_true, RugoTOK_try, RugoTOK_use, RugoTOK_while, RugoTOK_0021, RugoTOK_0028, RugoTOK_002d, RugoTOK_003b, RugoTOK_005b, RugoTOK_007b, Rugofloat_lit, Rugoident, Rugointeger, Rugoraw_str_lit, Rugostr_lit, RugoStatement, RugoUseStmt, RugoImportStmt, RugoRequireStmt, RugoSandboxStmt, RugoFuncDef, RugoTestDef, RugoBenchDef, RugoIfStmt, RugoCaseExpr, RugoWhileStmt, RugoForStmt, RugoBreakStmt, RugoNextStmt, RugoReturnStmt, RugoAssignOrExpr, RugoExpr, RugoOrExpr, RugoAndExpr, RugoCompExpr, RugoAddExpr, RugoMulExpr, RugoUnaryExpr, RugoPostfix, RugoPrimary, RugoTryExpr, RugoSpawnExpr, RugoParallelExpr, RugoFnExpr, RugoArrayLit, RugoHashLit:
r = p.add(r, p.Body())
goto state5
}
return p.stop(r, accept, errorSet)
state4:
accept, errorSet = false, 56
switch Symbol(p.tok.Ch) {
	case  RugoTOK_case, RugoTOK_false, RugoTOK_fn, RugoTOK_nil, RugoTOK_parallel, RugoTOK_spawn, RugoTOK_true, RugoTOK_try, RugoTOK_0021, RugoTOK_0028, RugoTOK_002d, RugoTOK_005b, RugoTOK_007b, Rugofloat_lit, Rugoident, Rugointeger, Rugoraw_str_lit, Rugostr_lit, RugoCaseExpr, RugoOrExpr, RugoAndExpr, RugoCompExpr, RugoAddExpr, RugoMulExpr, RugoUnaryExpr, RugoPostfix, RugoPrimary, RugoTryExpr, RugoSpawnExpr, RugoParallelExpr, RugoFnExpr, RugoArrayLit, RugoHashLit:
r = p.add(r, p.Expr())
goto state5
}
return p.stop(r, accept, errorSet)
state5:
accept, errorSet = false, 0
switch Symbol(p.tok.Ch) {
	case  RugoTOK_end:
r = append(r, p.shift())
goto state6
}
return p.stop(r, accept, errorSet)
state6:
accept, errorSet = true, 0
return p.stop(r, accept, errorSet)
state7:
accept, errorSet = false, 56
switch Symbol(p.tok.Ch) {
	case  RugoTOK_case, RugoTOK_false, RugoTOK_fn, RugoTOK_nil, RugoTOK_parallel, RugoTOK_spawn, RugoTOK_true, RugoTOK_try, RugoTOK_0021, RugoTOK_0028, RugoTOK_002d, RugoTOK_005b, RugoTOK_007b, Rugofloat_lit, Rugoident, Rugointeger, Rugoraw_str_lit, Rugostr_lit, RugoCaseExpr, RugoOrExpr, RugoAndExpr, RugoCompExpr, RugoAddExpr, RugoMulExpr, RugoUnaryExpr, RugoPostfix, RugoPrimary, RugoTryExpr, RugoSpawnExpr, RugoParallelExpr, RugoFnExpr, RugoArrayLit, RugoHashLit:
r = p.add(r, p.Expr())
goto state8
}
return p.stop(r, accept, errorSet)
state8:
accept, errorSet = false, 11
switch Symbol(p.tok.Ch) {
	case  RugoTOK_else:
r = append(r, p.shift())
goto state3
	case  RugoTOK_end:
r = append(r, p.shift())
goto state6
	case  RugoTOK_elsif:
r = append(r, p.shift())
goto state7
	case  RugoTOK_002d003e:
r = append(r, p.shift())
goto state9
	case  RugoTOK_bench, RugoTOK_break, RugoTOK_case, RugoTOK_def, RugoTOK_false, RugoTOK_fn, RugoTOK_for, RugoTOK_if, RugoTOK_import, RugoTOK_next, RugoTOK_nil, RugoTOK_parallel, RugoTOK_rats, RugoTOK_require, RugoTOK_return, RugoTOK_sandbox, RugoTOK_spawn, RugoTOK_true, RugoTOK_try, RugoTOK_use, RugoTOK_while, RugoTOK_0021, RugoTOK_0028, RugoTOK_002d, RugoTOK_003b, RugoTOK_005b, RugoTOK_007b, Rugofloat_lit, Rugoident, Rugointeger, Rugoraw_str_lit, Rugostr_lit, RugoStatement, RugoUseStmt, RugoImportStmt, RugoRequireStmt, RugoSandboxStmt, RugoFuncDef, RugoTestDef, RugoBenchDef, RugoIfStmt, RugoCaseExpr, RugoWhileStmt, RugoForStmt, RugoBreakStmt, RugoNextStmt, RugoReturnStmt, RugoAssignOrExpr, RugoExpr, RugoOrExpr, RugoAndExpr, RugoCompExpr, RugoAddExpr, RugoMulExpr, RugoUnaryExpr, RugoPostfix, RugoPrimary, RugoTryExpr, RugoSpawnExpr, RugoParallelExpr, RugoFnExpr, RugoArrayLit, RugoHashLit:
r = p.add(r, p.Body())
goto state10
}
return p.stop(r, accept, errorSet)
state9:
accept, errorSet = false, 56
switch Symbol(p.tok.Ch) {
	case  RugoTOK_case, RugoTOK_false, RugoTOK_fn, RugoTOK_nil, RugoTOK_parallel, RugoTOK_spawn, RugoTOK_true, RugoTOK_try, RugoTOK_0021, RugoTOK_0028, RugoTOK_002d, RugoTOK_005b, RugoTOK_007b, Rugofloat_lit, Rugoident, Rugointeger, Rugoraw_str_lit, Rugostr_lit, RugoCaseExpr, RugoOrExpr, RugoAndExpr, RugoCompExpr, RugoAddExpr, RugoMulExpr, RugoUnaryExpr, RugoPostfix, RugoPrimary, RugoTryExpr, RugoSpawnExpr, RugoParallelExpr, RugoFnExpr, RugoArrayLit, RugoHashLit:
r = p.add(r, p.Expr())
goto state10
}
return p.stop(r, accept, errorSet)
state10:
accept, errorSet = false, 70
switch Symbol(p.tok.Ch) {
	case  RugoTOK_else:
r = append(r, p.shift())
goto state3
	case  RugoTOK_end:
r = append(r, p.shift())
goto state6
	case  RugoTOK_elsif:
r = append(r, p.shift())
goto state7
}
return p.stop(r, accept, errorSet)
state11:
accept, errorSet = false, 55
switch Symbol(p.tok.Ch) {
	case  RugoTOK_case, RugoTOK_false, RugoTOK_fn, RugoTOK_nil, RugoTOK_parallel, RugoTOK_spawn, RugoTOK_true, RugoTOK_try, RugoTOK_0021, RugoTOK_0028, RugoTOK_002d, RugoTOK_005b, RugoTOK_007b, Rugofloat_lit, Rugoident, Rugointeger, Rugoraw_str_lit, Rugostr_lit, RugoCaseExpr, RugoExpr, RugoOrExpr, RugoAndExpr, RugoCompExpr, RugoAddExpr, RugoMulExpr, RugoUnaryExpr, RugoPostfix, RugoPrimary, RugoTryExpr, RugoSpawnExpr, RugoParallelExpr, RugoFnExpr, RugoArrayLit, RugoHashLit:
r = p.add(r, p.ExprList())
goto state12
}
return p.stop(r, accept, errorSet)
state12:
accept, errorSet = false, 10
switch Symbol(p.tok.Ch) {
	case  RugoTOK_of:
r = append(r, p.shift())
goto state11
	case  RugoTOK_002d003e:
r = append(r, p.shift())
goto state1
	case  RugoTOK_else:
r = append(r, p.shift())
goto state3
	case  RugoTOK_end:
r = append(r, p.shift())
goto state6
	case  RugoTOK_elsif:
r = append(r, p.shift())
goto state7
	case  RugoTOK_bench, RugoTOK_break, RugoTOK_case, RugoTOK_def, RugoTOK_false, RugoTOK_fn, RugoTOK_for, RugoTOK_if, RugoTOK_import, RugoTOK_next, RugoTOK_nil, RugoTOK_parallel, RugoTOK_rats, RugoTOK_require, RugoTOK_return, RugoTOK_sandbox, RugoTOK_spawn, RugoTOK_true, RugoTOK_try, RugoTOK_use, RugoTOK_while, RugoTOK_0021, RugoTOK_0028, RugoTOK_002d, RugoTOK_003b, RugoTOK_005b, RugoTOK_007b, Rugofloat_lit, Rugoident, Rugointeger, Rugoraw_str_lit, Rugostr_lit, RugoStatement, RugoUseStmt, RugoImportStmt, RugoRequireStmt, RugoSandboxStmt, RugoFuncDef, RugoTestDef, RugoBenchDef, RugoIfStmt, RugoCaseExpr, RugoWhileStmt, RugoForStmt, RugoBreakStmt, RugoNextStmt, RugoReturnStmt, RugoAssignOrExpr, RugoExpr, RugoOrExpr, RugoAndExpr, RugoCompExpr, RugoAddExpr, RugoMulExpr, RugoUnaryExpr, RugoPostfix, RugoPrimary, RugoTryExpr, RugoSpawnExpr, RugoParallelExpr, RugoFnExpr, RugoArrayLit, RugoHashLit:
r = p.add(r, p.Body())
goto state2
}
return p.stop(r, accept, errorSet)
}


// CompExpr grammar:
//
//	
//	CompExpr    = AddExpr [ comp_op AddExpr ] .
//
//	State 0
//		on  "case", "false", "fn", "nil", "parallel", "spawn", "true", "try", '!', '(', '-', '[', '{', float_lit, ident, integer, raw_str_lit, str_lit, CaseExpr, MulExpr, UnaryExpr, Postfix, Primary, TryExpr, SpawnExpr, ParallelExpr, FnExpr, ArrayLit, HashLit
//			call AddExpr and goto state 1
//	State 1
//		Accept
//		on  comp_op
//			shift and goto state 2
//	State 2
//		on  "case", "false", "fn", "nil", "parallel", "spawn", "true", "try", '!', '(', '-', '[', '{', float_lit, ident, integer, raw_str_lit, str_lit, CaseExpr, MulExpr, UnaryExpr, Postfix, Primary, TryExpr, SpawnExpr, ParallelExpr, FnExpr, ArrayLit, HashLit
//			call AddExpr and goto state 3
//	State 3
//		Accept
// CompExpr is used internally from Parse.
func (p *Parser) CompExpr() (r []int32) {
		accept, errorSet := false, 0
		r = append(p.get(), -int32(RugoCompExpr), 0)
// state0:
accept, errorSet = false, 60
switch Symbol(p.tok.Ch) {
	case  RugoTOK_case, RugoTOK_false, RugoTOK_fn, RugoTOK_nil, RugoTOK_parallel, RugoTOK_spawn, RugoTOK_true, RugoTOK_try, RugoTOK_0021, RugoTOK_0028, RugoTOK_002d, RugoTOK_005b, RugoTOK_007b, Rugofloat_lit, Rugoident, Rugointeger, Rugoraw_str_lit, Rugostr_lit, RugoCaseExpr, RugoMulExpr, RugoUnaryExpr, RugoPostfix, RugoPrimary, RugoTryExpr, RugoSpawnExpr, RugoParallelExpr, RugoFnExpr, RugoArrayLit, RugoHashLit:
r = p.add(r, p.AddExpr())
goto state1
}
return p.stop(r, accept, errorSet)
state1:
accept, errorSet = true, 45
switch Symbol(p.tok.Ch) {
	case  Rugocomp_op:
r = append(r, p.shift())
goto state2
}
return p.stop(r, accept, errorSet)
state2:
accept, errorSet = false, 60
switch Symbol(p.tok.Ch) {
	case  RugoTOK_case, RugoTOK_false, RugoTOK_fn, RugoTOK_nil, RugoTOK_parallel, RugoTOK_spawn, RugoTOK_true, RugoTOK_try, RugoTOK_0021, RugoTOK_0028, RugoTOK_002d, RugoTOK_005b, RugoTOK_007b, Rugofloat_lit, Rugoident, Rugointeger, Rugoraw_str_lit, Rugostr_lit, RugoCaseExpr, RugoMulExpr, RugoUnaryExpr, RugoPostfix, RugoPrimary, RugoTryExpr, RugoSpawnExpr, RugoParallelExpr, RugoFnExpr, RugoArrayLit, RugoHashLit:
r = p.add(r, p.AddExpr())
goto state3
}
return p.stop(r, accept, errorSet)
state3:
accept, errorSet = true, 0
return p.stop(r, accept, errorSet)
}


// Expr grammar:
//
//	
//	
//	# Expressions (lowest to highest precedence)
//	Expr        = OrExpr .
//
//	State 0
//		on  "case", "false", "fn", "nil", "parallel", "spawn", "true", "try", '!', '(', '-', '[', '{', float_lit, ident, integer, raw_str_lit, str_lit, CaseExpr, AndExpr, CompExpr, AddExpr, MulExpr, UnaryExpr, Postfix, Primary, TryExpr, SpawnExpr, ParallelExpr, FnExpr, ArrayLit, HashLit
//			call OrExpr and goto state 1
//	State 1
//		Accept
// Expr is used internally from Parse.
func (p *Parser) Expr() (r []int32) {
		accept, errorSet := false, 0
		r = append(p.get(), -int32(RugoExpr), 0)
// state0:
accept, errorSet = false, 57
switch Symbol(p.tok.Ch) {
	case  RugoTOK_case, RugoTOK_false, RugoTOK_fn, RugoTOK_nil, RugoTOK_parallel, RugoTOK_spawn, RugoTOK_true, RugoTOK_try, RugoTOK_0021, RugoTOK_0028, RugoTOK_002d, RugoTOK_005b, RugoTOK_007b, Rugofloat_lit, Rugoident, Rugointeger, Rugoraw_str_lit, Rugostr_lit, RugoCaseExpr, RugoAndExpr, RugoCompExpr, RugoAddExpr, RugoMulExpr, RugoUnaryExpr, RugoPostfix, RugoPrimary, RugoTryExpr, RugoSpawnExpr, RugoParallelExpr, RugoFnExpr, RugoArrayLit, RugoHashLit:
r = p.add(r, p.OrExpr())
goto state1
}
return p.stop(r, accept, errorSet)
state1:
accept, errorSet = true, 0
return p.stop(r, accept, errorSet)
}


// ExprList grammar:
//
//	
//	ExprList    = Expr { ',' Expr } .
//
//	State 0
//		on  "case", "false", "fn", "nil", "parallel", "spawn", "true", "try", '!', '(', '-', '[', '{', float_lit, ident, integer, raw_str_lit, str_lit, CaseExpr, OrExpr, AndExpr, CompExpr, AddExpr, MulExpr, UnaryExpr, Postfix, Primary, TryExpr, SpawnExpr, ParallelExpr, FnExpr, ArrayLit, HashLit
//			call Expr and goto state 1
//	State 1
//		Accept
//		on  ','
//			shift and goto state 0
// ExprList is used internally from Parse.
func (p *Parser) ExprList() (r []int32) {
		accept, errorSet := false, 0
		r = append(p.get(), -int32(RugoExprList), 0)
state0:
accept, errorSet = false, 56
switch Symbol(p.tok.Ch) {
	case  RugoTOK_case, RugoTOK_false, RugoTOK_fn, RugoTOK_nil, RugoTOK_parallel, RugoTOK_spawn, RugoTOK_true, RugoTOK_try, RugoTOK_0021, RugoTOK_0028, RugoTOK_002d, RugoTOK_005b, RugoTOK_007b, Rugofloat_lit, Rugoident, Rugointeger, Rugoraw_str_lit, Rugostr_lit, RugoCaseExpr, RugoOrExpr, RugoAndExpr, RugoCompExpr, RugoAddExpr, RugoMulExpr, RugoUnaryExpr, RugoPostfix, RugoPrimary, RugoTryExpr, RugoSpawnExpr, RugoParallelExpr, RugoFnExpr, RugoArrayLit, RugoHashLit:
r = p.add(r, p.Expr())
goto state1
}
return p.stop(r, accept, errorSet)
state1:
accept, errorSet = true, 33
switch Symbol(p.tok.Ch) {
	case  RugoTOK_002c:
r = append(r, p.shift())
goto state0
}
return p.stop(r, accept, errorSet)
}


// FnExpr grammar:
//
//	
//	FnExpr       = "fn" '(' [ ParamList ] ')' Body "end" .
//
//	State 0
//		on  "fn"
//			shift and goto state 1
//	State 1
//		on  '('
//			shift and goto state 2
//	State 2
//		on  ')'
//			shift and goto state 3
//		on  ident, Param
//			call ParamList and goto state 6
//	State 3
//		on  "end"
//			shift and goto state 4
//		on  "bench", "break", "case", "def", "false", "fn", "for", "if", "import", "next", "nil", "parallel", "rats", "require", "return", "sandbox", "spawn", "true", "try", "use", "while", '!', '(', '-', ';', '[', '{', float_lit, ident, integer, raw_str_lit, str_lit, Statement, UseStmt, ImportStmt, RequireStmt, SandboxStmt, FuncDef, TestDef, BenchDef, IfStmt, CaseExpr, WhileStmt, ForStmt, BreakStmt, NextStmt, ReturnStmt, AssignOrExpr, Expr, OrExpr, AndExpr, CompExpr, AddExpr, MulExpr, UnaryExpr, Postfix, Primary, TryExpr, SpawnExpr, ParallelExpr, FnExpr, ArrayLit, HashLit
//			call Body and goto state 5
//	State 4
//		Accept
//	State 5
//		on  "end"
//			shift and goto state 4
//	State 6
//		on  ')'
//			shift and goto state 3
// FnExpr is used internally from Parse.
func (p *Parser) FnExpr() (r []int32) {
		accept, errorSet := false, 0
		r = append(p.get(), -int32(RugoFnExpr), 0)
// state0:
accept, errorSet = false, 1
switch Symbol(p.tok.Ch) {
	case  RugoTOK_fn:
r = append(r, p.shift())
goto state1
}
return p.stop(r, accept, errorSet)
state1:
accept, errorSet = false, 25
switch Symbol(p.tok.Ch) {
	case  RugoTOK_0028:
r = append(r, p.shift())
goto state2
}
return p.stop(r, accept, errorSet)
state2:
accept, errorSet = false, 26
switch Symbol(p.tok.Ch) {
	case  RugoTOK_0029:
r = append(r, p.shift())
goto state3
	case  Rugoident, RugoParam:
r = p.add(r, p.ParamList())
goto state6
}
return p.stop(r, accept, errorSet)
state3:
accept, errorSet = false, 41
switch Symbol(p.tok.Ch) {
	case  RugoTOK_end:
r = append(r, p.shift())
goto state4
	case  RugoTOK_bench, RugoTOK_break, RugoTOK_case, RugoTOK_def, RugoTOK_false, RugoTOK_fn, RugoTOK_for, RugoTOK_if, RugoTOK_import, RugoTOK_next, RugoTOK_nil, RugoTOK_parallel, RugoTOK_rats, RugoTOK_require, RugoTOK_return, RugoTOK_sandbox, RugoTOK_spawn, RugoTOK_true, RugoTOK_try, RugoTOK_use, RugoTOK_while, RugoTOK_0021, RugoTOK_0028, RugoTOK_002d, RugoTOK_003b, RugoTOK_005b, RugoTOK_007b, Rugofloat_lit, Rugoident, Rugointeger, Rugoraw_str_lit, Rugostr_lit, RugoStatement, RugoUseStmt, RugoImportStmt, RugoRequireStmt, RugoSandboxStmt, RugoFuncDef, RugoTestDef, RugoBenchDef, RugoIfStmt, RugoCaseExpr, RugoWhileStmt, RugoForStmt, RugoBreakStmt, RugoNextStmt, RugoReturnStmt, RugoAssignOrExpr, RugoExpr, RugoOrExpr, RugoAndExpr, RugoCompExpr, RugoAddExpr, RugoMulExpr, RugoUnaryExpr, RugoPostfix, RugoPrimary, RugoTryExpr, RugoSpawnExpr, RugoParallelExpr, RugoFnExpr, RugoArrayLit, RugoHashLit:
r = p.add(r, p.Body())
goto state5
}
return p.stop(r, accept, errorSet)
state4:
accept, errorSet = true, 0
return p.stop(r, accept, errorSet)
state5:
accept, errorSet = false, 0
switch Symbol(p.tok.Ch) {
	case  RugoTOK_end:
r = append(r, p.shift())
goto state4
}
return p.stop(r, accept, errorSet)
state6:
accept, errorSet = false, 27
switch Symbol(p.tok.Ch) {
	case  RugoTOK_0029:
r = append(r, p.shift())
goto state3
}
return p.stop(r, accept, errorSet)
}


// ForStmt grammar:
//
//	
//	ForStmt     = "for" ident [ ',' ident ] "in" Expr Body "end" .
//
//	State 0
//		on  "for"
//			shift and goto state 1
//	State 1
//		on  ident
//			shift and goto state 2
//	State 2
//		on  "in"
//			shift and goto state 3
//		on  ','
//			shift and goto state 7
//	State 3
//		on  "case", "false", "fn", "nil", "parallel", "spawn", "true", "try", '!', '(', '-', '[', '{', float_lit, ident, integer, raw_str_lit, str_lit, CaseExpr, OrExpr, AndExpr, CompExpr, AddExpr, MulExpr, UnaryExpr, Postfix, Primary, TryExpr, SpawnExpr, ParallelExpr, FnExpr, ArrayLit, HashLit
//			call Expr and goto state 4
//	State 4
//		on  "end"
//			shift and goto state 5
//		on  "bench", "break", "case", "def", "false", "fn", "for", "if", "import", "next", "nil", "parallel", "rats", "require", "return", "sandbox", "spawn", "true", "try", "use", "while", '!', '(', '-', ';', '[', '{', float_lit, ident, integer, raw_str_lit, str_lit, Statement, UseStmt, ImportStmt, RequireStmt, SandboxStmt, FuncDef, TestDef, BenchDef, IfStmt, CaseExpr, WhileStmt, ForStmt, BreakStmt, NextStmt, ReturnStmt, AssignOrExpr, Expr, OrExpr, AndExpr, CompExpr, AddExpr, MulExpr, UnaryExpr, Postfix, Primary, TryExpr, SpawnExpr, ParallelExpr, FnExpr, ArrayLit, HashLit
//			call Body and goto state 6
//	State 5
//		Accept
//	State 6
//		on  "end"
//			shift and goto state 5
//	State 7
//		on  ident
//			shift and goto state 8
//	State 8
//		on  "in"
//			shift and goto state 3
// ForStmt is used internally from Parse.
func (p *Parser) ForStmt() (r []int32) {
		accept, errorSet := false, 0
		r = append(p.get(), -int32(RugoForStmt), 0)
// state0:
accept, errorSet = false, 2
switch Symbol(p.tok.Ch) {
	case  RugoTOK_for:
r = append(r, p.shift())
goto state1
}
return p.stop(r, accept, errorSet)
state1:
accept, errorSet = false, 47
switch Symbol(p.tok.Ch) {
	case  Rugoident:
r = append(r, p.shift())
goto state2
}
return p.stop(r, accept, errorSet)
state2:
accept, errorSet = false, 5
switch Symbol(p.tok.Ch) {
	case  RugoTOK_in:
r = append(r, p.shift())
goto state3
	case  RugoTOK_002c:
r = append(r, p.shift())
goto state7
}
return p.stop(r, accept, errorSet)
state3:
accept, errorSet = false, 56
switch Symbol(p.tok.Ch) {
	case  RugoTOK_case, RugoTOK_false, RugoTOK_fn, RugoTOK_nil, RugoTOK_parallel, RugoTOK_spawn, RugoTOK_true, RugoTOK_try, RugoTOK_0021, RugoTOK_0028, RugoTOK_002d, RugoTOK_005b, RugoTOK_007b, Rugofloat_lit, Rugoident, Rugointeger, Rugoraw_str_lit, Rugostr_lit, RugoCaseExpr, RugoOrExpr, RugoAndExpr, RugoCompExpr, RugoAddExpr, RugoMulExpr, RugoUnaryExpr, RugoPostfix, RugoPrimary, RugoTryExpr, RugoSpawnExpr, RugoParallelExpr, RugoFnExpr, RugoArrayLit, RugoHashLit:
r = p.add(r, p.Expr())
goto state4
}
return p.stop(r, accept, errorSet)
state4:
accept, errorSet = false, 41
switch Symbol(p.tok.Ch) {
	case  RugoTOK_end:
r = append(r, p.shift())
goto state5
	case  RugoTOK_bench, RugoTOK_break, RugoTOK_case, RugoTOK_def, RugoTOK_false, RugoTOK_fn, RugoTOK_for, RugoTOK_if, RugoTOK_import, RugoTOK_next, RugoTOK_nil, RugoTOK_parallel, RugoTOK_rats, RugoTOK_require, RugoTOK_return, RugoTOK_sandbox, RugoTOK_spawn, RugoTOK_true, RugoTOK_try, RugoTOK_use, RugoTOK_while, RugoTOK_0021, RugoTOK_0028, RugoTOK_002d, RugoTOK_003b, RugoTOK_005b, RugoTOK_007b, Rugofloat_lit, Rugoident, Rugointeger, Rugoraw_str_lit, Rugostr_lit, RugoStatement, RugoUseStmt, RugoImportStmt, RugoRequireStmt, RugoSandboxStmt, RugoFuncDef, RugoTestDef, RugoBenchDef, RugoIfStmt, RugoCaseExpr, RugoWhileStmt, RugoForStmt, RugoBreakStmt, RugoNextStmt, RugoReturnStmt, RugoAssignOrExpr, RugoExpr, RugoOrExpr, RugoAndExpr, RugoCompExpr, RugoAddExpr, RugoMulExpr, RugoUnaryExpr, RugoPostfix, RugoPrimary, RugoTryExpr, RugoSpawnExpr, RugoParallelExpr, RugoFnExpr, RugoArrayLit, RugoHashLit:
r = p.add(r, p.Body())
goto state6
}
return p.stop(r, accept, errorSet)
state5:
accept, errorSet = true, 0
return p.stop(r, accept, errorSet)
state6:
accept, errorSet = false, 0
switch Symbol(p.tok.Ch) {
	case  RugoTOK_end:
r = append(r, p.shift())
goto state5
}
return p.stop(r, accept, errorSet)
state7:
accept, errorSet = false, 47
switch Symbol(p.tok.Ch) {
	case  Rugoident:
r = append(r, p.shift())
goto state8
}
return p.stop(r, accept, errorSet)
state8:
accept, errorSet = false, 6
switch Symbol(p.tok.Ch) {
	case  RugoTOK_in:
r = append(r, p.shift())
goto state3
}
return p.stop(r, accept, errorSet)
}


// FuncDef grammar:
//
//	
//	FuncDef     = "def" ident '(' [ ParamList ] ')' Body "end" .
//
//	State 0
//		on  "def"
//			shift and goto state 1
//	State 1
//		on  ident
//			shift and goto state 2
//	State 2
//		on  '('
//			shift and goto state 3
//	State 3
//		on  ')'
//			shift and goto state 4
//		on  ident, Param
//			call ParamList and goto state 7
//	State 4
//		on  "end"
//			shift and goto state 5
//		on  "bench", "break", "case", "def", "false", "fn", "for", "if", "import", "next", "nil", "parallel", "rats", "require", "return", "sandbox", "spawn", "true", "try", "use", "while", '!', '(', '-', ';', '[', '{', float_lit, ident, integer, raw_str_lit, str_lit, Statement, UseStmt, ImportStmt, RequireStmt, SandboxStmt, FuncDef, TestDef, BenchDef, IfStmt, CaseExpr, WhileStmt, ForStmt, BreakStmt, NextStmt, ReturnStmt, AssignOrExpr, Expr, OrExpr, AndExpr, CompExpr, AddExpr, MulExpr, UnaryExpr, Postfix, Primary, TryExpr, SpawnExpr, ParallelExpr, FnExpr, ArrayLit, HashLit
//			call Body and goto state 6
//	State 5
//		Accept
//	State 6
//		on  "end"
//			shift and goto state 5
//	State 7
//		on  ')'
//			shift and goto state 4
// FuncDef is used internally from Parse.
func (p *Parser) FuncDef() (r []int32) {
		accept, errorSet := false, 0
		r = append(p.get(), -int32(RugoFuncDef), 0)
// state0:
accept, errorSet = false, 68
switch Symbol(p.tok.Ch) {
	case  RugoTOK_def:
r = append(r, p.shift())
goto state1
}
return p.stop(r, accept, errorSet)
state1:
accept, errorSet = false, 47
switch Symbol(p.tok.Ch) {
	case  Rugoident:
r = append(r, p.shift())
goto state2
}
return p.stop(r, accept, errorSet)
state2:
accept, errorSet = false, 25
switch Symbol(p.tok.Ch) {
	case  RugoTOK_0028:
r = append(r, p.shift())
goto state3
}
return p.stop(r, accept, errorSet)
state3:
accept, errorSet = false, 26
switch Symbol(p.tok.Ch) {
	case  RugoTOK_0029:
r = append(r, p.shift())
goto state4
	case  Rugoident, RugoParam:
r = p.add(r, p.ParamList())
goto state7
}
return p.stop(r, accept, errorSet)
state4:
accept, errorSet = false, 41
switch Symbol(p.tok.Ch) {
	case  RugoTOK_end:
r = append(r, p.shift())
goto state5
	case  RugoTOK_bench, RugoTOK_break, RugoTOK_case, RugoTOK_def, RugoTOK_false, RugoTOK_fn, RugoTOK_for, RugoTOK_if, RugoTOK_import, RugoTOK_next, RugoTOK_nil, RugoTOK_parallel, RugoTOK_rats, RugoTOK_require, RugoTOK_return, RugoTOK_sandbox, RugoTOK_spawn, RugoTOK_true, RugoTOK_try, RugoTOK_use, RugoTOK_while, RugoTOK_0021, RugoTOK_0028, RugoTOK_002d, RugoTOK_003b, RugoTOK_005b, RugoTOK_007b, Rugofloat_lit, Rugoident, Rugointeger, Rugoraw_str_lit, Rugostr_lit, RugoStatement, RugoUseStmt, RugoImportStmt, RugoRequireStmt, RugoSandboxStmt, RugoFuncDef, RugoTestDef, RugoBenchDef, RugoIfStmt, RugoCaseExpr, RugoWhileStmt, RugoForStmt, RugoBreakStmt, RugoNextStmt, RugoReturnStmt, RugoAssignOrExpr, RugoExpr, RugoOrExpr, RugoAndExpr, RugoCompExpr, RugoAddExpr, RugoMulExpr, RugoUnaryExpr, RugoPostfix, RugoPrimary, RugoTryExpr, RugoSpawnExpr, RugoParallelExpr, RugoFnExpr, RugoArrayLit, RugoHashLit:
r = p.add(r, p.Body())
goto state6
}
return p.stop(r, accept, errorSet)
state5:
accept, errorSet = true, 0
return p.stop(r, accept, errorSet)
state6:
accept, errorSet = false, 0
switch Symbol(p.tok.Ch) {
	case  RugoTOK_end:
r = append(r, p.shift())
goto state5
}
return p.stop(r, accept, errorSet)
state7:
accept, errorSet = false, 27
switch Symbol(p.tok.Ch) {
	case  RugoTOK_0029:
r = append(r, p.shift())
goto state4
}
return p.stop(r, accept, errorSet)
}


// HashEntry grammar:
//
//	
//	HashEntry   = Expr "=>" Expr .
//
//	State 0
//		on  "case", "false", "fn", "nil", "parallel", "spawn", "true", "try", '!', '(', '-', '[', '{', float_lit, ident, integer, raw_str_lit, str_lit, CaseExpr, OrExpr, AndExpr, CompExpr, AddExpr, MulExpr, UnaryExpr, Postfix, Primary, TryExpr, SpawnExpr, ParallelExpr, FnExpr, ArrayLit, HashLit
//			call Expr and goto state 1
//	State 1
//		on  "=>"
//			shift and goto state 2
//	State 2
//		on  "case", "false", "fn", "nil", "parallel", "spawn", "true", "try", '!', '(', '-', '[', '{', float_lit, ident, integer, raw_str_lit, str_lit, CaseExpr, OrExpr, AndExpr, CompExpr, AddExpr, MulExpr, UnaryExpr, Postfix, Primary, TryExpr, SpawnExpr, ParallelExpr, FnExpr, ArrayLit, HashLit
//			call Expr and goto state 3
//	State 3
//		Accept
// HashEntry is used internally from Parse.
func (p *Parser) HashEntry() (r []int32) {
		accept, errorSet := false, 0
		r = append(p.get(), -int32(RugoHashEntry), 0)
// state0:
accept, errorSet = false, 56
switch Symbol(p.tok.Ch) {
	case  RugoTOK_case, RugoTOK_false, RugoTOK_fn, RugoTOK_nil, RugoTOK_parallel, RugoTOK_spawn, RugoTOK_true, RugoTOK_try, RugoTOK_0021, RugoTOK_0028, RugoTOK_002d, RugoTOK_005b, RugoTOK_007b, Rugofloat_lit, Rugoident, Rugointeger, Rugoraw_str_lit, Rugostr_lit, RugoCaseExpr, RugoOrExpr, RugoAndExpr, RugoCompExpr, RugoAddExpr, RugoMulExpr, RugoUnaryExpr, RugoPostfix, RugoPrimary, RugoTryExpr, RugoSpawnExpr, RugoParallelExpr, RugoFnExpr, RugoArrayLit, RugoHashLit:
r = p.add(r, p.Expr())
goto state1
}
return p.stop(r, accept, errorSet)
state1:
accept, errorSet = false, 29
switch Symbol(p.tok.Ch) {
	case  RugoTOK_003d003e:
r = append(r, p.shift())
goto state2
}
return p.stop(r, accept, errorSet)
state2:
accept, errorSet = false, 56
switch Symbol(p.tok.Ch) {
	case  RugoTOK_case, RugoTOK_false, RugoTOK_fn, RugoTOK_nil, RugoTOK_parallel, RugoTOK_spawn, RugoTOK_true, RugoTOK_try, RugoTOK_0021, RugoTOK_0028, RugoTOK_002d, RugoTOK_005b, RugoTOK_007b, Rugofloat_lit, Rugoident, Rugointeger, Rugoraw_str_lit, Rugostr_lit, RugoCaseExpr, RugoOrExpr, RugoAndExpr, RugoCompExpr, RugoAddExpr, RugoMulExpr, RugoUnaryExpr, RugoPostfix, RugoPrimary, RugoTryExpr, RugoSpawnExpr, RugoParallelExpr, RugoFnExpr, RugoArrayLit, RugoHashLit:
r = p.add(r, p.Expr())
goto state3
}
return p.stop(r, accept, errorSet)
state3:
accept, errorSet = true, 0
return p.stop(r, accept, errorSet)
}


// HashLit grammar:
//
//	
//	HashLit     = '{' [ HashEntry { ',' HashEntry } ] '}' .
//
//	State 0
//		on  '{'
//			shift and goto state 1
//	State 1
//		on  '}'
//			shift and goto state 2
//		on  "case", "false", "fn", "nil", "parallel", "spawn", "true", "try", '!', '(', '-', '[', '{', float_lit, ident, integer, raw_str_lit, str_lit, CaseExpr, Expr, OrExpr, AndExpr, CompExpr, AddExpr, MulExpr, UnaryExpr, Postfix, Primary, TryExpr, SpawnExpr, ParallelExpr, FnExpr, ArrayLit, HashLit
//			call HashEntry and goto state 3
//	State 2
//		Accept
//	State 3
//		on  '}'
//			shift and goto state 2
//		on  ','
//			shift and goto state 4
//	State 4
//		on  "case", "false", "fn", "nil", "parallel", "spawn", "true", "try", '!', '(', '-', '[', '{', float_lit, ident, integer, raw_str_lit, str_lit, CaseExpr, Expr, OrExpr, AndExpr, CompExpr, AddExpr, MulExpr, UnaryExpr, Postfix, Primary, TryExpr, SpawnExpr, ParallelExpr, FnExpr, ArrayLit, HashLit
//			call HashEntry and goto state 3
// HashLit is used internally from Parse.
func (p *Parser) HashLit() (r []int32) {
		accept, errorSet := false, 0
		r = append(p.get(), -int32(RugoHashLit), 0)
// state0:
accept, errorSet = false, 39
switch Symbol(p.tok.Ch) {
	case  RugoTOK_007b:
r = append(r, p.shift())
goto state1
}
return p.stop(r, accept, errorSet)
state1:
accept, errorSet = false, 54
switch Symbol(p.tok.Ch) {
	case  RugoTOK_007d:
r = append(r, p.shift())
goto state2
	case  RugoTOK_case, RugoTOK_false, RugoTOK_fn, RugoTOK_nil, RugoTOK_parallel, RugoTOK_spawn, RugoTOK_true, RugoTOK_try, RugoTOK_0021, RugoTOK_0028, RugoTOK_002d, RugoTOK_005b, RugoTOK_007b, Rugofloat_lit, Rugoident, Rugointeger, Rugoraw_str_lit, Rugostr_lit, RugoCaseExpr, RugoExpr, RugoOrExpr, RugoAndExpr, RugoCompExpr, RugoAddExpr, RugoMulExpr, RugoUnaryExpr, RugoPostfix, RugoPrimary, RugoTryExpr, RugoSpawnExpr, RugoParallelExpr, RugoFnExpr, RugoArrayLit, RugoHashLit:
r = p.add(r, p.HashEntry())
goto state3
}
return p.stop(r, accept, errorSet)
state2:
accept, errorSet = true, 0
return p.stop(r, accept, errorSet)
state3:
accept, errorSet = false, 32
switch Symbol(p.tok.Ch) {
	case  RugoTOK_007d:
r = append(r, p.shift())
goto state2
	case  RugoTOK_002c:
r = append(r, p.shift())
goto state4
}
return p.stop(r, accept, errorSet)
state4:
accept, errorSet = false, 55
switch Symbol(p.tok.Ch) {
	case  RugoTOK_case, RugoTOK_false, RugoTOK_fn, RugoTOK_nil, RugoTOK_parallel, RugoTOK_spawn, RugoTOK_true, RugoTOK_try, RugoTOK_0021, RugoTOK_0028, RugoTOK_002d, RugoTOK_005b, RugoTOK_007b, Rugofloat_lit, Rugoident, Rugointeger, Rugoraw_str_lit, Rugostr_lit, RugoCaseExpr, RugoExpr, RugoOrExpr, RugoAndExpr, RugoCompExpr, RugoAddExpr, RugoMulExpr, RugoUnaryExpr, RugoPostfix, RugoPrimary, RugoTryExpr, RugoSpawnExpr, RugoParallelExpr, RugoFnExpr, RugoArrayLit, RugoHashLit:
r = p.add(r, p.HashEntry())
goto state3
}
return p.stop(r, accept, errorSet)
}


// IfStmt grammar:
//
//	
//	IfStmt      = "if" Expr Body { "elsif" Expr Body } [ "else" Body ] "end" .
//
//	State 0
//		on  "if"
//			shift and goto state 1
//	State 1
//		on  "case", "false", "fn", "nil", "parallel", "spawn", "true", "try", '!', '(', '-', '[', '{', float_lit, ident, integer, raw_str_lit, str_lit, CaseExpr, OrExpr, AndExpr, CompExpr, AddExpr, MulExpr, UnaryExpr, Postfix, Primary, TryExpr, SpawnExpr, ParallelExpr, FnExpr, ArrayLit, HashLit
//			call Expr and goto state 2
//	State 2
//		on  "elsif"
//			shift and goto state 1
//		on  "else"
//			shift and goto state 3
//		on  "end"
//			shift and goto state 4
//		on  "bench", "break", "case", "def", "false", "fn", "for", "if", "import", "next", "nil", "parallel", "rats", "require", "return", "sandbox", "spawn", "true", "try", "use", "while", '!', '(', '-', ';', '[', '{', float_lit, ident, integer, raw_str_lit, str_lit, Statement, UseStmt, ImportStmt, RequireStmt, SandboxStmt, FuncDef, TestDef, BenchDef, IfStmt, CaseExpr, WhileStmt, ForStmt, BreakStmt, NextStmt, ReturnStmt, AssignOrExpr, Expr, OrExpr, AndExpr, CompExpr, AddExpr, MulExpr, UnaryExpr, Postfix, Primary, TryExpr, SpawnExpr, ParallelExpr, FnExpr, ArrayLit, HashLit
//			call Body and goto state 6
//	State 3
//		on  "end"
//			shift and goto state 4
//		on  "bench", "break", "case", "def", "false", "fn", "for", "if", "import", "next", "nil", "parallel", "rats", "require", "return", "sandbox", "spawn", "true", "try", "use", "while", '!', '(', '-', ';', '[', '{', float_lit, ident, integer, raw_str_lit, str_lit, Statement, UseStmt, ImportStmt, RequireStmt, SandboxStmt, FuncDef, TestDef, BenchDef, IfStmt, CaseExpr, WhileStmt, ForStmt, BreakStmt, NextStmt, ReturnStmt, AssignOrExpr, Expr, OrExpr, AndExpr, CompExpr, AddExpr, MulExpr, UnaryExpr, Postfix, Primary, TryExpr, SpawnExpr, ParallelExpr, FnExpr, ArrayLit, HashLit
//			call Body and goto state 5
//	State 4
//		Accept
//	State 5
//		on  "end"
//			shift and goto state 4
//	State 6
//		on  "elsif"
//			shift and goto state 1
//		on  "else"
//			shift and goto state 3
//		on  "end"
//			shift and goto state 4
// IfStmt is used internally from Parse.
func (p *Parser) IfStmt() (r []int32) {
		accept, errorSet := false, 0
		r = append(p.get(), -int32(RugoIfStmt), 0)
// state0:
accept, errorSet = false, 3
switch Symbol(p.tok.Ch) {
	case  RugoTOK_if:
r = append(r, p.shift())
goto state1
}
return p.stop(r, accept, errorSet)
state1:
accept, errorSet = false, 56
switch Symbol(p.tok.Ch) {
	case  RugoTOK_case, RugoTOK_false, RugoTOK_fn, RugoTOK_nil, RugoTOK_parallel, RugoTOK_spawn, RugoTOK_true, RugoTOK_try, RugoTOK_0021, RugoTOK_0028, RugoTOK_002d, RugoTOK_005b, RugoTOK_007b, Rugofloat_lit, Rugoident, Rugointeger, Rugoraw_str_lit, Rugostr_lit, RugoCaseExpr, RugoOrExpr, RugoAndExpr, RugoCompExpr, RugoAddExpr, RugoMulExpr, RugoUnaryExpr, RugoPostfix, RugoPrimary, RugoTryExpr, RugoSpawnExpr, RugoParallelExpr, RugoFnExpr, RugoArrayLit, RugoHashLit:
r = p.add(r, p.Expr())
goto state2
}
return p.stop(r, accept, errorSet)
state2:
accept, errorSet = false, 44
switch Symbol(p.tok.Ch) {
	case  RugoTOK_elsif:
r = append(r, p.shift())
goto state1
	case  RugoTOK_else:
r = append(r, p.shift())
goto state3
	case  RugoTOK_end:
r = append(r, p.shift())
goto state4
	case  RugoTOK_bench, RugoTOK_break, RugoTOK_case, RugoTOK_def, RugoTOK_false, RugoTOK_fn, RugoTOK_for, RugoTOK_if, RugoTOK_import, RugoTOK_next, RugoTOK_nil, RugoTOK_parallel, RugoTOK_rats, RugoTOK_require, RugoTOK_return, RugoTOK_sandbox, RugoTOK_spawn, RugoTOK_true, RugoTOK_try, RugoTOK_use, RugoTOK_while, RugoTOK_0021, RugoTOK_0028, RugoTOK_002d, RugoTOK_003b, RugoTOK_005b, RugoTOK_007b, Rugofloat_lit, Rugoident, Rugointeger, Rugoraw_str_lit, Rugostr_lit, RugoStatement, RugoUseStmt, RugoImportStmt, RugoRequireStmt, RugoSandboxStmt, RugoFuncDef, RugoTestDef, RugoBenchDef, RugoIfStmt, RugoCaseExpr, RugoWhileStmt, RugoForStmt, RugoBreakStmt, RugoNextStmt, RugoReturnStmt, RugoAssignOrExpr, RugoExpr, RugoOrExpr, RugoAndExpr, RugoCompExpr, RugoAddExpr, RugoMulExpr, RugoUnaryExpr, RugoPostfix, RugoPrimary, RugoTryExpr, RugoSpawnExpr, RugoParallelExpr, RugoFnExpr, RugoArrayLit, RugoHashLit:
r = p.add(r, p.Body())
goto state6
}
return p.stop(r, accept, errorSet)
state3:
accept, errorSet = false, 41
switch Symbol(p.tok.Ch) {
	case  RugoTOK_end:
r = append(r, p.shift())
goto state4
	case  RugoTOK_bench, RugoTOK_break, RugoTOK_case, RugoTOK_def, RugoTOK_false, RugoTOK_fn, RugoTOK_for, RugoTOK_if, RugoTOK_import, RugoTOK_next, RugoTOK_nil, RugoTOK_parallel, RugoTOK_rats, RugoTOK_require, RugoTOK_return, RugoTOK_sandbox, RugoTOK_spawn, RugoTOK_true, RugoTOK_try, RugoTOK_use, RugoTOK_while, RugoTOK_0021, RugoTOK_0028, RugoTOK_002d, RugoTOK_003b, RugoTOK_005b, RugoTOK_007b, Rugofloat_lit, Rugoident, Rugointeger, Rugoraw_str_lit, Rugostr_lit, RugoStatement, RugoUseStmt, RugoImportStmt, RugoRequireStmt, RugoSandboxStmt, RugoFuncDef, RugoTestDef, RugoBenchDef, RugoIfStmt, RugoCaseExpr, RugoWhileStmt, RugoForStmt, RugoBreakStmt, RugoNextStmt, RugoReturnStmt, RugoAssignOrExpr, RugoExpr, RugoOrExpr, RugoAndExpr, RugoCompExpr, RugoAddExpr, RugoMulExpr, RugoUnaryExpr, RugoPostfix, RugoPrimary, RugoTryExpr, RugoSpawnExpr, RugoParallelExpr, RugoFnExpr, RugoArrayLit, RugoHashLit:
r = p.add(r, p.Body())
goto state5
}
return p.stop(r, accept, errorSet)
state4:
accept, errorSet = true, 0
return p.stop(r, accept, errorSet)
state5:
accept, errorSet = false, 0
switch Symbol(p.tok.Ch) {
	case  RugoTOK_end:
r = append(r, p.shift())
goto state4
}
return p.stop(r, accept, errorSet)
state6:
accept, errorSet = false, 70
switch Symbol(p.tok.Ch) {
	case  RugoTOK_elsif:
r = append(r, p.shift())
goto state1
	case  RugoTOK_else:
r = append(r, p.shift())
goto state3
	case  RugoTOK_end:
r = append(r, p.shift())
goto state4
}
return p.stop(r, accept, errorSet)
}


// ImportStmt grammar:
//
//	
//	ImportStmt  = "import" str_lit [ "as" ident ] .
//
//	State 0
//		on  "import"
//			shift and goto state 1
//	State 1
//		on  str_lit
//			shift and goto state 2
//	State 2
//		Accept
//		on  "as"
//			shift and goto state 3
//	State 3
//		on  ident
//			shift and goto state 4
//	State 4
//		Accept
// ImportStmt is used internally from Parse.
func (p *Parser) ImportStmt() (r []int32) {
		accept, errorSet := false, 0
		r = append(p.get(), -int32(RugoImportStmt), 0)
// state0:
accept, errorSet = false, 4
switch Symbol(p.tok.Ch) {
	case  RugoTOK_import:
r = append(r, p.shift())
goto state1
}
return p.stop(r, accept, errorSet)
state1:
accept, errorSet = false, 49
switch Symbol(p.tok.Ch) {
	case  Rugostr_lit:
r = append(r, p.shift())
goto state2
}
return p.stop(r, accept, errorSet)
state2:
accept, errorSet = true, 40
switch Symbol(p.tok.Ch) {
	case  RugoTOK_as:
r = append(r, p.shift())
goto state3
}
return p.stop(r, accept, errorSet)
state3:
accept, errorSet = false, 47
switch Symbol(p.tok.Ch) {
	case  Rugoident:
r = append(r, p.shift())
goto state4
}
return p.stop(r, accept, errorSet)
state4:
accept, errorSet = true, 0
return p.stop(r, accept, errorSet)
}


// MulExpr grammar:
//
//	
//	MulExpr     = UnaryExpr { ('*' | '/' | '%') UnaryExpr } .
//
//	State 0
//		on  "case", "false", "fn", "nil", "parallel", "spawn", "true", "try", '!', '(', '-', '[', '{', float_lit, ident, integer, raw_str_lit, str_lit, CaseExpr, Postfix, Primary, TryExpr, SpawnExpr, ParallelExpr, FnExpr, ArrayLit, HashLit
//			call UnaryExpr and goto state 1
//	State 1
//		Accept
//		on  '%', '*', '/'
//			shift and goto state 0
// MulExpr is used internally from Parse.
func (p *Parser) MulExpr() (r []int32) {
		accept, errorSet := false, 0
		r = append(p.get(), -int32(RugoMulExpr), 0)
state0:
accept, errorSet = false, 62
switch Symbol(p.tok.Ch) {
	case  RugoTOK_case, RugoTOK_false, RugoTOK_fn, RugoTOK_nil, RugoTOK_parallel, RugoTOK_spawn, RugoTOK_true, RugoTOK_try, RugoTOK_0021, RugoTOK_0028, RugoTOK_002d, RugoTOK_005b, RugoTOK_007b, Rugofloat_lit, Rugoident, Rugointeger, Rugoraw_str_lit, Rugostr_lit, RugoCaseExpr, RugoPostfix, RugoPrimary, RugoTryExpr, RugoSpawnExpr, RugoParallelExpr, RugoFnExpr, RugoArrayLit, RugoHashLit:
r = p.add(r, p.UnaryExpr())
goto state1
}
return p.stop(r, accept, errorSet)
state1:
accept, errorSet = true, 23
switch Symbol(p.tok.Ch) {
	case  RugoTOK_0025, RugoTOK_002a, RugoTOK_002f:
r = append(r, p.shift())
goto state0
}
return p.stop(r, accept, errorSet)
}


// NextStmt grammar:
//
//	
//	NextStmt    = "next" .
//
//	State 0
//		on  "next"
//			shift and goto state 1
//	State 1
//		Accept
// NextStmt is used internally from Parse.
func (p *Parser) NextStmt() (r []int32) {
		accept, errorSet := false, 0
		r = append(p.get(), -int32(RugoNextStmt), 0)
// state0:
accept, errorSet = false, 7
switch Symbol(p.tok.Ch) {
	case  RugoTOK_next:
r = append(r, p.shift())
goto state1
}
return p.stop(r, accept, errorSet)
state1:
accept, errorSet = true, 0
return p.stop(r, accept, errorSet)
}


// OrExpr grammar:
//
//	
//	OrExpr      = AndExpr { "||" AndExpr } .
//
//	State 0
//		on  "case", "false", "fn", "nil", "parallel", "spawn", "true", "try", '!', '(', '-', '[', '{', float_lit, ident, integer, raw_str_lit, str_lit, CaseExpr, CompExpr, AddExpr, MulExpr, UnaryExpr, Postfix, Primary, TryExpr, SpawnExpr, ParallelExpr, FnExpr, ArrayLit, HashLit
//			call AndExpr and goto state 1
//	State 1
//		Accept
//		on  "||"
//			shift and goto state 0
// OrExpr is used internally from Parse.
func (p *Parser) OrExpr() (r []int32) {
		accept, errorSet := false, 0
		r = append(p.get(), -int32(RugoOrExpr), 0)
state0:
accept, errorSet = false, 58
switch Symbol(p.tok.Ch) {
	case  RugoTOK_case, RugoTOK_false, RugoTOK_fn, RugoTOK_nil, RugoTOK_parallel, RugoTOK_spawn, RugoTOK_true, RugoTOK_try, RugoTOK_0021, RugoTOK_0028, RugoTOK_002d, RugoTOK_005b, RugoTOK_007b, Rugofloat_lit, Rugoident, Rugointeger, Rugoraw_str_lit, Rugostr_lit, RugoCaseExpr, RugoCompExpr, RugoAddExpr, RugoMulExpr, RugoUnaryExpr, RugoPostfix, RugoPrimary, RugoTryExpr, RugoSpawnExpr, RugoParallelExpr, RugoFnExpr, RugoArrayLit, RugoHashLit:
r = p.add(r, p.AndExpr())
goto state1
}
return p.stop(r, accept, errorSet)
state1:
accept, errorSet = true, 22
switch Symbol(p.tok.Ch) {
	case  RugoTOK_007c007c:
r = append(r, p.shift())
goto state0
}
return p.stop(r, accept, errorSet)
}


// ParallelExpr grammar:
//
//	
//	ParallelExpr = "parallel" Body "end" .
//
//	State 0
//		on  "parallel"
//			shift and goto state 1
//	State 1
//		on  "end"
//			shift and goto state 2
//		on  "bench", "break", "case", "def", "false", "fn", "for", "if", "import", "next", "nil", "parallel", "rats", "require", "return", "sandbox", "spawn", "true", "try", "use", "while", '!', '(', '-', ';', '[', '{', float_lit, ident, integer, raw_str_lit, str_lit, Statement, UseStmt, ImportStmt, RequireStmt, SandboxStmt, FuncDef, TestDef, BenchDef, IfStmt, CaseExpr, WhileStmt, ForStmt, BreakStmt, NextStmt, ReturnStmt, AssignOrExpr, Expr, OrExpr, AndExpr, CompExpr, AddExpr, MulExpr, UnaryExpr, Postfix, Primary, TryExpr, SpawnExpr, ParallelExpr, FnExpr, ArrayLit, HashLit
//			call Body and goto state 3
//	State 2
//		Accept
//	State 3
//		on  "end"
//			shift and goto state 2
// ParallelExpr is used internally from Parse.
func (p *Parser) ParallelExpr() (r []int32) {
		accept, errorSet := false, 0
		r = append(p.get(), -int32(RugoParallelExpr), 0)
// state0:
accept, errorSet = false, 13
switch Symbol(p.tok.Ch) {
	case  RugoTOK_parallel:
r = append(r, p.shift())
goto state1
}
return p.stop(r, accept, errorSet)
state1:
accept, errorSet = false, 41
switch Symbol(p.tok.Ch) {
	case  RugoTOK_end:
r = append(r, p.shift())
goto state2
	case  RugoTOK_bench, RugoTOK_break, RugoTOK_case, RugoTOK_def, RugoTOK_false, RugoTOK_fn, RugoTOK_for, RugoTOK_if, RugoTOK_import, RugoTOK_next, RugoTOK_nil, RugoTOK_parallel, RugoTOK_rats, RugoTOK_require, RugoTOK_return, RugoTOK_sandbox, RugoTOK_spawn, RugoTOK_true, RugoTOK_try, RugoTOK_use, RugoTOK_while, RugoTOK_0021, RugoTOK_0028, RugoTOK_002d, RugoTOK_003b, RugoTOK_005b, RugoTOK_007b, Rugofloat_lit, Rugoident, Rugointeger, Rugoraw_str_lit, Rugostr_lit, RugoStatement, RugoUseStmt, RugoImportStmt, RugoRequireStmt, RugoSandboxStmt, RugoFuncDef, RugoTestDef, RugoBenchDef, RugoIfStmt, RugoCaseExpr, RugoWhileStmt, RugoForStmt, RugoBreakStmt, RugoNextStmt, RugoReturnStmt, RugoAssignOrExpr, RugoExpr, RugoOrExpr, RugoAndExpr, RugoCompExpr, RugoAddExpr, RugoMulExpr, RugoUnaryExpr, RugoPostfix, RugoPrimary, RugoTryExpr, RugoSpawnExpr, RugoParallelExpr, RugoFnExpr, RugoArrayLit, RugoHashLit:
r = p.add(r, p.Body())
goto state3
}
return p.stop(r, accept, errorSet)
state2:
accept, errorSet = true, 0
return p.stop(r, accept, errorSet)
state3:
accept, errorSet = false, 0
switch Symbol(p.tok.Ch) {
	case  RugoTOK_end:
r = append(r, p.shift())
goto state2
}
return p.stop(r, accept, errorSet)
}


// Param grammar:
//
//	
//	Param       = ident [ '=' Expr ] .
//
//	State 0
//		on  ident
//			shift and goto state 1
//	State 1
//		Accept
//		on  '='
//			shift and goto state 2
//	State 2
//		on  "case", "false", "fn", "nil", "parallel", "spawn", "true", "try", '!', '(', '-', '[', '{', float_lit, ident, integer, raw_str_lit, str_lit, CaseExpr, OrExpr, AndExpr, CompExpr, AddExpr, MulExpr, UnaryExpr, Postfix, Primary, TryExpr, SpawnExpr, ParallelExpr, FnExpr, ArrayLit, HashLit
//			call Expr and goto state 3
//	State 3
//		Accept
// Param is used internally from Parse.
func (p *Parser) Param() (r []int32) {
		accept, errorSet := false, 0
		r = append(p.get(), -int32(RugoParam), 0)
// state0:
accept, errorSet = false, 47
switch Symbol(p.tok.Ch) {
	case  Rugoident:
r = append(r, p.shift())
goto state1
}
return p.stop(r, accept, errorSet)
state1:
accept, errorSet = true, 35
switch Symbol(p.tok.Ch) {
	case  RugoTOK_003d:
r = append(r, p.shift())
goto state2
}
return p.stop(r, accept, errorSet)
state2:
accept, errorSet = false, 56
switch Symbol(p.tok.Ch) {
	case  RugoTOK_case, RugoTOK_false, RugoTOK_fn, RugoTOK_nil, RugoTOK_parallel, RugoTOK_spawn, RugoTOK_true, RugoTOK_try, RugoTOK_0021, RugoTOK_0028, RugoTOK_002d, RugoTOK_005b, RugoTOK_007b, Rugofloat_lit, Rugoident, Rugointeger, Rugoraw_str_lit, Rugostr_lit, RugoCaseExpr, RugoOrExpr, RugoAndExpr, RugoCompExpr, RugoAddExpr, RugoMulExpr, RugoUnaryExpr, RugoPostfix, RugoPrimary, RugoTryExpr, RugoSpawnExpr, RugoParallelExpr, RugoFnExpr, RugoArrayLit, RugoHashLit:
r = p.add(r, p.Expr())
goto state3
}
return p.stop(r, accept, errorSet)
state3:
accept, errorSet = true, 0
return p.stop(r, accept, errorSet)
}


// ParamList grammar:
//
//	
//	ParamList   = Param { ',' Param } .
//
//	State 0
//		on  ident
//			call Param and goto state 1
//	State 1
//		Accept
//		on  ','
//			shift and goto state 0
// ParamList is used internally from Parse.
func (p *Parser) ParamList() (r []int32) {
		accept, errorSet := false, 0
		r = append(p.get(), -int32(RugoParamList), 0)
state0:
accept, errorSet = false, 47
switch Symbol(p.tok.Ch) {
	case  Rugoident:
r = p.add(r, p.Param())
goto state1
}
return p.stop(r, accept, errorSet)
state1:
accept, errorSet = true, 33
switch Symbol(p.tok.Ch) {
	case  RugoTOK_002c:
r = append(r, p.shift())
goto state0
}
return p.stop(r, accept, errorSet)
}


// Postfix grammar:
//
//	
//	Postfix     = Primary { Suffix } .
//
//	State 0
//		on  "case", "false", "fn", "nil", "parallel", "spawn", "true", "try", '(', '[', '{', float_lit, ident, integer, raw_str_lit, str_lit, CaseExpr, TryExpr, SpawnExpr, ParallelExpr, FnExpr, ArrayLit, HashLit
//			call Primary and goto state 1
//	State 1
//		Accept
//		on  '(', '.', '['
//			call Suffix and goto state 1
// Postfix is used internally from Parse.
func (p *Parser) Postfix() (r []int32) {
		accept, errorSet := false, 0
		r = append(p.get(), -int32(RugoPostfix), 0)
// state0:
accept, errorSet = false, 65
switch Symbol(p.tok.Ch) {
	case  RugoTOK_case, RugoTOK_false, RugoTOK_fn, RugoTOK_nil, RugoTOK_parallel, RugoTOK_spawn, RugoTOK_true, RugoTOK_try, RugoTOK_0028, RugoTOK_005b, RugoTOK_007b, Rugofloat_lit, Rugoident, Rugointeger, Rugoraw_str_lit, Rugostr_lit, RugoCaseExpr, RugoTryExpr, RugoSpawnExpr, RugoParallelExpr, RugoFnExpr, RugoArrayLit, RugoHashLit:
r = p.add(r, p.Primary())
goto state1
}
return p.stop(r, accept, errorSet)
state1:
accept, errorSet = true, 24
switch Symbol(p.tok.Ch) {
	case  RugoTOK_0028, RugoTOK_002e, RugoTOK_005b:
r = p.add(r, p.Suffix())
goto state1
}
return p.stop(r, accept, errorSet)
}


// Primary grammar:
//
//	
//	
//	# Primary expressions
//	Primary     = ident
//	            | integer
//	            | float_lit
//	            | str_lit
//	            | raw_str_lit
//	            | "true"
//	            | "false"
//	            | "nil"
//	            | ArrayLit
//	            | HashLit
//	            | CaseExpr
//	            | TryExpr
//	            | SpawnExpr
//	            | ParallelExpr
//	            | FnExpr
//	            | '(' Expr ')' .
//
//	State 0
//		on  "false", "nil", "true", float_lit, ident, integer, raw_str_lit, str_lit
//			shift and goto state 1
//		on  '('
//			shift and goto state 2
//		on  "case"
//			call CaseExpr and goto state 1
//		on  "try"
//			call TryExpr and goto state 1
//		on  "spawn"
//			call SpawnExpr and goto state 1
//		on  "parallel"
//			call ParallelExpr and goto state 1
//		on  "fn"
//			call FnExpr and goto state 1
//		on  '['
//			call ArrayLit and goto state 1
//		on  '{'
//			call HashLit and goto state 1
//	State 1
//		Accept
//	State 2
//		on  "case", "false", "fn", "nil", "parallel", "spawn", "true", "try", '!', '(', '-', '[', '{', float_lit, ident, integer, raw_str_lit, str_lit, CaseExpr, OrExpr, AndExpr, CompExpr, AddExpr, MulExpr, UnaryExpr, Postfix, Primary, TryExpr, SpawnExpr, ParallelExpr, FnExpr, ArrayLit, HashLit
//			call Expr and goto state 3
//	State 3
//		on  ')'
//			shift and goto state 1
// Primary is used internally from Parse.
func (p *Parser) Primary() (r []int32) {
		accept, errorSet := false, 0
		r = append(p.get(), -int32(RugoPrimary), 0)
// state0:
accept, errorSet = false, 66
switch Symbol(p.tok.Ch) {
	case  RugoTOK_false, RugoTOK_nil, RugoTOK_true, Rugofloat_lit, Rugoident, Rugointeger, Rugoraw_str_lit, Rugostr_lit:
r = append(r, p.shift())
goto state1
	case  RugoTOK_0028:
r = append(r, p.shift())
goto state2
	case  RugoTOK_case:
r = p.add(r, p.CaseExpr())
goto state1
	case  RugoTOK_try:
r = p.add(r, p.TryExpr())
goto state1
	case  RugoTOK_spawn:
r = p.add(r, p.SpawnExpr())
goto state1
	case  RugoTOK_parallel:
r = p.add(r, p.ParallelExpr())
goto state1
	case  RugoTOK_fn:
r = p.add(r, p.FnExpr())
goto state1
	case  RugoTOK_005b:
r = p.add(r, p.ArrayLit())
goto state1
	case  RugoTOK_007b:
r = p.add(r, p.HashLit())
goto state1
}
return p.stop(r, accept, errorSet)
state1:
accept, errorSet = true, 0
return p.stop(r, accept, errorSet)
state2:
accept, errorSet = false, 56
switch Symbol(p.tok.Ch) {
	case  RugoTOK_case, RugoTOK_false, RugoTOK_fn, RugoTOK_nil, RugoTOK_parallel, RugoTOK_spawn, RugoTOK_true, RugoTOK_try, RugoTOK_0021, RugoTOK_0028, RugoTOK_002d, RugoTOK_005b, RugoTOK_007b, Rugofloat_lit, Rugoident, Rugointeger, Rugoraw_str_lit, Rugostr_lit, RugoCaseExpr, RugoOrExpr, RugoAndExpr, RugoCompExpr, RugoAddExpr, RugoMulExpr, RugoUnaryExpr, RugoPostfix, RugoPrimary, RugoTryExpr, RugoSpawnExpr, RugoParallelExpr, RugoFnExpr, RugoArrayLit, RugoHashLit:
r = p.add(r, p.Expr())
goto state3
}
return p.stop(r, accept, errorSet)
state3:
accept, errorSet = false, 27
switch Symbol(p.tok.Ch) {
	case  RugoTOK_0029:
r = append(r, p.shift())
goto state1
}
return p.stop(r, accept, errorSet)
}


// Program grammar:
//
//	# Rugo Language Grammar (LL(1))
//	# A minimal Ruby-inspired language that transpiles to Go.
//	
//	# Entry point
//	# ';' is a statement separator injected by the preprocessor to disambiguate
//	# array literals on new lines from index suffix operations (e.g. expr\n[1,2,3]).
//	# Users should not write ';' directly  the preprocessor rejects it.
//	Program     = { Statement | ';' } .
//
//	State 0
//		Accept
//		on  ';'
//			shift and goto state 1
//		on  "bench", "break", "case", "def", "false", "fn", "for", "if", "import", "next", "nil", "parallel", "rats", "require", "return", "sandbox", "spawn", "true", "try", "use", "while", '!', '(', '-', '[', '{', float_lit, ident, integer, raw_str_lit, str_lit, UseStmt, ImportStmt, RequireStmt, SandboxStmt, FuncDef, TestDef, BenchDef, IfStmt, CaseExpr, WhileStmt, ForStmt, BreakStmt, NextStmt, ReturnStmt, AssignOrExpr, Expr, OrExpr, AndExpr, CompExpr, AddExpr, MulExpr, UnaryExpr, Postfix, Primary, TryExpr, SpawnExpr, ParallelExpr, FnExpr, ArrayLit, HashLit
//			call Statement and goto state 1
//	State 1
//		Accept
//		on  ';'
//			shift and goto state 1
//		on  "bench", "break", "case", "def", "false", "fn", "for", "if", "import", "next", "nil", "parallel", "rats", "require", "return", "sandbox", "spawn", "true", "try", "use", "while", '!', '(', '-', '[', '{', float_lit, ident, integer, raw_str_lit, str_lit, UseStmt, ImportStmt, RequireStmt, SandboxStmt, FuncDef, TestDef, BenchDef, IfStmt, CaseExpr, WhileStmt, ForStmt, BreakStmt, NextStmt, ReturnStmt, AssignOrExpr, Expr, OrExpr, AndExpr, CompExpr, AddExpr, MulExpr, UnaryExpr, Postfix, Primary, TryExpr, SpawnExpr, ParallelExpr, FnExpr, ArrayLit, HashLit
//			call Statement and goto state 1
// Program is used internally from Parse.
func (p *Parser) Program() (r []int32) {
		accept, errorSet := false, 0
		r = append(p.get(), -int32(RugoProgram), 0)
// state0:
accept, errorSet = true, 42
switch Symbol(p.tok.Ch) {
	case  RugoTOK_003b:
r = append(r, p.shift())
goto state1
	case  RugoTOK_bench, RugoTOK_break, RugoTOK_case, RugoTOK_def, RugoTOK_false, RugoTOK_fn, RugoTOK_for, RugoTOK_if, RugoTOK_import, RugoTOK_next, RugoTOK_nil, RugoTOK_parallel, RugoTOK_rats, RugoTOK_require, RugoTOK_return, RugoTOK_sandbox, RugoTOK_spawn, RugoTOK_true, RugoTOK_try, RugoTOK_use, RugoTOK_while, RugoTOK_0021, RugoTOK_0028, RugoTOK_002d, RugoTOK_005b, RugoTOK_007b, Rugofloat_lit, Rugoident, Rugointeger, Rugoraw_str_lit, Rugostr_lit, RugoUseStmt, RugoImportStmt, RugoRequireStmt, RugoSandboxStmt, RugoFuncDef, RugoTestDef, RugoBenchDef, RugoIfStmt, RugoCaseExpr, RugoWhileStmt, RugoForStmt, RugoBreakStmt, RugoNextStmt, RugoReturnStmt, RugoAssignOrExpr, RugoExpr, RugoOrExpr, RugoAndExpr, RugoCompExpr, RugoAddExpr, RugoMulExpr, RugoUnaryExpr, RugoPostfix, RugoPrimary, RugoTryExpr, RugoSpawnExpr, RugoParallelExpr, RugoFnExpr, RugoArrayLit, RugoHashLit:
r = p.add(r, p.Statement())
goto state1
}
return p.stop(r, accept, errorSet)
state1:
accept, errorSet = true, 42
switch Symbol(p.tok.Ch) {
	case  RugoTOK_003b:
r = append(r, p.shift())
goto state1
	case  RugoTOK_bench, RugoTOK_break, RugoTOK_case, RugoTOK_def, RugoTOK_false, RugoTOK_fn, RugoTOK_for, RugoTOK_if, RugoTOK_import, RugoTOK_next, RugoTOK_nil, RugoTOK_parallel, RugoTOK_rats, RugoTOK_require, RugoTOK_return, RugoTOK_sandbox, RugoTOK_spawn, RugoTOK_true, RugoTOK_try, RugoTOK_use, RugoTOK_while, RugoTOK_0021, RugoTOK_0028, RugoTOK_002d, RugoTOK_005b, RugoTOK_007b, Rugofloat_lit, Rugoident, Rugointeger, Rugoraw_str_lit, Rugostr_lit, RugoUseStmt, RugoImportStmt, RugoRequireStmt, RugoSandboxStmt, RugoFuncDef, RugoTestDef, RugoBenchDef, RugoIfStmt, RugoCaseExpr, RugoWhileStmt, RugoForStmt, RugoBreakStmt, RugoNextStmt, RugoReturnStmt, RugoAssignOrExpr, RugoExpr, RugoOrExpr, RugoAndExpr, RugoCompExpr, RugoAddExpr, RugoMulExpr, RugoUnaryExpr, RugoPostfix, RugoPrimary, RugoTryExpr, RugoSpawnExpr, RugoParallelExpr, RugoFnExpr, RugoArrayLit, RugoHashLit:
r = p.add(r, p.Statement())
goto state1
}
	if accept = accept && p.eof; accept {
 			r = append(r, p.shift())
 		}
 	r[1] = int32(len(r)-2)
 	if !accept {
 	p.err(p.tok.Position(), "%q [%s]: expected %v", p.tok.Src(), Symbol(p.tok.Ch), errorSets[errorSet])
 }
return r
}


// RequireStmt grammar:
//
//	
//	RequireStmt = "require" str_lit [ "as" ( str_lit | ident ) | "with" ident { ',' ident } ] .
//
//	State 0
//		on  "require"
//			shift and goto state 1
//	State 1
//		on  str_lit
//			shift and goto state 2
//	State 2
//		Accept
//		on  "as"
//			shift and goto state 3
//		on  "with"
//			shift and goto state 5
//	State 3
//		on  ident, str_lit
//			shift and goto state 4
//	State 4
//		Accept
//	State 5
//		on  ident
//			shift and goto state 6
//	State 6
//		Accept
//		on  ','
//			shift and goto state 5
// RequireStmt is used internally from Parse.
func (p *Parser) RequireStmt() (r []int32) {
		accept, errorSet := false, 0
		r = append(p.get(), -int32(RugoRequireStmt), 0)
// state0:
accept, errorSet = false, 15
switch Symbol(p.tok.Ch) {
	case  RugoTOK_require:
r = append(r, p.shift())
goto state1
}
return p.stop(r, accept, errorSet)
state1:
accept, errorSet = false, 49
switch Symbol(p.tok.Ch) {
	case  Rugostr_lit:
r = append(r, p.shift())
goto state2
}
return p.stop(r, accept, errorSet)
state2:
accept, errorSet = true, 30
switch Symbol(p.tok.Ch) {
	case  RugoTOK_as:
r = append(r, p.shift())
goto state3
	case  RugoTOK_with:
r = append(r, p.shift())
goto state5
}
return p.stop(r, accept, errorSet)
state3:
accept, errorSet = false, 46
switch Symbol(p.tok.Ch) {
	case  Rugoident, Rugostr_lit:
r = append(r, p.shift())
goto state4
}
return p.stop(r, accept, errorSet)
state4:
accept, errorSet = true, 0
return p.stop(r, accept, errorSet)
state5:
accept, errorSet = false, 47
switch Symbol(p.tok.Ch) {
	case  Rugoident:
r = append(r, p.shift())
goto state6
}
return p.stop(r, accept, errorSet)
state6:
accept, errorSet = true, 33
switch Symbol(p.tok.Ch) {
	case  RugoTOK_002c:
r = append(r, p.shift())
goto state5
}
return p.stop(r, accept, errorSet)
}


// ReturnStmt grammar:
//
//	
//	ReturnStmt  = "return" [ Expr ] .
//
//	State 0
//		on  "return"
//			shift and goto state 1
//	State 1
//		Accept
//		on  "case", "false", "fn", "nil", "parallel", "spawn", "true", "try", '!', '(', '-', '[', '{', float_lit, ident, integer, raw_str_lit, str_lit, CaseExpr, OrExpr, AndExpr, CompExpr, AddExpr, MulExpr, UnaryExpr, Postfix, Primary, TryExpr, SpawnExpr, ParallelExpr, FnExpr, ArrayLit, HashLit
//			call Expr and goto state 2
//	State 2
//		Accept
// ReturnStmt is used internally from Parse.
func (p *Parser) ReturnStmt() (r []int32) {
		accept, errorSet := false, 0
		r = append(p.get(), -int32(RugoReturnStmt), 0)
// state0:
accept, errorSet = false, 16
switch Symbol(p.tok.Ch) {
	case  RugoTOK_return:
r = append(r, p.shift())
goto state1
}
return p.stop(r, accept, errorSet)
state1:
accept, errorSet = true, 56
switch Symbol(p.tok.Ch) {
	case  RugoTOK_case, RugoTOK_false, RugoTOK_fn, RugoTOK_nil, RugoTOK_parallel, RugoTOK_spawn, RugoTOK_true, RugoTOK_try, RugoTOK_0021, RugoTOK_0028, RugoTOK_002d, RugoTOK_005b, RugoTOK_007b, Rugofloat_lit, Rugoident, Rugointeger, Rugoraw_str_lit, Rugostr_lit, RugoCaseExpr, RugoOrExpr, RugoAndExpr, RugoCompExpr, RugoAddExpr, RugoMulExpr, RugoUnaryExpr, RugoPostfix, RugoPrimary, RugoTryExpr, RugoSpawnExpr, RugoParallelExpr, RugoFnExpr, RugoArrayLit, RugoHashLit:
r = p.add(r, p.Expr())
goto state2
}
return p.stop(r, accept, errorSet)
state2:
accept, errorSet = true, 0
return p.stop(r, accept, errorSet)
}


// SandboxList grammar:
//
//	
//	SandboxList = '[' ( str_lit | integer ) { ',' ( str_lit | integer ) } ']' .
//
//	State 0
//		on  '['
//			shift and goto state 1
//	State 1
//		on  integer, str_lit
//			shift and goto state 2
//	State 2
//		on  ','
//			shift and goto state 1
//		on  ']'
//			shift and goto state 3
//	State 3
//		Accept
// SandboxList is used internally from Parse.
func (p *Parser) SandboxList() (r []int32) {
		accept, errorSet := false, 0
		r = append(p.get(), -int32(RugoSandboxList), 0)
// state0:
accept, errorSet = false, 37
switch Symbol(p.tok.Ch) {
	case  RugoTOK_005b:
r = append(r, p.shift())
goto state1
}
return p.stop(r, accept, errorSet)
state1:
accept, errorSet = false, 48
switch Symbol(p.tok.Ch) {
	case  Rugointeger, Rugostr_lit:
r = append(r, p.shift())
goto state2
}
return p.stop(r, accept, errorSet)
state2:
accept, errorSet = false, 31
switch Symbol(p.tok.Ch) {
	case  RugoTOK_002c:
r = append(r, p.shift())
goto state1
	case  RugoTOK_005d:
r = append(r, p.shift())
goto state3
}
return p.stop(r, accept, errorSet)
state3:
accept, errorSet = true, 0
return p.stop(r, accept, errorSet)
}


// SandboxPerm grammar:
//
//	
//	SandboxPerm = ident ':' ( str_lit | integer | SandboxList ) .
//
//	State 0
//		on  ident
//			shift and goto state 1
//	State 1
//		on  ':'
//			shift and goto state 2
//	State 2
//		on  integer, str_lit
//			shift and goto state 3
//		on  '['
//			call SandboxList and goto state 3
//	State 3
//		Accept
// SandboxPerm is used internally from Parse.
func (p *Parser) SandboxPerm() (r []int32) {
		accept, errorSet := false, 0
		r = append(p.get(), -int32(RugoSandboxPerm), 0)
// state0:
accept, errorSet = false, 47
switch Symbol(p.tok.Ch) {
	case  Rugoident:
r = append(r, p.shift())
goto state1
}
return p.stop(r, accept, errorSet)
state1:
accept, errorSet = false, 34
switch Symbol(p.tok.Ch) {
	case  RugoTOK_003a:
r = append(r, p.shift())
goto state2
}
return p.stop(r, accept, errorSet)
state2:
accept, errorSet = false, 36
switch Symbol(p.tok.Ch) {
	case  Rugointeger, Rugostr_lit:
r = append(r, p.shift())
goto state3
	case  RugoTOK_005b:
r = p.add(r, p.SandboxList())
goto state3
}
return p.stop(r, accept, errorSet)
state3:
accept, errorSet = true, 0
return p.stop(r, accept, errorSet)
}


// SandboxStmt grammar:
//
//	
//	SandboxStmt = "sandbox" [ SandboxPerm { ',' SandboxPerm } ] .
//
//	State 0
//		on  "sandbox"
//			shift and goto state 1
//	State 1
//		Accept
//		on  ident
//			call SandboxPerm and goto state 2
//	State 2
//		Accept
//		on  ','
//			shift and goto state 3
//	State 3
//		on  ident
//			call SandboxPerm and goto state 2
// SandboxStmt is used internally from Parse.
func (p *Parser) SandboxStmt() (r []int32) {
		accept, errorSet := false, 0
		r = append(p.get(), -int32(RugoSandboxStmt), 0)
// state0:
accept, errorSet = false, 17
switch Symbol(p.tok.Ch) {
	case  RugoTOK_sandbox:
r = append(r, p.shift())
goto state1
}
return p.stop(r, accept, errorSet)
state1:
accept, errorSet = true, 47
switch Symbol(p.tok.Ch) {
	case  Rugoident:
r = p.add(r, p.SandboxPerm())
goto state2
}
return p.stop(r, accept, errorSet)
state2:
accept, errorSet = true, 33
switch Symbol(p.tok.Ch) {
	case  RugoTOK_002c:
r = append(r, p.shift())
goto state3
}
return p.stop(r, accept, errorSet)
state3:
accept, errorSet = false, 47
switch Symbol(p.tok.Ch) {
	case  Rugoident:
r = p.add(r, p.SandboxPerm())
goto state2
}
return p.stop(r, accept, errorSet)
}


// SpawnExpr grammar:
//
//	
//	SpawnExpr    = "spawn" Body "end" .
//
//	State 0
//		on  "spawn"
//			shift and goto state 1
//	State 1
//		on  "end"
//			shift and goto state 2
//		on  "bench", "break", "case", "def", "false", "fn", "for", "if", "import", "next", "nil", "parallel", "rats", "require", "return", "sandbox", "spawn", "true", "try", "use", "while", '!', '(', '-', ';', '[', '{', float_lit, ident, integer, raw_str_lit, str_lit, Statement, UseStmt, ImportStmt, RequireStmt, SandboxStmt, FuncDef, TestDef, BenchDef, IfStmt, CaseExpr, WhileStmt, ForStmt, BreakStmt, NextStmt, ReturnStmt, AssignOrExpr, Expr, OrExpr, AndExpr, CompExpr, AddExpr, MulExpr, UnaryExpr, Postfix, Primary, TryExpr, SpawnExpr, ParallelExpr, FnExpr, ArrayLit, HashLit
//			call Body and goto state 3
//	State 2
//		Accept
//	State 3
//		on  "end"
//			shift and goto state 2
// SpawnExpr is used internally from Parse.
func (p *Parser) SpawnExpr() (r []int32) {
		accept, errorSet := false, 0
		r = append(p.get(), -int32(RugoSpawnExpr), 0)
// state0:
accept, errorSet = false, 18
switch Symbol(p.tok.Ch) {
	case  RugoTOK_spawn:
r = append(r, p.shift())
goto state1
}
return p.stop(r, accept, errorSet)
state1:
accept, errorSet = false, 41
switch Symbol(p.tok.Ch) {
	case  RugoTOK_end:
r = append(r, p.shift())
goto state2
	case  RugoTOK_bench, RugoTOK_break, RugoTOK_case, RugoTOK_def, RugoTOK_false, RugoTOK_fn, RugoTOK_for, RugoTOK_if, RugoTOK_import, RugoTOK_next, RugoTOK_nil, RugoTOK_parallel, RugoTOK_rats, RugoTOK_require, RugoTOK_return, RugoTOK_sandbox, RugoTOK_spawn, RugoTOK_true, RugoTOK_try, RugoTOK_use, RugoTOK_while, RugoTOK_0021, RugoTOK_0028, RugoTOK_002d, RugoTOK_003b, RugoTOK_005b, RugoTOK_007b, Rugofloat_lit, Rugoident, Rugointeger, Rugoraw_str_lit, Rugostr_lit, RugoStatement, RugoUseStmt, RugoImportStmt, RugoRequireStmt, RugoSandboxStmt, RugoFuncDef, RugoTestDef, RugoBenchDef, RugoIfStmt, RugoCaseExpr, RugoWhileStmt, RugoForStmt, RugoBreakStmt, RugoNextStmt, RugoReturnStmt, RugoAssignOrExpr, RugoExpr, RugoOrExpr, RugoAndExpr, RugoCompExpr, RugoAddExpr, RugoMulExpr, RugoUnaryExpr, RugoPostfix, RugoPrimary, RugoTryExpr, RugoSpawnExpr, RugoParallelExpr, RugoFnExpr, RugoArrayLit, RugoHashLit:
r = p.add(r, p.Body())
goto state3
}
return p.stop(r, accept, errorSet)
state2:
accept, errorSet = true, 0
return p.stop(r, accept, errorSet)
state3:
accept, errorSet = false, 0
switch Symbol(p.tok.Ch) {
	case  RugoTOK_end:
r = append(r, p.shift())
goto state2
}
return p.stop(r, accept, errorSet)
}


// Statement grammar:
//
//	
//	
//	# Statements
//	Statement   = UseStmt
//	            | ImportStmt
//	            | RequireStmt
//	            | SandboxStmt
//	            | FuncDef
//	            | TestDef
//	            | BenchDef
//	            | IfStmt
//	            | WhileStmt
//	            | ForStmt
//	            | BreakStmt
//	            | NextStmt
//	            | ReturnStmt
//	            | AssignOrExpr .
//
//	State 0
//		on  "use"
//			call UseStmt and goto state 1
//		on  "import"
//			call ImportStmt and goto state 1
//		on  "require"
//			call RequireStmt and goto state 1
//		on  "sandbox"
//			call SandboxStmt and goto state 1
//		on  "def"
//			call FuncDef and goto state 1
//		on  "rats"
//			call TestDef and goto state 1
//		on  "bench"
//			call BenchDef and goto state 1
//		on  "if"
//			call IfStmt and goto state 1
//		on  "while"
//			call WhileStmt and goto state 1
//		on  "for"
//			call ForStmt and goto state 1
//		on  "break"
//			call BreakStmt and goto state 1
//		on  "next"
//			call NextStmt and goto state 1
//		on  "return"
//			call ReturnStmt and goto state 1
//		on  "case", "false", "fn", "nil", "parallel", "spawn", "true", "try", '!', '(', '-', '[', '{', float_lit, ident, integer, raw_str_lit, str_lit, CaseExpr, Expr, OrExpr, AndExpr, CompExpr, AddExpr, MulExpr, UnaryExpr, Postfix, Primary, TryExpr, SpawnExpr, ParallelExpr, FnExpr, ArrayLit, HashLit
//			call AssignOrExpr and goto state 1
//	State 1
//		Accept
// Statement is used internally from Parse.
func (p *Parser) Statement() (r []int32) {
		accept, errorSet := false, 0
		r = append(p.get(), -int32(RugoStatement), 0)
// state0:
accept, errorSet = false, 43
switch Symbol(p.tok.Ch) {
	case  RugoTOK_use:
r = p.add(r, p.UseStmt())
goto state1
	case  RugoTOK_import:
r = p.add(r, p.ImportStmt())
goto state1
	case  RugoTOK_require:
r = p.add(r, p.RequireStmt())
goto state1
	case  RugoTOK_sandbox:
r = p.add(r, p.SandboxStmt())
goto state1
	case  RugoTOK_def:
r = p.add(r, p.FuncDef())
goto state1
	case  RugoTOK_rats:
r = p.add(r, p.TestDef())
goto state1
	case  RugoTOK_bench:
r = p.add(r, p.BenchDef())
goto state1
	case  RugoTOK_if:
r = p.add(r, p.IfStmt())
goto state1
	case  RugoTOK_while:
r = p.add(r, p.WhileStmt())
goto state1
	case  RugoTOK_for:
r = p.add(r, p.ForStmt())
goto state1
	case  RugoTOK_break:
r = p.add(r, p.BreakStmt())
goto state1
	case  RugoTOK_next:
r = p.add(r, p.NextStmt())
goto state1
	case  RugoTOK_return:
r = p.add(r, p.ReturnStmt())
goto state1
	case  RugoTOK_case, RugoTOK_false, RugoTOK_fn, RugoTOK_nil, RugoTOK_parallel, RugoTOK_spawn, RugoTOK_true, RugoTOK_try, RugoTOK_0021, RugoTOK_0028, RugoTOK_002d, RugoTOK_005b, RugoTOK_007b, Rugofloat_lit, Rugoident, Rugointeger, Rugoraw_str_lit, Rugostr_lit, RugoCaseExpr, RugoExpr, RugoOrExpr, RugoAndExpr, RugoCompExpr, RugoAddExpr, RugoMulExpr, RugoUnaryExpr, RugoPostfix, RugoPrimary, RugoTryExpr, RugoSpawnExpr, RugoParallelExpr, RugoFnExpr, RugoArrayLit, RugoHashLit:
r = p.add(r, p.AssignOrExpr())
goto state1
}
return p.stop(r, accept, errorSet)
state1:
accept, errorSet = true, 0
return p.stop(r, accept, errorSet)
}


// Suffix grammar:
//
//	
//	Suffix      = '(' [ ArgList ] ')' | '[' Expr [ ',' Expr ] ']' | '.' ident .
//
//	State 0
//		on  '('
//			shift and goto state 1
//		on  '.'
//			shift and goto state 4
//		on  '['
//			shift and goto state 5
//	State 1
//		on  ')'
//			shift and goto state 2
//		on  "case", "false", "fn", "nil", "parallel", "spawn", "true", "try", '!', '(', '-', '[', '{', float_lit, ident, integer, raw_str_lit, str_lit, CaseExpr, Expr, OrExpr, AndExpr, CompExpr, AddExpr, MulExpr, UnaryExpr, Postfix, Primary, TryExpr, SpawnExpr, ParallelExpr, FnExpr, ArrayLit, HashLit
//			call ArgList and goto state 3
//	State 2
//		Accept
//	State 3
//		on  ')'
//			shift and goto state 2
//	State 4
//		on  ident
//			shift and goto state 2
//	State 5
//		on  "case", "false", "fn", "nil", "parallel", "spawn", "true", "try", '!', '(', '-', '[', '{', float_lit, ident, integer, raw_str_lit, str_lit, CaseExpr, OrExpr, AndExpr, CompExpr, AddExpr, MulExpr, UnaryExpr, Postfix, Primary, TryExpr, SpawnExpr, ParallelExpr, FnExpr, ArrayLit, HashLit
//			call Expr and goto state 6
//	State 6
//		on  ']'
//			shift and goto state 2
//		on  ','
//			shift and goto state 7
//	State 7
//		on  "case", "false", "fn", "nil", "parallel", "spawn", "true", "try", '!', '(', '-', '[', '{', float_lit, ident, integer, raw_str_lit, str_lit, CaseExpr, OrExpr, AndExpr, CompExpr, AddExpr, MulExpr, UnaryExpr, Postfix, Primary, TryExpr, SpawnExpr, ParallelExpr, FnExpr, ArrayLit, HashLit
//			call Expr and goto state 8
//	State 8
//		on  ']'
//			shift and goto state 2
// Suffix is used internally from Parse.
func (p *Parser) Suffix() (r []int32) {
		accept, errorSet := false, 0
		r = append(p.get(), -int32(RugoSuffix), 0)
// state0:
accept, errorSet = false, 24
switch Symbol(p.tok.Ch) {
	case  RugoTOK_0028:
r = append(r, p.shift())
goto state1
	case  RugoTOK_002e:
r = append(r, p.shift())
goto state4
	case  RugoTOK_005b:
r = append(r, p.shift())
goto state5
}
return p.stop(r, accept, errorSet)
state1:
accept, errorSet = false, 52
switch Symbol(p.tok.Ch) {
	case  RugoTOK_0029:
r = append(r, p.shift())
goto state2
	case  RugoTOK_case, RugoTOK_false, RugoTOK_fn, RugoTOK_nil, RugoTOK_parallel, RugoTOK_spawn, RugoTOK_true, RugoTOK_try, RugoTOK_0021, RugoTOK_0028, RugoTOK_002d, RugoTOK_005b, RugoTOK_007b, Rugofloat_lit, Rugoident, Rugointeger, Rugoraw_str_lit, Rugostr_lit, RugoCaseExpr, RugoExpr, RugoOrExpr, RugoAndExpr, RugoCompExpr, RugoAddExpr, RugoMulExpr, RugoUnaryExpr, RugoPostfix, RugoPrimary, RugoTryExpr, RugoSpawnExpr, RugoParallelExpr, RugoFnExpr, RugoArrayLit, RugoHashLit:
r = p.add(r, p.ArgList())
goto state3
}
return p.stop(r, accept, errorSet)
state2:
accept, errorSet = true, 0
return p.stop(r, accept, errorSet)
state3:
accept, errorSet = false, 27
switch Symbol(p.tok.Ch) {
	case  RugoTOK_0029:
r = append(r, p.shift())
goto state2
}
return p.stop(r, accept, errorSet)
state4:
accept, errorSet = false, 47
switch Symbol(p.tok.Ch) {
	case  Rugoident:
r = append(r, p.shift())
goto state2
}
return p.stop(r, accept, errorSet)
state5:
accept, errorSet = false, 56
switch Symbol(p.tok.Ch) {
	case  RugoTOK_case, RugoTOK_false, RugoTOK_fn, RugoTOK_nil, RugoTOK_parallel, RugoTOK_spawn, RugoTOK_true, RugoTOK_try, RugoTOK_0021, RugoTOK_0028, RugoTOK_002d, RugoTOK_005b, RugoTOK_007b, Rugofloat_lit, Rugoident, Rugointeger, Rugoraw_str_lit, Rugostr_lit, RugoCaseExpr, RugoOrExpr, RugoAndExpr, RugoCompExpr, RugoAddExpr, RugoMulExpr, RugoUnaryExpr, RugoPostfix, RugoPrimary, RugoTryExpr, RugoSpawnExpr, RugoParallelExpr, RugoFnExpr, RugoArrayLit, RugoHashLit:
r = p.add(r, p.Expr())
goto state6
}
return p.stop(r, accept, errorSet)
state6:
accept, errorSet = false, 31
switch Symbol(p.tok.Ch) {
	case  RugoTOK_005d:
r = append(r, p.shift())
goto state2
	case  RugoTOK_002c:
r = append(r, p.shift())
goto state7
}
return p.stop(r, accept, errorSet)
state7:
accept, errorSet = false, 56
switch Symbol(p.tok.Ch) {
	case  RugoTOK_case, RugoTOK_false, RugoTOK_fn, RugoTOK_nil, RugoTOK_parallel, RugoTOK_spawn, RugoTOK_true, RugoTOK_try, RugoTOK_0021, RugoTOK_0028, RugoTOK_002d, RugoTOK_005b, RugoTOK_007b, Rugofloat_lit, Rugoident, Rugointeger, Rugoraw_str_lit, Rugostr_lit, RugoCaseExpr, RugoOrExpr, RugoAndExpr, RugoCompExpr, RugoAddExpr, RugoMulExpr, RugoUnaryExpr, RugoPostfix, RugoPrimary, RugoTryExpr, RugoSpawnExpr, RugoParallelExpr, RugoFnExpr, RugoArrayLit, RugoHashLit:
r = p.add(r, p.Expr())
goto state8
}
return p.stop(r, accept, errorSet)
state8:
accept, errorSet = false, 38
switch Symbol(p.tok.Ch) {
	case  RugoTOK_005d:
r = append(r, p.shift())
goto state2
}
return p.stop(r, accept, errorSet)
}


// TestDef grammar:
//
//	
//	TestDef     = "rats" str_lit Body "end" .
//
//	State 0
//		on  "rats"
//			shift and goto state 1
//	State 1
//		on  str_lit
//			shift and goto state 2
//	State 2
//		on  "end"
//			shift and goto state 3
//		on  "bench", "break", "case", "def", "false", "fn", "for", "if", "import", "next", "nil", "parallel", "rats", "require", "return", "sandbox", "spawn", "true", "try", "use", "while", '!', '(', '-', ';', '[', '{', float_lit, ident, integer, raw_str_lit, str_lit, Statement, UseStmt, ImportStmt, RequireStmt, SandboxStmt, FuncDef, TestDef, BenchDef, IfStmt, CaseExpr, WhileStmt, ForStmt, BreakStmt, NextStmt, ReturnStmt, AssignOrExpr, Expr, OrExpr, AndExpr, CompExpr, AddExpr, MulExpr, UnaryExpr, Postfix, Primary, TryExpr, SpawnExpr, ParallelExpr, FnExpr, ArrayLit, HashLit
//			call Body and goto state 4
//	State 3
//		Accept
//	State 4
//		on  "end"
//			shift and goto state 3
// TestDef is used internally from Parse.
func (p *Parser) TestDef() (r []int32) {
		accept, errorSet := false, 0
		r = append(p.get(), -int32(RugoTestDef), 0)
// state0:
accept, errorSet = false, 14
switch Symbol(p.tok.Ch) {
	case  RugoTOK_rats:
r = append(r, p.shift())
goto state1
}
return p.stop(r, accept, errorSet)
state1:
accept, errorSet = false, 49
switch Symbol(p.tok.Ch) {
	case  Rugostr_lit:
r = append(r, p.shift())
goto state2
}
return p.stop(r, accept, errorSet)
state2:
accept, errorSet = false, 41
switch Symbol(p.tok.Ch) {
	case  RugoTOK_end:
r = append(r, p.shift())
goto state3
	case  RugoTOK_bench, RugoTOK_break, RugoTOK_case, RugoTOK_def, RugoTOK_false, RugoTOK_fn, RugoTOK_for, RugoTOK_if, RugoTOK_import, RugoTOK_next, RugoTOK_nil, RugoTOK_parallel, RugoTOK_rats, RugoTOK_require, RugoTOK_return, RugoTOK_sandbox, RugoTOK_spawn, RugoTOK_true, RugoTOK_try, RugoTOK_use, RugoTOK_while, RugoTOK_0021, RugoTOK_0028, RugoTOK_002d, RugoTOK_003b, RugoTOK_005b, RugoTOK_007b, Rugofloat_lit, Rugoident, Rugointeger, Rugoraw_str_lit, Rugostr_lit, RugoStatement, RugoUseStmt, RugoImportStmt, RugoRequireStmt, RugoSandboxStmt, RugoFuncDef, RugoTestDef, RugoBenchDef, RugoIfStmt, RugoCaseExpr, RugoWhileStmt, RugoForStmt, RugoBreakStmt, RugoNextStmt, RugoReturnStmt, RugoAssignOrExpr, RugoExpr, RugoOrExpr, RugoAndExpr, RugoCompExpr, RugoAddExpr, RugoMulExpr, RugoUnaryExpr, RugoPostfix, RugoPrimary, RugoTryExpr, RugoSpawnExpr, RugoParallelExpr, RugoFnExpr, RugoArrayLit, RugoHashLit:
r = p.add(r, p.Body())
goto state4
}
return p.stop(r, accept, errorSet)
state3:
accept, errorSet = true, 0
return p.stop(r, accept, errorSet)
state4:
accept, errorSet = false, 0
switch Symbol(p.tok.Ch) {
	case  RugoTOK_end:
r = append(r, p.shift())
goto state3
}
return p.stop(r, accept, errorSet)
}


// TryExpr grammar:
//
//	
//	
//	TryExpr      = "try" Expr "or" ident Body "end" .
//
//	State 0
//		on  "try"
//			shift and goto state 1
//	State 1
//		on  "case", "false", "fn", "nil", "parallel", "spawn", "true", "try", '!', '(', '-', '[', '{', float_lit, ident, integer, raw_str_lit, str_lit, CaseExpr, OrExpr, AndExpr, CompExpr, AddExpr, MulExpr, UnaryExpr, Postfix, Primary, TryExpr, SpawnExpr, ParallelExpr, FnExpr, ArrayLit, HashLit
//			call Expr and goto state 2
//	State 2
//		on  "or"
//			shift and goto state 3
//	State 3
//		on  ident
//			shift and goto state 4
//	State 4
//		on  "end"
//			shift and goto state 5
//		on  "bench", "break", "case", "def", "false", "fn", "for", "if", "import", "next", "nil", "parallel", "rats", "require", "return", "sandbox", "spawn", "true", "try", "use", "while", '!', '(', '-', ';', '[', '{', float_lit, ident, integer, raw_str_lit, str_lit, Statement, UseStmt, ImportStmt, RequireStmt, SandboxStmt, FuncDef, TestDef, BenchDef, IfStmt, CaseExpr, WhileStmt, ForStmt, BreakStmt, NextStmt, ReturnStmt, AssignOrExpr, Expr, OrExpr, AndExpr, CompExpr, AddExpr, MulExpr, UnaryExpr, Postfix, Primary, TryExpr, SpawnExpr, ParallelExpr, FnExpr, ArrayLit, HashLit
//			call Body and goto state 6
//	State 5
//		Accept
//	State 6
//		on  "end"
//			shift and goto state 5
// TryExpr is used internally from Parse.
func (p *Parser) TryExpr() (r []int32) {
		accept, errorSet := false, 0
		r = append(p.get(), -int32(RugoTryExpr), 0)
// state0:
accept, errorSet = false, 19
switch Symbol(p.tok.Ch) {
	case  RugoTOK_try:
r = append(r, p.shift())
goto state1
}
return p.stop(r, accept, errorSet)
state1:
accept, errorSet = false, 56
switch Symbol(p.tok.Ch) {
	case  RugoTOK_case, RugoTOK_false, RugoTOK_fn, RugoTOK_nil, RugoTOK_parallel, RugoTOK_spawn, RugoTOK_true, RugoTOK_try, RugoTOK_0021, RugoTOK_0028, RugoTOK_002d, RugoTOK_005b, RugoTOK_007b, Rugofloat_lit, Rugoident, Rugointeger, Rugoraw_str_lit, Rugostr_lit, RugoCaseExpr, RugoOrExpr, RugoAndExpr, RugoCompExpr, RugoAddExpr, RugoMulExpr, RugoUnaryExpr, RugoPostfix, RugoPrimary, RugoTryExpr, RugoSpawnExpr, RugoParallelExpr, RugoFnExpr, RugoArrayLit, RugoHashLit:
r = p.add(r, p.Expr())
goto state2
}
return p.stop(r, accept, errorSet)
state2:
accept, errorSet = false, 12
switch Symbol(p.tok.Ch) {
	case  RugoTOK_or:
r = append(r, p.shift())
goto state3
}
return p.stop(r, accept, errorSet)
state3:
accept, errorSet = false, 47
switch Symbol(p.tok.Ch) {
	case  Rugoident:
r = append(r, p.shift())
goto state4
}
return p.stop(r, accept, errorSet)
state4:
accept, errorSet = false, 41
switch Symbol(p.tok.Ch) {
	case  RugoTOK_end:
r = append(r, p.shift())
goto state5
	case  RugoTOK_bench, RugoTOK_break, RugoTOK_case, RugoTOK_def, RugoTOK_false, RugoTOK_fn, RugoTOK_for, RugoTOK_if, RugoTOK_import, RugoTOK_next, RugoTOK_nil, RugoTOK_parallel, RugoTOK_rats, RugoTOK_require, RugoTOK_return, RugoTOK_sandbox, RugoTOK_spawn, RugoTOK_true, RugoTOK_try, RugoTOK_use, RugoTOK_while, RugoTOK_0021, RugoTOK_0028, RugoTOK_002d, RugoTOK_003b, RugoTOK_005b, RugoTOK_007b, Rugofloat_lit, Rugoident, Rugointeger, Rugoraw_str_lit, Rugostr_lit, RugoStatement, RugoUseStmt, RugoImportStmt, RugoRequireStmt, RugoSandboxStmt, RugoFuncDef, RugoTestDef, RugoBenchDef, RugoIfStmt, RugoCaseExpr, RugoWhileStmt, RugoForStmt, RugoBreakStmt, RugoNextStmt, RugoReturnStmt, RugoAssignOrExpr, RugoExpr, RugoOrExpr, RugoAndExpr, RugoCompExpr, RugoAddExpr, RugoMulExpr, RugoUnaryExpr, RugoPostfix, RugoPrimary, RugoTryExpr, RugoSpawnExpr, RugoParallelExpr, RugoFnExpr, RugoArrayLit, RugoHashLit:
r = p.add(r, p.Body())
goto state6
}
return p.stop(r, accept, errorSet)
state5:
accept, errorSet = true, 0
return p.stop(r, accept, errorSet)
state6:
accept, errorSet = false, 0
switch Symbol(p.tok.Ch) {
	case  RugoTOK_end:
r = append(r, p.shift())
goto state5
}
return p.stop(r, accept, errorSet)
}


// UnaryExpr grammar:
//
//	
//	UnaryExpr   = '!' Postfix | '-' Postfix | Postfix .
//
//	State 0
//		on  '!', '-'
//			shift and goto state 1
//		on  "case", "false", "fn", "nil", "parallel", "spawn", "true", "try", '(', '[', '{', float_lit, ident, integer, raw_str_lit, str_lit, CaseExpr, Primary, TryExpr, SpawnExpr, ParallelExpr, FnExpr, ArrayLit, HashLit
//			call Postfix and goto state 2
//	State 1
//		on  "case", "false", "fn", "nil", "parallel", "spawn", "true", "try", '(', '[', '{', float_lit, ident, integer, raw_str_lit, str_lit, CaseExpr, Primary, TryExpr, SpawnExpr, ParallelExpr, FnExpr, ArrayLit, HashLit
//			call Postfix and goto state 2
//	State 2
//		Accept
// UnaryExpr is used internally from Parse.
func (p *Parser) UnaryExpr() (r []int32) {
		accept, errorSet := false, 0
		r = append(p.get(), -int32(RugoUnaryExpr), 0)
// state0:
accept, errorSet = false, 63
switch Symbol(p.tok.Ch) {
	case  RugoTOK_0021, RugoTOK_002d:
r = append(r, p.shift())
goto state1
	case  RugoTOK_case, RugoTOK_false, RugoTOK_fn, RugoTOK_nil, RugoTOK_parallel, RugoTOK_spawn, RugoTOK_true, RugoTOK_try, RugoTOK_0028, RugoTOK_005b, RugoTOK_007b, Rugofloat_lit, Rugoident, Rugointeger, Rugoraw_str_lit, Rugostr_lit, RugoCaseExpr, RugoPrimary, RugoTryExpr, RugoSpawnExpr, RugoParallelExpr, RugoFnExpr, RugoArrayLit, RugoHashLit:
r = p.add(r, p.Postfix())
goto state2
}
return p.stop(r, accept, errorSet)
state1:
accept, errorSet = false, 64
switch Symbol(p.tok.Ch) {
	case  RugoTOK_case, RugoTOK_false, RugoTOK_fn, RugoTOK_nil, RugoTOK_parallel, RugoTOK_spawn, RugoTOK_true, RugoTOK_try, RugoTOK_0028, RugoTOK_005b, RugoTOK_007b, Rugofloat_lit, Rugoident, Rugointeger, Rugoraw_str_lit, Rugostr_lit, RugoCaseExpr, RugoPrimary, RugoTryExpr, RugoSpawnExpr, RugoParallelExpr, RugoFnExpr, RugoArrayLit, RugoHashLit:
r = p.add(r, p.Postfix())
goto state2
}
return p.stop(r, accept, errorSet)
state2:
accept, errorSet = true, 0
return p.stop(r, accept, errorSet)
}


// UseStmt grammar:
//
//	
//	
//	UseStmt     = "use" str_lit .
//
//	State 0
//		on  "use"
//			shift and goto state 1
//	State 1
//		on  str_lit
//			shift and goto state 2
//	State 2
//		Accept
// UseStmt is used internally from Parse.
func (p *Parser) UseStmt() (r []int32) {
		accept, errorSet := false, 0
		r = append(p.get(), -int32(RugoUseStmt), 0)
// state0:
accept, errorSet = false, 20
switch Symbol(p.tok.Ch) {
	case  RugoTOK_use:
r = append(r, p.shift())
goto state1
}
return p.stop(r, accept, errorSet)
state1:
accept, errorSet = false, 49
switch Symbol(p.tok.Ch) {
	case  Rugostr_lit:
r = append(r, p.shift())
goto state2
}
return p.stop(r, accept, errorSet)
state2:
accept, errorSet = true, 0
return p.stop(r, accept, errorSet)
}


// WhileStmt grammar:
//
//	
//	WhileStmt   = "while" Expr Body "end" .
//
//	State 0
//		on  "while"
//			shift and goto state 1
//	State 1
//		on  "case", "false", "fn", "nil", "parallel", "spawn", "true", "try", '!', '(', '-', '[', '{', float_lit, ident, integer, raw_str_lit, str_lit, CaseExpr, OrExpr, AndExpr, CompExpr, AddExpr, MulExpr, UnaryExpr, Postfix, Primary, TryExpr, SpawnExpr, ParallelExpr, FnExpr, ArrayLit, HashLit
//			call Expr and goto state 2
//	State 2
//		on  "end"
//			shift and goto state 3
//		on  "bench", "break", "case", "def", "false", "fn", "for", "if", "import", "next", "nil", "parallel", "rats", "require", "return", "sandbox", "spawn", "true", "try", "use", "while", '!', '(', '-', ';', '[', '{', float_lit, ident, integer, raw_str_lit, str_lit, Statement, UseStmt, ImportStmt, RequireStmt, SandboxStmt, FuncDef, TestDef, BenchDef, IfStmt, CaseExpr, WhileStmt, ForStmt, BreakStmt, NextStmt, ReturnStmt, AssignOrExpr, Expr, OrExpr, AndExpr, CompExpr, AddExpr, MulExpr, UnaryExpr, Postfix, Primary, TryExpr, SpawnExpr, ParallelExpr, FnExpr, ArrayLit, HashLit
//			call Body and goto state 4
//	State 3
//		Accept
//	State 4
//		on  "end"
//			shift and goto state 3
// WhileStmt is used internally from Parse.
func (p *Parser) WhileStmt() (r []int32) {
		accept, errorSet := false, 0
		r = append(p.get(), -int32(RugoWhileStmt), 0)
// state0:
accept, errorSet = false, 21
switch Symbol(p.tok.Ch) {
	case  RugoTOK_while:
r = append(r, p.shift())
goto state1
}
return p.stop(r, accept, errorSet)
state1:
accept, errorSet = false, 56
switch Symbol(p.tok.Ch) {
	case  RugoTOK_case, RugoTOK_false, RugoTOK_fn, RugoTOK_nil, RugoTOK_parallel, RugoTOK_spawn, RugoTOK_true, RugoTOK_try, RugoTOK_0021, RugoTOK_0028, RugoTOK_002d, RugoTOK_005b, RugoTOK_007b, Rugofloat_lit, Rugoident, Rugointeger, Rugoraw_str_lit, Rugostr_lit, RugoCaseExpr, RugoOrExpr, RugoAndExpr, RugoCompExpr, RugoAddExpr, RugoMulExpr, RugoUnaryExpr, RugoPostfix, RugoPrimary, RugoTryExpr, RugoSpawnExpr, RugoParallelExpr, RugoFnExpr, RugoArrayLit, RugoHashLit:
r = p.add(r, p.Expr())
goto state2
}
return p.stop(r, accept, errorSet)
state2:
accept, errorSet = false, 41
switch Symbol(p.tok.Ch) {
	case  RugoTOK_end:
r = append(r, p.shift())
goto state3
	case  RugoTOK_bench, RugoTOK_break, RugoTOK_case, RugoTOK_def, RugoTOK_false, RugoTOK_fn, RugoTOK_for, RugoTOK_if, RugoTOK_import, RugoTOK_next, RugoTOK_nil, RugoTOK_parallel, RugoTOK_rats, RugoTOK_require, RugoTOK_return, RugoTOK_sandbox, RugoTOK_spawn, RugoTOK_true, RugoTOK_try, RugoTOK_use, RugoTOK_while, RugoTOK_0021, RugoTOK_0028, RugoTOK_002d, RugoTOK_003b, RugoTOK_005b, RugoTOK_007b, Rugofloat_lit, Rugoident, Rugointeger, Rugoraw_str_lit, Rugostr_lit, RugoStatement, RugoUseStmt, RugoImportStmt, RugoRequireStmt, RugoSandboxStmt, RugoFuncDef, RugoTestDef, RugoBenchDef, RugoIfStmt, RugoCaseExpr, RugoWhileStmt, RugoForStmt, RugoBreakStmt, RugoNextStmt, RugoReturnStmt, RugoAssignOrExpr, RugoExpr, RugoOrExpr, RugoAndExpr, RugoCompExpr, RugoAddExpr, RugoMulExpr, RugoUnaryExpr, RugoPostfix, RugoPrimary, RugoTryExpr, RugoSpawnExpr, RugoParallelExpr, RugoFnExpr, RugoArrayLit, RugoHashLit:
r = p.add(r, p.Body())
goto state4
}
return p.stop(r, accept, errorSet)
state3:
accept, errorSet = true, 0
return p.stop(r, accept, errorSet)
state4:
accept, errorSet = false, 0
switch Symbol(p.tok.Ch) {
	case  RugoTOK_end:
r = append(r, p.shift())
goto state3
}
return p.stop(r, accept, errorSet)
}


func (p *Parser) shift() (r int32) {
	r = p.tokIndex
	if !p.eof {
		p.tok = p.Scan()
		p.tokIndex++
		p.eof = p.tok.Ch == rune(RugoTOK_EOF)
	}
	return r
}

func (p *Parser) get() (r []int32) {
	if n := len(p.cache); n != 0 {
		r = p.cache[n-1][:0]
		p.cache = p.cache[:n-1]
	}
	return r
}

func (p *Parser) add(r, s []int32) (t []int32) {
	p.cache = append(p.cache, s)
	return append(r, s...)
}

func (p *Parser) stop(r []int32, accept bool, errorSet int) []int32 {
	r[1] = int32(len(r) - 2)
	if !accept {
		p.err(p.tok.Position(), "%q [%s]: expected %v", p.tok.Src(), Symbol(p.tok.Ch), errorSets[errorSet])
	}
	return r
}

// EOF reports whether the parser lookahead token is EOF.
func (p *Parser) EOF() bool {
	return p.eof
}

// Token returns the n-th token in 'p'. Token panics if 'n' is out of range.
func (p *Parser) Token(n int32) (r scanner.Token) {
	return p.sc.Token(int(n))
}

// Parse parses 'src'. 'src' becomes "owned" by the parser and must not be
// mutated afterwards.
func (p *Parser) Parse(name string, src []byte) (ast []int32, err error) {
	if err = p.init(name, src); err != nil {
		return nil, err
	}

	defer func() {
		switch e := recover(); x := e.(type) {
		case nil:
			// ok
		case scanner.ErrList:
			err = x
		case error:
			err = errors.Join(err, x)
		default:
			err = errors.Join(err, fmt.Errorf("%v", x))
		}
	}()

	p.tok = p.Scan()
	ast = p.Program()
	return ast, p.sc.Err()
}

func (p *Parser) err0(pos token.Position, s string, args ...any) {
	p.sc.AddErr(pos, s, args...)
	if p.errBudget--; p.errBudget == 0 {
		p.sc.AddErr(pos, "too many errors")
	}
}

func (p *Parser) err(pos token.Position, s string, args ...any) {
	p.err0(pos, s, args...)
	p.shift()
	if p.eof {
		panic(p.sc.Err())
	}
}

