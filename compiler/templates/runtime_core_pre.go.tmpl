// --- Rugo Runtime ---

type rugoShellError struct {
	code int
	cmd  string
}
func (e rugoShellError) Error() string {
	return fmt.Sprintf("shell command failed (exit %d): %s", e.code, e.cmd)
}

func rugo_to_bool(v interface{}) bool {
	switch val := v.(type) {
	case bool:
		return val
	case int:
		return val != 0
	case float64:
		return val != 0
	case string:
		return val != ""
	case nil:
		return false
	default:
		return true
	}
}

func rugo_to_int(v interface{}) int {
	switch val := v.(type) {
	case int:
		return val
	case float64:
		return int(val)
	case bool:
		if val { return 1 }
		return 0
	default:
		panic(fmt.Sprintf("cannot convert %T to int", v))
	}
}

func rugo_to_float(v interface{}) float64 {
	switch val := v.(type) {
	case float64:
		return val
	case int:
		return float64(val)
	default:
		panic(fmt.Sprintf("cannot convert %T to float", v))
	}
}

func rugo_to_string(v interface{}) string {
	return fmt.Sprintf("%v", v)
}

func rugo_add(a, b interface{}) interface{} {
	switch av := a.(type) {
	case int:
		if bv, ok := b.(int); ok { return av + bv }
		if bv, ok := b.(float64); ok { return float64(av) + bv }
	case float64:
		if bv, ok := b.(float64); ok { return av + bv }
		if bv, ok := b.(int); ok { return av + float64(bv) }
	case string:
		return av + rugo_to_string(b)
	}
	panic(fmt.Sprintf("cannot add %T and %T", a, b))
}

func rugo_sub(a, b interface{}) interface{} {
	switch av := a.(type) {
	case int:
		if bv, ok := b.(int); ok { return av - bv }
		if bv, ok := b.(float64); ok { return float64(av) - bv }
	case float64:
		if bv, ok := b.(float64); ok { return av - bv }
		if bv, ok := b.(int); ok { return av - float64(bv) }
	}
	panic(fmt.Sprintf("cannot subtract %T and %T", a, b))
}

func rugo_mul(a, b interface{}) interface{} {
	switch av := a.(type) {
	case int:
		if bv, ok := b.(int); ok { return av * bv }
		if bv, ok := b.(float64); ok { return float64(av) * bv }
	case float64:
		if bv, ok := b.(float64); ok { return av * bv }
		if bv, ok := b.(int); ok { return av * float64(bv) }
	}
	panic(fmt.Sprintf("cannot multiply %T and %T", a, b))
}

func rugo_div(a, b interface{}) interface{} {
	switch av := a.(type) {
	case int:
		if bv, ok := b.(int); ok { return av / bv }
		if bv, ok := b.(float64); ok { return float64(av) / bv }
	case float64:
		if bv, ok := b.(float64); ok { return av / bv }
		if bv, ok := b.(int); ok { return av / float64(bv) }
	}
	panic(fmt.Sprintf("cannot divide %T and %T", a, b))
}

func rugo_mod(a, b interface{}) interface{} {
	return rugo_to_int(a) % rugo_to_int(b)
}

func rugo_negate(a interface{}) interface{} {
	switch av := a.(type) {
	case int:
		return -av
	case float64:
		return -av
	}
	panic(fmt.Sprintf("cannot negate %T", a))
}

func rugo_not(a interface{}) interface{} {
	return !rugo_to_bool(a)
}

func rugo_eq(a, b interface{}) interface{} {
	if rugo_is_numeric(a) && rugo_is_numeric(b) {
		return rugo_to_float(a) == rugo_to_float(b)
	}
	return a == b
}

func rugo_neq(a, b interface{}) interface{} {
	if rugo_is_numeric(a) && rugo_is_numeric(b) {
		return rugo_to_float(a) != rugo_to_float(b)
	}
	return a != b
}

func rugo_lt(a, b interface{}) interface{} {
	if as, ok := a.(string); ok {
		if bs, ok := b.(string); ok {
			return as < bs
		}
	}
	return rugo_to_float(a) < rugo_to_float(b)
}

func rugo_gt(a, b interface{}) interface{} {
	if as, ok := a.(string); ok {
		if bs, ok := b.(string); ok {
			return as > bs
		}
	}
	return rugo_to_float(a) > rugo_to_float(b)
}

func rugo_le(a, b interface{}) interface{} {
	if as, ok := a.(string); ok {
		if bs, ok := b.(string); ok {
			return as <= bs
		}
	}
	return rugo_to_float(a) <= rugo_to_float(b)
}

func rugo_ge(a, b interface{}) interface{} {
	if as, ok := a.(string); ok {
		if bs, ok := b.(string); ok {
			return as >= bs
		}
	}
	return rugo_to_float(a) >= rugo_to_float(b)
}

func rugo_is_numeric(v interface{}) bool {
	switch v.(type) {
	case int, float64:
		return true
	}
	return false
}

func rugo_puts(args ...interface{}) interface{} {
	if len(args) == 1 {
		fmt.Println(rugo_to_string(args[0]))
		return nil
	}
	parts := make([]string, len(args))
	for i, a := range args {
		parts[i] = rugo_to_string(a)
	}
	fmt.Println(strings.Join(parts, " "))
	return nil
}

func rugo_print(args ...interface{}) interface{} {
	if len(args) == 1 {
		fmt.Print(rugo_to_string(args[0]))
		return nil
	}
	parts := make([]string, len(args))
	for i, a := range args {
		parts[i] = rugo_to_string(a)
	}
	fmt.Print(strings.Join(parts, " "))
	return nil
}

func rugo_raise(args ...interface{}) interface{} {
	if len(args) == 0 {
		panic("runtime error")
	}
	panic(rugo_to_string(args[0]))
}

func rugo_exit(args ...interface{}) interface{} {
	code := 0
	if len(args) > 0 {
		code = rugo_to_int(args[0])
	}
	os.Exit(code)
	return nil
}

func rugo_shell(args ...interface{}) interface{} {
	if len(args) == 0 { panic("shell requires at least one argument") }
	cmdStr := rugo_to_string(args[0])
	cmd := exec.Command("sh", "-c", cmdStr)
	cmd.Stdout = os.Stdout
	cmd.Stderr = os.Stderr
	cmd.Stdin = os.Stdin
	err := cmd.Run()
	if err != nil {
		if exitErr, ok := err.(*exec.ExitError); ok {
			panic(rugoShellError{code: exitErr.ExitCode(), cmd: cmdStr})
		}
		panic(fmt.Sprintf("shell failed: %v", err))
	}
	return 0
}

func rugo_capture(args ...interface{}) interface{} {
	if len(args) == 0 { panic("capture requires at least one argument") }
	cmdStr := rugo_to_string(args[0])
	cmd := exec.Command("sh", "-c", cmdStr)
	cmd.Stderr = os.Stderr
	out, err := cmd.Output()
	if err != nil {
		if exitErr, ok := err.(*exec.ExitError); ok {
			panic(rugoShellError{code: exitErr.ExitCode(), cmd: cmdStr})
		}
		panic(fmt.Sprintf("shell failed: %v", err))
	}
	return strings.TrimRight(string(out), "\n")
}

func rugo_pipe_shell(args ...interface{}) interface{} {
	if len(args) < 2 { panic("pipe_shell requires command and input arguments") }
	cmdStr := rugo_to_string(args[0])
	input := rugo_to_string(args[1])
	cmd := exec.Command("sh", "-c", cmdStr)
	cmd.Stdin = strings.NewReader(input)
	cmd.Stderr = os.Stderr
	out, err := cmd.Output()
	if err != nil {
		if exitErr, ok := err.(*exec.ExitError); ok {
			panic(rugoShellError{code: exitErr.ExitCode(), cmd: cmdStr})
		}
		panic(fmt.Sprintf("shell failed: %v", err))
	}
	return strings.TrimRight(string(out), "\n")
}

func rugo_len(args ...interface{}) interface{} {
	if len(args) == 0 { panic("len requires one argument") }
	switch v := args[0].(type) {
	case string:
		return len(v)
	case []interface{}:
		return len(v)
	case map[interface{}]interface{}:
		return len(v)
	}
	panic(fmt.Sprintf("cannot get length of %T", args[0]))
}

func rugo_type_of(args ...interface{}) interface{} {
	if len(args) == 0 { panic("type_of requires one argument") }
	v := args[0]
	switch v.(type) {
	case nil:
		return "Nil"
	case bool:
		return "Bool"
	case int:
		return "Integer"
	case float64:
		return "Float"
	case string:
		return "String"
	case []interface{}:
		return "Array"
	case map[interface{}]interface{}:
		m := v.(map[interface{}]interface{})
		if t, ok := m["__type__"]; ok {
			return t
		}
		return "Hash"
	case func(...interface{}) interface{}:
		return "Lambda"
	default:
		return "Unknown"
	}
}

func rugo_append(args ...interface{}) interface{} {
	if len(args) < 2 { panic("append requires array and value arguments") }
	arr, ok := args[0].([]interface{})
	if !ok { panic("first argument to append must be an array") }
	return append(arr, args[1])
}

type rugo_kv struct { Key, Val interface{} }

func rugo_iterable(v interface{}) []rugo_kv {
	switch c := v.(type) {
	case []interface{}:
		r := make([]rugo_kv, len(c))
		for i, v := range c { r[i] = rugo_kv{interface{}(i), v} }
		return r
	case map[interface{}]interface{}:
		r := make([]rugo_kv, 0, len(c))
		for k, v := range c { r = append(r, rugo_kv{k, v}) }
		return r
	}
	panic(fmt.Sprintf("cannot iterate over %T", v))
}

func rugo_index_set(obj, idx, val interface{}) {
	switch o := obj.(type) {
	case []interface{}:
		i := rugo_to_int(idx)
		if i < 0 {
			i += len(o)
		}
		o[i] = val
	case map[interface{}]interface{}:
		o[idx] = val
	default:
		panic(fmt.Sprintf("cannot index-assign %T", obj))
	}
}

func rugo_array_index(arr []interface{}, idx int) interface{} {
	if idx < 0 {
		idx += len(arr)
	}
	return arr[idx]
}

func rugo_index(obj, idx interface{}) interface{} {
	switch o := obj.(type) {
	case []interface{}:
		return rugo_array_index(o, rugo_to_int(idx))
	case map[interface{}]interface{}:
		return o[idx]
	default:
		panic(fmt.Sprintf("cannot index %T", o))
	}
}

func rugo_type_name(v interface{}) string {
	switch v.(type) {
	case nil:
		return "nil"
	case bool:
		return "bool"
	case int:
		return "int"
	case float64:
		return "float"
	case string:
		return "string"
	case []interface{}:
		return "array"
	case map[interface{}]interface{}:
		return "hash"
	case func(...interface{}) interface{}:
		return "lambda"
	default:
		return fmt.Sprintf("%T", v)
	}
}

func rugo_slice(obj, start, length interface{}) interface{} {
	s := rugo_to_int(start)
	l := rugo_to_int(length)
	switch v := obj.(type) {
	case string:
		if s >= len(v) {
			return interface{}("")
		}
		end := s + l
		if end > len(v) {
			end = len(v)
		}
		return interface{}(v[s:end])
	case []interface{}:
		if s >= len(v) {
			return interface{}([]interface{}{})
		}
		end := s + l
		if end > len(v) {
			end = len(v)
		}
		result := make([]interface{}, end-s)
		copy(result, v[s:end])
		return interface{}(result)
	default:
		panic(fmt.Sprintf("cannot slice %s (expected string or array)", rugo_type_name(obj)))
	}
}

// rugo_bridge_err formats a Go bridge error with the Rugo function name,
// stripping the Go function name prefix if present.
func rugo_bridge_err(rugoName string, err error) string {
	msg := err.Error()
	// Go errors often start with "package.Function: ..." â€” strip it
	if idx := strings.Index(msg, ": "); idx > 0 {
		prefix := msg[:idx]
		// If the prefix looks like a Go function reference, strip it
		if strings.Contains(prefix, ".") && prefix[0] >= 'a' && prefix[0] <= 'z' {
			msg = msg[idx+2:]
		}
	}
	return fmt.Sprintf("%s: %s", rugoName, msg)
}

