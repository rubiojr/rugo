# RATS: Test json module (parse, encode)
import "test"
import "conv"

test "json.parse parses object"
  test.run("printf 'import \"json\"\nimport \"conv\"\ndata = json.parse(\"{\\\\\"name\\\\\": \\\\\"rugo\\\\\", \\\\\"version\\\\\": 1}\")\nputs(data[\"name\"])\nputs(conv.to_s(data[\"version\"]))\n' > " + test.tmpdir() + "/test.rg")
  result = test.run("./rugo run " + test.tmpdir() + "/test.rg")
  test.assert_eq(result["status"], 0)
  lines = result["lines"]
  test.assert_eq(lines[0], "rugo")
  test.assert_eq(lines[1], "1")
end

test "json.parse parses array"
  test.run("printf 'import \"json\"\nimport \"conv\"\narr = json.parse(\"[1, 2, 3]\")\nputs(conv.to_s(len(arr)))\nputs(conv.to_s(arr[0]))\nputs(conv.to_s(arr[2]))\n' > " + test.tmpdir() + "/test.rg")
  result = test.run("./rugo run " + test.tmpdir() + "/test.rg")
  test.assert_eq(result["status"], 0)
  lines = result["lines"]
  test.assert_eq(lines[0], "3")
  test.assert_eq(lines[1], "1")
  test.assert_eq(lines[2], "3")
end

test "json.parse converts whole numbers to int"
  test.run("printf 'import \"json\"\nimport \"conv\"\ndata = json.parse(\"{\\\\\"id\\\\\": 12345}\")\nputs(conv.to_s(data[\"id\"]))\n' > " + test.tmpdir() + "/test.rg")
  result = test.run("./rugo run " + test.tmpdir() + "/test.rg")
  test.assert_eq(result["status"], 0)
  test.assert_eq(result["output"], "12345")
end

test "json.parse preserves floats"
  test.run("printf 'import \"json\"\nimport \"conv\"\ndata = json.parse(\"{\\\\\"pi\\\\\": 3.14}\")\nputs(conv.to_s(data[\"pi\"]))\n' > " + test.tmpdir() + "/test.rg")
  result = test.run("./rugo run " + test.tmpdir() + "/test.rg")
  test.assert_eq(result["status"], 0)
  test.assert_eq(result["output"], "3.14")
end

test "json.parse handles nested objects"
  test.run("printf 'import \"json\"\ndata = json.parse(\"{\\\\\"user\\\\\": {\\\\\"name\\\\\": \\\\\"rugo\\\\\"}}\")\nputs(data[\"user\"][\"name\"])\n' > " + test.tmpdir() + "/test.rg")
  result = test.run("./rugo run " + test.tmpdir() + "/test.rg")
  test.assert_eq(result["status"], 0)
  test.assert_eq(result["output"], "rugo")
end

test "json.parse handles booleans and null"
  test.run("printf 'import \"json\"\nimport \"conv\"\ndata = json.parse(\"{\\\\\"ok\\\\\": true, \\\\\"err\\\\\": null}\")\nputs(conv.to_s(data[\"ok\"]))\nputs(data[\"err\"] == nil)\n' > " + test.tmpdir() + "/test.rg")
  result = test.run("./rugo run " + test.tmpdir() + "/test.rg")
  test.assert_eq(result["status"], 0)
  lines = result["lines"]
  test.assert_eq(lines[0], "true")
  test.assert_eq(lines[1], "true")
end

test "json.encode converts hash to JSON"
  test.run("printf 'import \"json\"\nh = {\"a\" => 1}\nputs(json.encode(h))\n' > " + test.tmpdir() + "/test.rg")
  result = test.run("./rugo run " + test.tmpdir() + "/test.rg")
  test.assert_eq(result["status"], 0)
  test.assert_contains(result["output"], "\"a\"")
  test.assert_contains(result["output"], "1")
end

test "json.encode converts array to JSON"
  test.run("printf 'import \"json\"\narr = [1, \"two\", true]\nputs(json.encode(arr))\n' > " + test.tmpdir() + "/test.rg")
  result = test.run("./rugo run " + test.tmpdir() + "/test.rg")
  test.assert_eq(result["status"], 0)
  test.assert_eq(result["output"], "[1,\"two\",true]")
end

test "json.parse roundtrip"
  test.run("printf 'import \"json\"\noriginal = \"[1,2,3]\"\nparsed = json.parse(original)\nresult = json.encode(parsed)\nputs(result)\n' > " + test.tmpdir() + "/test.rg")
  result = test.run("./rugo run " + test.tmpdir() + "/test.rg")
  test.assert_eq(result["status"], 0)
  test.assert_eq(result["output"], "[1,2,3]")
end

test "json.parse panics on invalid JSON"
  test.run("printf 'import \"json\"\njson.parse(\"not json\")\n' > " + test.tmpdir() + "/test.rg")
  result = test.run("./rugo run " + test.tmpdir() + "/test.rg")
  test.assert_neq(result["status"], 0)
  test.assert_contains(result["output"], "json.parse")
end
