# RATS: Sandbox (Landlock) comprehensive tests
use "test"
use "eval"
use "os"
use "str"

def skip_if_no_landlock()
  result = test.run("uname -s")
  if result["status"] != 0 || result["output"] != "Linux"
    test.skip("Landlock requires Linux")
  end
end

# ── Codegen / emit tests ────────────────────────────────────────────

rats "emit: bare sandbox generates Restrict() call"
  result = test.run("rugo emit rats/core/fixtures/sandbox/bare.rugo")
  test.assert_eq(result["status"], 0)
  test.assert_contains(result["output"], "landlock.V5.BestEffort()")
  test.assert_contains(result["output"], "rugo_sandbox_cfg.Restrict()")
end

rats "emit: full permissions generate all rule types"
  result = test.run("rugo emit rats/core/fixtures/sandbox/full_perms.rugo")
  test.assert_eq(result["status"], 0)
  test.assert_contains(result["output"], "rugo_sandbox_fs_ro")
  test.assert_contains(result["output"], "rugo_sandbox_fs_rw")
  test.assert_contains(result["output"], "rugo_sandbox_fs_rox")
  test.assert_contains(result["output"], "rugo_sandbox_fs_rwx")
  test.assert_contains(result["output"], "landlock.ConnectTCP")
  test.assert_contains(result["output"], "landlock.BindTCP")
end

rats "emit: non-linux warning is generated"
  result = test.run("rugo emit rats/core/fixtures/sandbox/bare.rugo")
  test.assert_eq(result["status"], 0)
  test.assert_contains(result["output"], "runtime.GOOS")
  test.assert_contains(result["output"], "sandbox requires Linux")
end

rats "emit: single values (not arrays) work"
  result = test.run("rugo emit rats/core/fixtures/sandbox/single_values.rugo")
  test.assert_eq(result["status"], 0)
  test.assert_contains(result["output"], "/etc")
  test.assert_contains(result["output"], "/tmp")
  test.assert_contains(result["output"], "/usr/bin")
  test.assert_contains(result["output"], "ConnectTCP(uint16(443))")
  test.assert_contains(result["output"], "BindTCP(uint16(8080))")
end

rats "emit: network-only sandbox still restricts filesystem"
  result = test.run("rugo emit rats/core/fixtures/sandbox/network_only.rugo")
  test.assert_eq(result["status"], 0)
  test.assert_contains(result["output"], "RestrictPaths()")
  test.assert_contains(result["output"], "RestrictNet(rugo_sandbox_net...)")
end

rats "emit: fs-only sandbox still restricts network"
  result = test.run("rugo emit rats/core/fixtures/sandbox/fs_only.rugo")
  test.assert_eq(result["status"], 0)
  test.assert_contains(result["output"], "RestrictPaths(rugo_sandbox_fs...)")
  test.assert_contains(result["output"], "RestrictNet()")
end

rats "emit: sandbox with function definitions"
  result = test.run("rugo emit rats/core/fixtures/sandbox/sandbox_with_func.rugo")
  test.assert_eq(result["status"], 0)
  test.assert_contains(result["output"], "rugo_sandbox_cfg")
  test.assert_contains(result["output"], "hello from sandboxed function")
end

rats "emit: no sandbox means no landlock imports"
  result = test.run("rugo emit rats/core/fixtures/sandbox/no_sandbox.rugo")
  test.assert_eq(result["status"], 0)
  test.assert_false(str.contains(result["output"], "go-landlock"))
  test.assert_false(str.contains(result["output"], "rugo_sandbox_cfg"))
end

rats "emit: sandbox with require of clean library"
  result = test.run("rugo emit rats/core/fixtures/sandbox/sandbox_with_require.rugo")
  test.assert_eq(result["status"], 0)
  test.assert_contains(result["output"], "rugo_sandbox_cfg")
  test.assert_contains(result["output"], "rugons_helper_helper_add")
end

rats "emit: sandbox after use/import/require compiles"
  result = test.run("rugo emit rats/core/fixtures/sandbox/sandbox_after_decls.rugo")
  test.assert_eq(result["status"], 0)
  test.assert_contains(result["output"], "rugo_sandbox_cfg")
end

rats "emit: sandbox paths use os.ExpandEnv for env var expansion"
  script = <<~SCRIPT
    sandbox ro: ["$HOME"], rox: ["/usr", "/lib"], rw: ["/dev/null"]
    puts("env expand sandbox active")
  SCRIPT
  test.write_file("#{test.tmpdir()}/test.rugo", script)
  result = test.run("rugo emit #{test.tmpdir()}/test.rugo")
  test.assert_eq(result["status"], 0)
  test.assert_contains(result["output"], 'os.ExpandEnv("$HOME")')
end

# ── Placement / compile error tests ─────────────────────────────────

rats "error: duplicate sandbox directive"
  source = <<~RUGO
    sandbox ro: "/etc"
    sandbox rw: "/tmp"
    puts("should not reach here")
  RUGO
  result = eval.run(source)
  test.assert_neq(result["status"], 0)
  test.assert_contains(result["output"], "duplicate sandbox directive")
end

rats "error: sandbox in required file"
  result = eval.file("rats/core/fixtures/sandbox/require_sandbox_lib.rugo")
  test.assert_neq(result["status"], 0)
  test.assert_contains(result["output"], "sandbox directive not allowed in required files")
end

rats "error: sandbox in nested required file"
  result = eval.file("rats/core/fixtures/sandbox/require_nested_sandbox.rugo")
  test.assert_neq(result["status"], 0)
  test.assert_contains(result["output"], "sandbox directive not allowed in required files")
end

rats "error: sandbox after assignment"
  source = <<~RUGO
    x = 42
    sandbox ro: ["/etc"]
    puts(x)
  RUGO
  result = eval.run(source)
  test.assert_neq(result["status"], 0)
  test.assert_contains(result["output"], "sandbox must appear before any other code")
end

rats "error: sandbox after def"
  source = <<~RUGO
    def helper()
      return "ok"
    end
    sandbox ro: ["/etc"]
    puts(helper())
  RUGO
  result = eval.run(source)
  test.assert_neq(result["status"], 0)
  test.assert_contains(result["output"], "sandbox must appear before any other code")
end

rats "error: sandbox inside function"
  source = <<~RUGO
    def foo()
      sandbox ro: "/etc"
    end
    foo()
  RUGO
  result = eval.run(source)
  test.assert_neq(result["status"], 0)
  test.assert_contains(result["output"], "sandbox must be a top-level directive")
end

rats "error: sandbox inside if block"
  source = <<~RUGO
    if true
      sandbox ro: "/etc"
    end
    puts("hi")
  RUGO
  result = eval.run(source)
  test.assert_neq(result["status"], 0)
  test.assert_contains(result["output"], "sandbox must be a top-level directive")
end

rats "error: sandbox inside while block"
  source = <<~RUGO
    while false
      sandbox ro: "/etc"
    end
    puts("hi")
  RUGO
  result = eval.run(source)
  test.assert_neq(result["status"], 0)
  test.assert_contains(result["output"], "sandbox must be a top-level directive")
end

# ── Runtime enforcement: Go bridge ──────────────────────────────────

rats "enforce: bare sandbox runs"
  skip_if_no_landlock()
  source = <<~RUGO
    sandbox
    puts("sandbox active")
  RUGO
  result = eval.run(source)
  test.assert_eq(result["status"], 0)
  test.assert_contains(result["output"], "sandbox active")
end

rats "enforce: ro allows reading via shell"
  skip_if_no_landlock()
  test.write_file("/tmp/rugo_sandbox_test_readable", "landlock_ok")
  source = <<~RUGO
    sandbox ro: ["/tmp"], rox: ["/usr", "/lib"], rw: ["/dev/null"]
    result = `cat /tmp/rugo_sandbox_test_readable`
    puts(result)
  RUGO
  result = eval.run(source)
  test.assert_eq(result["status"], 0)
  test.assert_contains(result["output"], "landlock_ok")
end

rats "enforce: missing ro path is denied via shell"
  skip_if_no_landlock()
  test.write_file("/tmp/rugo_sandbox_test_readable", "landlock_ok")
  source = <<~RUGO
    sandbox rox: ["/usr", "/lib"], rw: ["/dev/null"]
    result = `cat /tmp/rugo_sandbox_test_readable`
    puts(result)
  RUGO
  result = eval.run(source)
  test.assert_neq(result["status"], 0)
  test.assert_contains(result["output"], "Permission denied")
end

rats "enforce: ro denies write via Go bridge"
  skip_if_no_landlock()
  script = <<~RUGO
    sandbox ro: ["/tmp"]
    import "os"
    os.write_file("/tmp/rugo_sandbox_write_denied", "nope", 0644)
    puts("should not reach here")
  RUGO
  test.write_file("#{test.tmpdir()}/test.rugo", script)
  result = test.run("rugo run #{test.tmpdir()}/test.rugo")
  test.assert_neq(result["status"], 0)
  test.assert_contains(result["output"], "permission denied")
end

rats "enforce: rw allows write and read via Go bridge"
  skip_if_no_landlock()
  script = <<~RUGO
    sandbox rw: ["/tmp"]
    import "os"
    os.write_file("/tmp/rugo_sandbox_write_check", "sandbox_write_test", 0644)
    data = os.read_file("/tmp/rugo_sandbox_write_check")
    puts(data)
  RUGO
  test.write_file("#{test.tmpdir()}/test.rugo", script)
  result = test.run("rugo run #{test.tmpdir()}/test.rugo")
  test.assert_eq(result["status"], 0)
  test.assert_contains(result["output"], "sandbox_write_test")
end

rats "enforce: rwx allows write and read via Go bridge"
  skip_if_no_landlock()
  script = <<~RUGO
    sandbox rwx: ["/tmp"]
    import "os"
    os.write_file("/tmp/rugo_sandbox_rwx_check", "rwx_test", 0644)
    data = os.read_file("/tmp/rugo_sandbox_rwx_check")
    puts(data)
  RUGO
  test.write_file("#{test.tmpdir()}/test.rugo", script)
  result = test.run("rugo run #{test.tmpdir()}/test.rugo")
  test.assert_eq(result["status"], 0)
  test.assert_contains(result["output"], "rwx_test")
end

rats "enforce: sandbox with function definitions"
  skip_if_no_landlock()
  source = <<~RUGO
    sandbox ro: ["/etc"], rox: ["/usr", "/lib"], rw: ["/dev/null"]
    def greet()
      return "hello from sandboxed function"
    end
    puts(greet())
  RUGO
  result = eval.run(source)
  test.assert_eq(result["status"], 0)
  test.assert_contains(result["output"], "hello from sandboxed function")
end

rats "enforce: sandbox with require of clean library"
  skip_if_no_landlock()
  result = eval.file("rats/core/fixtures/sandbox/sandbox_with_require.rugo")
  test.assert_eq(result["status"], 0)
  test.assert_contains(result["output"], "3")
end

rats "enforce: no sandbox runs unrestricted"
  test.write_file("/tmp/rugo_sandbox_test_readable", "landlock_ok")
  source = <<~RUGO
    result = `cat /tmp/rugo_sandbox_test_readable`
    puts(result)
  RUGO
  result = eval.run(source)
  test.assert_eq(result["status"], 0)
  test.assert_contains(result["output"], "landlock_ok")
end

rats "enforce: sandbox with $HOME env var expansion"
  skip_if_no_landlock()
  source = <<~RUGO
    sandbox ro: ["$HOME"], rox: ["/usr", "/lib"], rw: ["/dev/null"]
    puts("env expand sandbox active")
  RUGO
  result = eval.run(source)
  test.assert_eq(result["status"], 0)
  test.assert_contains(result["output"], "env expand sandbox active")
end

# ── Runtime enforcement: shell commands ─────────────────────────────

rats "enforce: shell rw allows write and read"
  skip_if_no_landlock()
  source = <<~RUGO
    sandbox rw: ["/tmp", "/dev/null"], rox: ["/usr", "/lib"]
    `echo "shell_write_ok" > /tmp/rugo_sandbox_shell_write`
    result = `cat /tmp/rugo_sandbox_shell_write`
    puts(result)
  RUGO
  result = eval.run(source)
  test.assert_eq(result["status"], 0)
  test.assert_contains(result["output"], "shell_write_ok")
end

rats "enforce: shell ro allows reading"
  skip_if_no_landlock()
  test.write_file("/tmp/rugo_sandbox_test_readable", "shell_read_ok")
  source = <<~RUGO
    sandbox ro: ["/tmp"], rox: ["/usr", "/lib"], rw: ["/dev/null"]
    result = `cat /tmp/rugo_sandbox_test_readable`
    puts(result)
  RUGO
  result = eval.run(source)
  test.assert_eq(result["status"], 0)
  test.assert_contains(result["output"], "shell_read_ok")
end

rats "enforce: shell ro denies write"
  skip_if_no_landlock()
  source = <<~RUGO
    sandbox ro: ["/tmp"], rox: ["/usr", "/lib"], rw: ["/dev/null"]
    `echo "nope" > /tmp/rugo_sandbox_shell_write_denied`
    puts("should not reach here")
  RUGO
  result = eval.run(source)
  test.assert_neq(result["status"], 0)
  test.assert_contains(result["output"], "Permission denied")
end

rats "enforce: shell without /dev/null fails"
  skip_if_no_landlock()
  test.write_file("/tmp/rugo_sandbox_test_readable", "data")
  source = <<~RUGO
    sandbox rox: ["/usr", "/lib"], ro: ["/tmp"]
    result = `cat /tmp/rugo_sandbox_test_readable`
    puts(result)
  RUGO
  result = eval.run(source)
  test.assert_neq(result["status"], 0)
  test.assert_contains(result["output"], "/dev/null")
  test.assert_contains(result["output"], "permission denied")
end

rats "enforce: shell without rox /usr cannot execute"
  skip_if_no_landlock()
  test.write_file("/tmp/rugo_sandbox_test_readable", "data")
  source = <<~RUGO
    sandbox ro: ["/tmp"], rw: ["/dev/null"]
    result = `cat /tmp/rugo_sandbox_test_readable`
    puts(result)
  RUGO
  result = eval.run(source)
  test.assert_neq(result["status"], 0)
  test.assert_contains(result["output"], "permission denied")
end

# ── CLI flag tests ──────────────────────────────────────────────────

rats "cli: --sandbox bare denies file access"
  skip_if_no_landlock()
  test.write_file("/tmp/rugo_sandbox_test_readable", "landlock_ok")
  result = test.run("rugo run --sandbox --rox /usr --rox /lib --rw /dev/null rats/core/fixtures/sandbox/no_sandbox.rugo")
  test.assert_neq(result["status"], 0)
  test.assert_contains(result["output"], "Permission denied")
end

rats "cli: --sandbox with --ro allows reading"
  skip_if_no_landlock()
  test.write_file("/tmp/rugo_sandbox_test_readable", "landlock_ok")
  result = test.run("rugo run --sandbox --ro /tmp --rox /usr --rox /lib --rw /dev/null rats/core/fixtures/sandbox/no_sandbox.rugo")
  test.assert_eq(result["status"], 0)
  test.assert_contains(result["output"], "landlock_ok")
end

rats "cli: --sandbox overrides script directive entirely"
  skip_if_no_landlock()
  test.write_file("/tmp/rugo_sandbox_test_readable", "landlock_ok")
  # Script allows /tmp via ro, but CLI override removes it
  result = test.run("rugo run --sandbox --rox /usr --rox /lib --rw /dev/null rats/core/fixtures/sandbox/ro_allowed.rugo")
  test.assert_neq(result["status"], 0)
  test.assert_contains(result["output"], "Permission denied")
end

rats "cli: --sandbox without permission flags = deny all"
  skip_if_no_landlock()
  test.write_file("/tmp/rugo_sandbox_test_readable", "landlock_ok")
  result = test.run("rugo run --sandbox rats/core/fixtures/sandbox/no_sandbox.rugo")
  test.assert_neq(result["status"], 0)
end

rats "cli: no --sandbox flag means no sandboxing"
  test.write_file("/tmp/rugo_sandbox_test_readable", "landlock_ok")
  result = test.run("rugo run rats/core/fixtures/sandbox/no_sandbox.rugo")
  test.assert_eq(result["status"], 0)
  test.assert_contains(result["output"], "landlock_ok")
end

# ── Multi-file source tree tests ────────────────────────────────────

rats "tree: basic require + sandbox"
  skip_if_no_landlock()
  result = eval.file("rats/core/fixtures/sandbox/tree_basic/main.rugo")
  test.assert_eq(result["status"], 0)
  test.assert_contains(result["output"], "5")
  test.assert_contains(result["output"], "20")
end

rats "tree: nested require (main → lib → helpers) + sandbox"
  skip_if_no_landlock()
  # Uses import "os" which requires test.run (see git-bug 422b5b7)
  result = test.run("rugo run rats/core/fixtures/sandbox/tree_nested/main.rugo")
  test.assert_eq(result["status"], 0)
  test.assert_contains(result["output"], "hello world")
end

rats "tree: deep require (3 levels) + bare sandbox"
  skip_if_no_landlock()
  result = eval.file("rats/core/fixtures/sandbox/tree_deep/main.rugo")
  test.assert_eq(result["status"], 0)
  test.assert_contains(result["output"], "12")
end

rats "tree: multiple requires + sandbox"
  skip_if_no_landlock()
  result = eval.file("rats/core/fixtures/sandbox/tree_multi/main.rugo")
  test.assert_eq(result["status"], 0)
  test.assert_contains(result["output"], "HELLO")
  test.assert_contains(result["output"], "49")
end

rats "tree: require with selective imports + sandbox"
  skip_if_no_landlock()
  result = eval.file("rats/core/fixtures/sandbox/tree_with/main.rugo")
  test.assert_eq(result["status"], 0)
  test.assert_contains(result["output"], "13")
  test.assert_contains(result["output"], "7")
end

rats "tree: require + sandbox + shell commands"
  skip_if_no_landlock()
  test.write_file("/tmp/rugo_tree_shell_data", "tree_shell_works")
  result = eval.file("rats/core/fixtures/sandbox/tree_shell/main.rugo")
  test.assert_eq(result["status"], 0)
  test.assert_contains(result["output"], ">> tree_shell_works")
end

rats "tree: emit multi-file sandbox has correct source"
  result = test.run("rugo emit rats/core/fixtures/sandbox/tree_basic/main.rugo")
  test.assert_eq(result["status"], 0)
  test.assert_contains(result["output"], "rugo_sandbox_cfg")
  test.assert_contains(result["output"], "rugons_m_add")
  test.assert_contains(result["output"], "rugons_m_mul")
end

rats "tree: error — sandbox in directly required lib"
  result = eval.file("rats/core/fixtures/sandbox/tree_err_lib_sandbox/main.rugo")
  test.assert_neq(result["status"], 0)
  test.assert_contains(result["output"], "sandbox directive not allowed in required files")
  test.assert_contains(result["output"], "badlib.rugo")
end

rats "tree: error — sandbox in deeply nested required lib"
  result = eval.file("rats/core/fixtures/sandbox/tree_err_deep_sandbox/main.rugo")
  test.assert_neq(result["status"], 0)
  test.assert_contains(result["output"], "sandbox directive not allowed in required files")
  test.assert_contains(result["output"], "sneaky.rugo")
end
