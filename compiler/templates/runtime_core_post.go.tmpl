func rugo_panic_handler(e interface{}) {
	// Parse debug.Stack() to find the Rugo source location
	stack := string(debug.Stack())
	file := ""
	line := ""
	// Find Rugo frames after the panic() frame (skip recovery frames)
	lines := strings.Split(stack, "\n")
	pastPanic := false
	for _, s := range lines {
		if strings.Contains(s, "panic(") { pastPanic = true; continue }
		if !pastPanic { continue }
		s = strings.TrimSpace(s)
		// Check for .rugo: first (preferred), then .rg: (deprecated)
		if idx := strings.Index(s, ".rugo:"); idx >= 0 {
			rest := s[idx+6:]
			lineEnd := strings.IndexAny(rest, " +")
			if lineEnd < 0 { lineEnd = len(rest) }
			line = rest[:lineEnd]
			file = s[:idx+5]
			break
		}
		if idx := strings.Index(s, ".rg:"); idx >= 0 {
			rest := s[idx+4:]
			lineEnd := strings.IndexAny(rest, " +")
			if lineEnd < 0 { lineEnd = len(rest) }
			line = rest[:lineEnd]
			file = s[:idx+3]
			break
		}
	}
	msg := rugo_friendly_error(fmt.Sprintf("%v", e))
	if file != "" && line != "" {
		fmt.Fprintf(os.Stderr, "error: %s (%s:%s)\n", msg, file, line)
	} else {
		fmt.Fprintf(os.Stderr, "error: %s\n", msg)
	}
	os.Exit(1)
}

// rugo_friendly_error translates raw Go runtime messages to human-friendly ones.
func rugo_friendly_error(msg string) string {
	// "runtime error: index out of range [N] with length M"
	if strings.HasPrefix(msg, "runtime error: index out of range [") {
		rest := msg[len("runtime error: index out of range ["):]
		if bracket := strings.Index(rest, "]"); bracket >= 0 {
			idx := rest[:bracket]
			rest = rest[bracket+1:]
			if strings.HasPrefix(rest, " with length ") {
				length := strings.TrimPrefix(rest, " with length ")
				return fmt.Sprintf("index %s out of bounds (length %s)", idx, length)
			}
		}
	}
	// "runtime error: ..."
	if strings.HasPrefix(msg, "runtime error: ") {
		return strings.TrimPrefix(msg, "runtime error: ")
	}
	return msg
}

func rugo_dot_get(obj interface{}, field string) interface{} {
	// Task-like objects: check for field accessor interface
	if fa, ok := obj.(interface{ DotGet(string) (interface{}, bool) }); ok {
		if val, handled := fa.DotGet(field); handled {
			return val
		}
	}
	if m, ok := obj.(map[interface{}]interface{}); ok {
		return m[field]
	}
	panic(fmt.Sprintf("cannot access .%s on %T — expected a hash/struct", field, obj))
}

func rugo_dot_set(obj interface{}, field string, val interface{}) {
	if m, ok := obj.(map[interface{}]interface{}); ok {
		m[field] = val
		return
	}
	panic(fmt.Sprintf("cannot set .%s on %T — expected a hash/struct", field, obj))
}

// rugo_dot_call dispatches a method call on any object implementing the DotCall interface.
// It also supports calling lambdas stored as hash values via dot access (e.g. record.save()).
func rugo_dot_call(obj interface{}, method string, args ...interface{}) interface{} {
	if dc, ok := obj.(interface {
		DotCall(string, ...interface{}) (interface{}, bool)
	}); ok {
		if result, handled := dc.DotCall(method, args...); handled {
			return result
		}
	}
	if m, ok := obj.(map[interface{}]interface{}); ok {
		val, exists := m[method]
		if !exists {
			panic(fmt.Sprintf("undefined method .%s() — key %q not found in hash", method, method))
		}
		if fn, ok := val.(func(...interface{}) interface{}); ok {
			return fn(args...)
		}
		panic(fmt.Sprintf("cannot call .%s() — value is %T, not a function", method, val))
	}
	panic(fmt.Sprintf("cannot call .%s() on %T", method, obj))
}

// --- End Rugo Runtime ---

