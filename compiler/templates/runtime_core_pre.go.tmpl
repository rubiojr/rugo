// --- Rugo Runtime ---

var rugo_call_depth int

const rugo_max_call_depth = 10000

func rugo_check_depth(name string) {
	rugo_call_depth++
	if rugo_call_depth > rugo_max_call_depth {
		panic(fmt.Sprintf("maximum recursion depth exceeded in %s()", name))
	}
}

type rugoShellError struct {
	code int
	cmd  string
}
func (e rugoShellError) Error() string {
	return fmt.Sprintf("shell command failed (exit %d): %s", e.code, e.cmd)
}

func rugo_to_bool(v interface{}) bool {
	switch val := v.(type) {
	case bool:
		return val
	case nil:
		return false
	default:
		_ = val
		return true
	}
}

func rugo_to_int(v interface{}) int {
	switch val := v.(type) {
	case int:
		return val
	case float64:
		return int(val)
	case bool:
		if val { return 1 }
		return 0
	default:
		panic(fmt.Sprintf("cannot convert %T to int", v))
	}
}

//go:noinline
func rugo_float(f float64) float64 { return f }

func rugo_to_float(v interface{}) float64 {
	switch val := v.(type) {
	case float64:
		return val
	case int:
		return float64(val)
	default:
		panic(fmt.Sprintf("cannot convert %T to float", v))
	}
}

func rugo_to_string(v interface{}) string {
	if v == nil {
		return "nil"
	}
	if b, ok := v.([]byte); ok {
		return string(b)
	}
	if f, ok := v.(float64); ok {
		s := strconv.FormatFloat(f, 'f', -1, 64)
		if !strings.Contains(s, ".") {
			s += ".0"
		}
		return s
	}
	return fmt.Sprintf("%v", v)
}

// rugo_to_go recursively normalizes a Rugo value for Go consumption.
// Converts map[interface{}]interface{} → map[string]interface{} and
// recurses into []interface{} elements so Go stdlib functions like
// json.Marshal can process Rugo hashes and arrays.
func rugo_to_go(v interface{}) interface{} {
	switch val := v.(type) {
	case map[interface{}]interface{}:
		m := make(map[string]interface{}, len(val))
		for k, v2 := range val {
			m[fmt.Sprintf("%v", k)] = rugo_to_go(v2)
		}
		return m
	case []interface{}:
		out := make([]interface{}, len(val))
		for i, v2 := range val {
			out[i] = rugo_to_go(v2)
		}
		return out
	default:
		return v
	}
}

func rugo_add(a, b interface{}) interface{} {
	switch av := a.(type) {
	case int:
		if bv, ok := b.(int); ok { return av + bv }
		if bv, ok := b.(float64); ok { return float64(av) + bv }
	case float64:
		if bv, ok := b.(float64); ok { return av + bv }
		if bv, ok := b.(int); ok { return av + float64(bv) }
	case string:
		return av + rugo_to_string(b)
	}
	panic(fmt.Sprintf("cannot add %T and %T", a, b))
}

func rugo_sub(a, b interface{}) interface{} {
	switch av := a.(type) {
	case int:
		if bv, ok := b.(int); ok { return av - bv }
		if bv, ok := b.(float64); ok { return float64(av) - bv }
	case float64:
		if bv, ok := b.(float64); ok { return av - bv }
		if bv, ok := b.(int); ok { return av - float64(bv) }
	}
	panic(fmt.Sprintf("cannot subtract %T and %T", a, b))
}

func rugo_mul(a, b interface{}) interface{} {
	switch av := a.(type) {
	case int:
		if bv, ok := b.(int); ok { return av * bv }
		if bv, ok := b.(float64); ok { return float64(av) * bv }
	case float64:
		if bv, ok := b.(float64); ok { return av * bv }
		if bv, ok := b.(int); ok { return av * float64(bv) }
	}
	panic(fmt.Sprintf("cannot multiply %T and %T", a, b))
}

func rugo_div(a, b interface{}) interface{} {
	switch av := a.(type) {
	case int:
		if bv, ok := b.(int); ok { return av / bv }
		if bv, ok := b.(float64); ok { return float64(av) / bv }
	case float64:
		if bv, ok := b.(float64); ok { return av / bv }
		if bv, ok := b.(int); ok { return av / float64(bv) }
	}
	panic(fmt.Sprintf("cannot divide %T and %T", a, b))
}

func rugo_mod(a, b interface{}) interface{} {
	switch av := a.(type) {
	case int:
		if bv, ok := b.(int); ok { return av % bv }
		if bv, ok := b.(float64); ok { return math.Mod(float64(av), bv) }
	case float64:
		if bv, ok := b.(float64); ok { return math.Mod(av, bv) }
		if bv, ok := b.(int); ok { return math.Mod(av, float64(bv)) }
	}
	panic(fmt.Sprintf("cannot modulo %T and %T", a, b))
}

func rugo_negate(a interface{}) interface{} {
	switch av := a.(type) {
	case int:
		return -av
	case float64:
		return -av
	}
	panic(fmt.Sprintf("cannot negate %T", a))
}

func rugo_not(a interface{}) interface{} {
	return !rugo_to_bool(a)
}

func rugo_eq(a, b interface{}) interface{} {
	if rugo_is_numeric(a) && rugo_is_numeric(b) {
		return rugo_to_float(a) == rugo_to_float(b)
	}
	return reflect.DeepEqual(a, b)
}

func rugo_neq(a, b interface{}) interface{} {
	if rugo_is_numeric(a) && rugo_is_numeric(b) {
		return rugo_to_float(a) != rugo_to_float(b)
	}
	return !reflect.DeepEqual(a, b)
}

func rugo_lt(a, b interface{}) interface{} {
	if as, ok := a.(string); ok {
		if bs, ok := b.(string); ok {
			return as < bs
		}
	}
	return rugo_to_float(a) < rugo_to_float(b)
}

func rugo_gt(a, b interface{}) interface{} {
	if as, ok := a.(string); ok {
		if bs, ok := b.(string); ok {
			return as > bs
		}
	}
	return rugo_to_float(a) > rugo_to_float(b)
}

func rugo_le(a, b interface{}) interface{} {
	if as, ok := a.(string); ok {
		if bs, ok := b.(string); ok {
			return as <= bs
		}
	}
	return rugo_to_float(a) <= rugo_to_float(b)
}

func rugo_ge(a, b interface{}) interface{} {
	if as, ok := a.(string); ok {
		if bs, ok := b.(string); ok {
			return as >= bs
		}
	}
	return rugo_to_float(a) >= rugo_to_float(b)
}

// rugo_compare returns -1, 0, or 1 for sorting.
func rugo_compare(a, b interface{}) int {
	if as, ok := a.(string); ok {
		if bs, ok := b.(string); ok {
			if as < bs { return -1 }
			if as > bs { return 1 }
			return 0
		}
	}
	af, bf := rugo_to_float(a), rugo_to_float(b)
	if af < bf { return -1 }
	if af > bf { return 1 }
	return 0
}

func rugo_is_numeric(v interface{}) bool {
	switch v.(type) {
	case int, float64:
		return true
	}
	return false
}

func rugo_puts(args ...interface{}) interface{} {
	if len(args) == 1 {
		fmt.Println(rugo_to_string(args[0]))
		return nil
	}
	parts := make([]string, len(args))
	for i, a := range args {
		parts[i] = rugo_to_string(a)
	}
	fmt.Println(strings.Join(parts, " "))
	return nil
}

func rugo_print(args ...interface{}) interface{} {
	if len(args) == 1 {
		fmt.Print(rugo_to_string(args[0]))
		return nil
	}
	parts := make([]string, len(args))
	for i, a := range args {
		parts[i] = rugo_to_string(a)
	}
	fmt.Print(strings.Join(parts, " "))
	return nil
}

func rugo_raise(args ...interface{}) interface{} {
	if len(args) == 0 {
		panic("runtime error")
	}
	panic(rugo_to_string(args[0]))
}

func rugo_exit(args ...interface{}) interface{} {
	code := 0
	if len(args) > 0 {
		code = rugo_to_int(args[0])
	}
	os.Exit(code)
	return nil
}

func rugo_shell(args ...interface{}) interface{} {
	if len(args) == 0 { panic("shell requires at least one argument") }
	cmdStr := rugo_to_string(args[0])
	cmd := exec.Command("sh", "-c", cmdStr)
	cmd.Stdout = os.Stdout
	cmd.Stderr = os.Stderr
	cmd.Stdin = os.Stdin
	err := cmd.Run()
	if err != nil {
		if exitErr, ok := err.(*exec.ExitError); ok {
			panic(rugoShellError{code: exitErr.ExitCode(), cmd: cmdStr})
		}
		panic(fmt.Sprintf("shell failed: %v", err))
	}
	return 0
}

func rugo_capture(args ...interface{}) interface{} {
	if len(args) == 0 { panic("capture requires at least one argument") }
	cmdStr := rugo_to_string(args[0])
	cmd := exec.Command("sh", "-c", cmdStr)
	cmd.Stderr = os.Stderr
	out, err := cmd.Output()
	if err != nil {
		if exitErr, ok := err.(*exec.ExitError); ok {
			panic(rugoShellError{code: exitErr.ExitCode(), cmd: cmdStr})
		}
		panic(fmt.Sprintf("shell failed: %v", err))
	}
	return strings.TrimRight(string(out), "\n")
}

func rugo_pipe_shell(args ...interface{}) interface{} {
	if len(args) < 2 { panic("pipe_shell requires command and input arguments") }
	cmdStr := rugo_to_string(args[0])
	input := rugo_to_string(args[1])
	cmd := exec.Command("sh", "-c", cmdStr)
	cmd.Stdin = strings.NewReader(input)
	cmd.Stderr = os.Stderr
	out, err := cmd.Output()
	if err != nil {
		if exitErr, ok := err.(*exec.ExitError); ok {
			panic(rugoShellError{code: exitErr.ExitCode(), cmd: cmdStr})
		}
		panic(fmt.Sprintf("shell failed: %v", err))
	}
	return strings.TrimRight(string(out), "\n")
}

func rugo_len(args ...interface{}) interface{} {
	if len(args) == 0 { panic("len requires one argument") }
	switch v := args[0].(type) {
	case string:
		return utf8.RuneCountInString(v)
	case []byte:
		return len(v)
	case []interface{}:
		return len(v)
	case map[interface{}]interface{}:
		return len(v)
	}
	panic(fmt.Sprintf("cannot get length of %T", args[0]))
}

func rugo_type_of(args ...interface{}) interface{} {
	if len(args) == 0 { panic("type_of requires one argument") }
	v := args[0]
	switch v.(type) {
	case nil:
		return "Nil"
	case bool:
		return "Bool"
	case int:
		return "Integer"
	case float64:
		return "Float"
	case string:
		return "String"
	case []byte:
		return "Bytes"
	case []interface{}:
		return "Array"
	case map[interface{}]interface{}:
		m := v.(map[interface{}]interface{})
		if t, ok := m["__type__"]; ok {
			return t
		}
		return "Hash"
	case func(...interface{}) interface{}:
		return "Lambda"
	default:
		// Struct wrappers with DotGet support (Go bridge structs)
		if dg, ok := v.(interface{ DotGet(string) (interface{}, bool) }); ok {
			if t, ok := dg.DotGet("__type__"); ok {
				return t
			}
		}
		return "Unknown"
	}
}

func rugo_append(args ...interface{}) interface{} {
	if len(args) < 2 { panic("append requires array and value arguments") }
	arr, ok := args[0].([]interface{})
	if !ok { panic("first argument to append must be an array") }
	return append(arr, args[1])
}

type rugo_kv struct { Key, Val interface{} }

func rugo_iterable(v interface{}) []rugo_kv {
	switch c := v.(type) {
	case []interface{}:
		r := make([]rugo_kv, len(c))
		for i, v := range c { r[i] = rugo_kv{interface{}(i), v} }
		return r
	case map[interface{}]interface{}:
		r := make([]rugo_kv, 0, len(c))
		for k, v := range c { r = append(r, rugo_kv{k, v}) }
		return r
	case int:
		if c <= 0 { return nil }
		r := make([]rugo_kv, c)
		for i := 0; i < c; i++ { r[i] = rugo_kv{interface{}(i), interface{}(i)} }
		return r
	}
	panic(fmt.Sprintf("cannot iterate over %s", rugo_type_name(v)))
}

// rugo_iterable_default returns values for arrays and keys for hashes.
// Used by single-variable for..in loops: `for x in collection`
func rugo_iterable_default(v interface{}) []interface{} {
	switch c := v.(type) {
	case []interface{}:
		return c
	case map[interface{}]interface{}:
		r := make([]interface{}, 0, len(c))
		for k := range c { r = append(r, k) }
		return r
	case int:
		if c <= 0 { return nil }
		r := make([]interface{}, c)
		for i := 0; i < c; i++ { r[i] = i }
		return r
	}
	panic(fmt.Sprintf("cannot iterate over %s", rugo_type_name(v)))
}

// rugo_range returns a slice of integers [start, start+1, ..., end-1].
// With one arg: range(n) = [0, 1, ..., n-1].
// With two args: range(start, end) = [start, start+1, ..., end-1].
func rugo_range(args ...interface{}) []interface{} {
	var start, end int
	switch len(args) {
	case 1:
		end = rugo_to_int(args[0])
	case 2:
		start = rugo_to_int(args[0])
		end = rugo_to_int(args[1])
	default:
		panic("range expects 1 or 2 arguments")
	}
	if start >= end { return []interface{}{} }
	r := make([]interface{}, end-start)
	for i := start; i < end; i++ { r[i-start] = i }
	return r
}

func rugo_index_set(obj, idx, val interface{}) {
	switch o := obj.(type) {
	case []interface{}:
		i := rugo_to_int(idx)
		if i < 0 {
			i += len(o)
		}
		o[i] = val
	case map[interface{}]interface{}:
		o[idx] = val
	default:
		panic(fmt.Sprintf("cannot index-assign %T", obj))
	}
}

func rugo_array_index(arr []interface{}, idx int) interface{} {
	if idx < 0 {
		idx += len(arr)
	}
	return arr[idx]
}

func rugo_index(obj, idx interface{}) interface{} {
	switch o := obj.(type) {
	case []interface{}:
		return rugo_array_index(o, rugo_to_int(idx))
	case []byte:
		i := rugo_to_int(idx)
		if i < 0 { i += len(o) }
		return int(o[i])
	case map[interface{}]interface{}:
		return o[idx]
	default:
		panic(fmt.Sprintf("cannot index %T", o))
	}
}

func rugo_type_name(v interface{}) string {
	switch v.(type) {
	case nil:
		return "nil"
	case bool:
		return "bool"
	case int:
		return "int"
	case float64:
		return "float"
	case string:
		return "string"
	case []byte:
		return "bytes"
	case []interface{}:
		return "array"
	case map[interface{}]interface{}:
		return "hash"
	case func(...interface{}) interface{}:
		return "a function"
	default:
		return fmt.Sprintf("%T", v)
	}
}

func rugo_slice(obj, start, length interface{}) interface{} {
	s := rugo_to_int(start)
	l := rugo_to_int(length)
	if l < 0 {
		l = 0
	}
	switch v := obj.(type) {
	case string:
		runes := []rune(v)
		if s >= len(runes) {
			return interface{}("")
		}
		end := s + l
		if end > len(runes) {
			end = len(runes)
		}
		return interface{}(string(runes[s:end]))
	case []byte:
		if s >= len(v) {
			return interface{}([]byte{})
		}
		end := s + l
		if end > len(v) {
			end = len(v)
		}
		result := make([]byte, end-s)
		copy(result, v[s:end])
		return interface{}(result)
	case []interface{}:
		if s >= len(v) {
			return interface{}([]interface{}{})
		}
		end := s + l
		if end > len(v) {
			end = len(v)
		}
		result := make([]interface{}, end-s)
		copy(result, v[s:end])
		return interface{}(result)
	default:
		panic(fmt.Sprintf("cannot slice %s (expected string or array)", rugo_type_name(obj)))
	}
}

// rugo_bridge_err formats a Go bridge error with the Rugo function name,
// stripping the Go function name prefix if present.
func rugo_bridge_err(rugoName string, err error) string {
	msg := err.Error()
	// Go errors often start with "package.Function: ..." — strip it
	if idx := strings.Index(msg, ": "); idx > 0 {
		prefix := msg[:idx]
		// If the prefix looks like a Go function reference, strip it
		if strings.Contains(prefix, ".") && prefix[0] >= 'a' && prefix[0] <= 'z' {
			msg = msg[idx+2:]
		}
	}
	return fmt.Sprintf("%s: %s", rugoName, msg)
}

