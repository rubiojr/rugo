use "test"
use "eval"

# --- Happy path tests ---

rats "pipe: shell to function"
  source = <<~RUGO
    echo "hello from pipe" | puts
  RUGO
  result = eval.run(source)
  test.assert_eq(result["status"], 0)
  test.assert_eq(result["output"], "hello from pipe")
end

rats "pipe: shell output prepended as first arg"
  source = <<~RUGO
    echo "world" | puts "hello"
  RUGO
  result = eval.run(source)
  test.assert_eq(result["status"], 0)
  test.assert_eq(result["output"], "world hello")
end

rats "pipe: chain shell → module → builtin"
  source = <<~RUGO
    use "str"
    echo "hello world" | str.upper | puts
  RUGO
  result = eval.run(source)
  test.assert_eq(result["status"], 0)
  test.assert_eq(result["output"], "HELLO WORLD")
end

rats "pipe: assignment with pipe"
  source = <<~RUGO
    use "str"
    x = echo "hello" | str.upper
    puts x
  RUGO
  result = eval.run(source)
  test.assert_eq(result["status"], 0)
  test.assert_eq(result["output"], "HELLO")
end

rats "pipe: expression to function"
  source = <<~RUGO
    len("hello") | puts
  RUGO
  result = eval.run(source)
  test.assert_eq(result["status"], 0)
  test.assert_eq(result["output"], "5")
end

rats "pipe: value piped to shell stdin"
  source = <<~RUGO
    "hello world" | tr a-z A-Z | puts
  RUGO
  result = eval.run(source)
  test.assert_eq(result["status"], 0)
  test.assert_eq(result["output"], "HELLO WORLD")
end

rats "pipe: user-defined function in chain"
  source = <<~RUGO
    def double(x)
      return x + " " + x
    end

    echo "hello" | double | puts
  RUGO
  result = eval.run(source)
  test.assert_eq(result["status"], 0)
  test.assert_eq(result["output"], "hello hello")
end

rats "pipe: shell-to-shell backward compat"
  source = <<~RUGO
    echo "hello world" | tr a-z A-Z
  RUGO
  result = eval.run(source)
  test.assert_eq(result["status"], 0)
  test.assert_eq(result["output"], "HELLO WORLD")
end

rats "pipe: || (logical OR) not confused with |"
  source = <<~RUGO
    x = true || false
    puts x
    y = false || true
    puts y
  RUGO
  result = eval.run(source)
  test.assert_eq(result["status"], 0)
  test.assert_contains(result["output"], "true")
end

rats "pipe: try/or with piped expression"
  source = <<~RUGO
    x = try nonexistent_cmd_xyz | puts or "caught"
    puts x
  RUGO
  result = eval.run(source)
  test.assert_eq(result["status"], 0)
  test.assert_contains(result["output"], "caught")
end

rats "pipe: inside function body"
  source = <<~RUGO
    def process()
      echo "from function" | puts
    end

    process()
  RUGO
  result = eval.run(source)
  test.assert_eq(result["status"], 0)
  test.assert_eq(result["output"], "from function")
end

rats "pipe: | inside strings not treated as pipe"
  source = <<~RUGO
    puts "a | b"
    puts "one|two|three"
  RUGO
  result = eval.run(source)
  test.assert_eq(result["status"], 0)
  test.assert_contains(result["output"], "a | b")
  test.assert_contains(result["output"], "one|two|three")
end

rats "pipe: native binary with pipes"
  source = <<~RUGO
    echo "hello binary" | puts
  RUGO
  script = test.tmpdir() + "/pipe_binary.rugo"
  bin = test.tmpdir() + "/rugo_pipe_binary"
  test.write_file(script, source)
  result = test.run("rugo build " + script + " -o " + bin)
  test.assert_eq(result["status"], 0)
  result = test.run(bin)
  test.assert_eq(result["status"], 0)
  test.assert_eq(result["output"], "hello binary")
end

rats "pipe: puts/print in mid-chain is compile error"
  source = <<~RUGO
    ls -la | puts | head -n1
  RUGO
  result = eval.run(source)
  test.assert_neq(result["status"], 0)
  test.assert_contains(result["output"], "puts")
  test.assert_contains(result["output"], "returns nil")
end
