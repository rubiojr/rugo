# Go Bridge — Developer Reference

The Go Bridge allows Rugo scripts to call Go standard library functions
directly via the `import` keyword. Bridge packages are auto-generated by
`rugo dev bridgegen` and hand-curated where needed.

## Architecture

```
Rugo source:    import "strings"
                x = strings.to_upper("hello")
                    │
                    ▼
Compiler:       resolveRequires() validates package is registered
                    │
                    ▼
Codegen:        generateGoBridgeCall() produces:
                  interface{}(strings.ToUpper(rugo_to_string(x)))
                    │
                    ▼
Generated Go:   Direct Go stdlib call — no wrapper struct, no runtime
```

### File Convention

| Pattern | Role |
|---------|------|
| `*_gen.go` | Auto-generated by `rugo dev bridgegen`. Always overwritten. |
| `*_custom.go` | Hand-written. Uses `Extend()` for aliases, `Codegen` callbacks, runtime helpers. Never touched by bridgegen. |
| `helpers/*.go` | Runtime helper source files (real Go, `//go:build ignore`). Embedded via `//go:embed` — no string literals. |
| `gobridge.go` | Core types, registry API, conversion helpers. |
| `helpers_embed.go` | `//go:embed` directives loading helper source files. |
| `source_embed.go` | Embeds all `.go` files for the Rugo build cache. |

### Key Compiler Files

| File | Role |
|------|------|
| `compiler/compiler.go` | `resolveRequires()` — validates + deduplicates `import` statements |
| `compiler/codegen.go` | `generateGoBridgeCall()` — emits Go code with type conversions |
| `cmd/dev/bridgegen.go` | `rugo dev bridgegen` — auto-generates bridge packages via `go/types` |
| `ast/preprocess.go` | `import` keyword + array destructuring desugaring |
| `parser/rugo.ebnf` | Grammar: `ImportStmt = "import" str_lit ["as" ident] .` |

### `use` vs `import`

| | `use` (Rugo modules) | `import` (Go bridge) |
|--|---|---|
| **Mechanism** | Hand-crafted Go structs, embedded as runtime strings | Static registry → direct Go function calls |
| **Generated code** | `rugo_mod_func(arg1, arg2)` wrapper | `strings.ToUpper(rugo_to_string(arg))` direct call |
| **Adding functions** | Write Go struct + methods in `runtime.go` | Run `rugo dev bridgegen <pkg>` or add to `_custom.go` |

## Type System

All Rugo values are `interface{}`. The bridge converts at call boundaries:

```go
GoString      // string ↔ string       — rugo_to_string(arg)
GoInt         // int ↔ int             — rugo_to_int(arg)
GoFloat64     // float ↔ float64       — rugo_to_float(arg)
GoBool        // bool ↔ bool           — rugo_to_bool(arg)
GoByte        // int ↔ byte            — byte(rugo_to_int(arg))
GoStringSlice // array ↔ []string      — rugo_go_to_string_slice(arg)
GoByteSlice   // string/array ↔ []byte   — rugo_to_byte_slice(arg)
GoInt32       // int ↔ int32           — int32(rugo_to_int(arg))
GoInt64       // int ↔ int64           — int64(rugo_to_int(arg))
GoUint32      // int ↔ uint32          — uint32(rugo_to_int(arg))
GoUint64      // int ↔ uint64          — uint64(rugo_to_int(arg))
GoUint        // int ↔ uint            — uint(rugo_to_int(arg))
GoFloat32     // float ↔ float32       — float32(rugo_to_float(arg))
GoRune        // string ↔ rune         — rugo_first_rune(rugo_to_string(arg))
GoFunc        // lambda ↔ func(T)R     — adapter wrapping (see FuncTypes)
GoDuration    // int (ms) ↔ Duration   — time.Duration(n) * time.Millisecond
GoError       // panic ↔ error         — return-only, auto-panics on non-nil
```

Return conversions wrap Go values back to `interface{}`:
- Most types: `interface{}(goValue)`
- Narrowing types (int32, int64, uint*, float32): cast back to `int` or `float64`
- `GoByteSlice`: `string(goValue)` — bytes are strings in Rugo; Rugo arrays of ints also convert to `[]byte`
- `GoRune`: `string(r)` with zero-rune → empty string
- `GoDuration`: `int(d / time.Millisecond)` — always milliseconds
- `GoStringSlice`: `rugo_go_from_string_slice(v)` → `[]interface{}`

## Function Signature

Each bridged function is described by `GoFuncSig`:

```go
type GoFuncSig struct {
    GoName       string              // PascalCase name or method chain ("StdEncoding.EncodeToString")
    Params       []GoType
    Returns      []GoType
    FuncTypes    map[int]*GoFuncType  // lambda adapter signatures for GoFunc params
    StructReturn *GoStructReturn      // struct → hash decomposition metadata
    ArrayTypes   map[int]*GoArrayType // fixed-size array [N]T → slice metadata
    TypeCasts    map[int]string       // named type casts ("os.FileMode")
    Variadic     bool
    Doc          string
    Codegen      CodegenFunc          // override for custom code generation
    RuntimeHelpers []RuntimeHelper    // Go helper functions to emit
}
```

### Return Pattern Handling

| Pattern | Codegen strategy |
|---------|-----------------|
| `()` void | IIFE: `func() interface{} { call; return nil }()` |
| `(T)` | `interface{}(call)` |
| `(error)` | IIFE with panic on non-nil error |
| `(T, error)` | IIFE: panic on error, return T |
| `(T, bool)` | IIFE: return nil if false, T if true |
| `(T1, T2, ...)` | IIFE: collect into `[]interface{}` array |

Multi-return functions return arrays that can be destructured:

```ruby
before, after, found = strings.cut("key=value", "=")
```

### Metadata Features

**FuncTypes** — Lambda-to-Go-func adapter. When a param is `GoFunc`, the
`FuncTypes` map describes the Go function signature so the codegen can wrap
a Rugo lambda:

```go
"contains_func": {Params: []GoType{GoString, GoFunc}, Returns: []GoType{GoBool},
    FuncTypes: map[int]*GoFuncType{1: {Params: []GoType{GoRune}, Returns: []GoType{GoBool}}}}
```

**StructReturn** — Declarative struct-to-hash decomposition:

```go
"parse": {Params: []GoType{GoString}, Returns: []GoType{GoString, GoError},
    StructReturn: &GoStructReturn{Pointer: true, Fields: []GoStructField{
        {GoField: "Scheme", RugoKey: "scheme", Type: GoString},
        {GoField: "Hostname", RugoKey: "hostname", Type: GoString, IsMethod: true},
    }}}
```

**ArrayTypes** — Fixed-size array returns. Codegen slices `[N]T → []T`:

```go
"sum256": {Params: []GoType{GoByteSlice}, Returns: []GoType{GoByteSlice},
    ArrayTypes: map[int]*GoArrayType{0: {Elem: GoByte, Size: 32}}}
```

**Output-buffer auto-wrapping** — Functions where the first param is a
write-destination `[]byte` and a companion sizing function exists (e.g.,
`EncodedLen`) are auto-wrapped during introspection. The `dst` param is
removed from the Rugo signature and auto-allocated internally:

```
Go:   hex.Encode(dst, src []byte) int
Rugo: hex.encode(src) → allocates dst via EncodedLen, returns string(dst)

Go:   hex.Decode(dst, src []byte) (int, error)
Rugo: hex.decode(src) → allocates dst via DecodedLen, returns string(dst[:n])
```

**TypeCasts** — Named Go type casts for params:

```go
"mkdir_all": {Params: []GoType{GoString, GoInt}, Returns: []GoType{GoError},
    TypeCasts: map[int]string{1: "os.FileMode"}}
```

## Adding a New Go Package

### Automated (recommended)

```bash
rugo dev bridgegen <go-package>     # generates _gen.go + smoke tests
make bridgegen                       # regenerate all packages
```

This generates `gobridge/<pkg>_gen.go` with all auto-bridgeable functions
and `rats/gobridge/auto/<pkg>_gen_test.rugo` with smoke tests.

### Adding custom functions

Create `gobridge/<pkg>_custom.go` using `Extend()`:

```go
package gobridge

func init() {
    Extend("encoding/hex", map[string]GoFuncSig{
        "encode": {GoName: "EncodeToString", Params: []GoType{GoByteSlice},
                   Returns: []GoType{GoString}, Doc: "Encodes to hex."},
    })
}
```

`Extend()` merges into the package registered by `_gen.go`. Init order is
handled automatically — either file can load first.

### Runtime helpers

For packages needing custom Go helper functions (generics workarounds, deep
type conversion), write the helpers as real Go files in `gobridge/helpers/`:

```go
//go:build ignore

package helpers

func rugo_my_helper(v interface{}) interface{} {
    // implementation
}
```

Embed in `helpers_embed.go` and reference from `_custom.go`:

```go
var myHelpers = []RuntimeHelper{helperFromFile("rugo_my_helpers", myHelperSrc)}
```

Helpers are deduplicated by key and emitted once into generated code.
Core helpers (`rugo_first_rune`, `rugo_go_to_string_slice`) are auto-emitted
when the corresponding GoType is used — no RuntimeHelpers declaration needed.

### Packages using NoGoImport

For packages implemented entirely via runtime helpers (Go generics, etc.):

```go
Register(&Package{
    Path:         "slices",
    NoGoImport:   true,
    ExtraImports: []string{"sort"},
    Funcs: map[string]GoFuncSig{ ... },
})
```

### Verifying codegen

```bash
echo 'import "strings"
puts strings.to_upper("hello")' > /tmp/test.rugo
bin/rugo emit /tmp/test.rugo
```

## Bridgegen Classification

`rugo dev bridgegen --dry-run <pkg>` classifies each function:

| Tier | Meaning | Marker |
|------|---------|--------|
| auto | All params/returns are basic Go types | ✓ |
| castable | Needs numeric casts, []byte, rune, func adapters | ~ |
| func | Has function params with unbridgeable inner signatures | λ |
| blocked | Generics, interfaces, channels, complex structs | ✗ |

Bridgegen generates code for `auto` and `castable` tiers. `func` tier is
generated when the inner function signature is bridgeable (emits `FuncTypes`).
`blocked` functions are listed as comments in the generated file.

The classifier also enumerates methods on exported package-level variables
(e.g., `base64.StdEncoding.EncodeToString`), using dot-notation GoNames.

## Custom Codegen Catalog

These packages require `_custom.go` with `Codegen` callbacks:

| Package | Reason |
|---------|--------|
| `encoding/json` | Deep `map[interface{}]interface{}` ↔ `map[string]interface{}` recursive conversion |
| `slices` | Go generics — pure runtime helpers, `NoGoImport` |
| `maps` | Go generics — pure runtime helpers, `NoGoImport` |
| `sort` | In-place mutation via `sort.Slice` + `rugo_compare` |

Convenience aliases (curated short names) in `_custom.go`:

| Package | Alias | Maps to |
|---------|-------|---------|
| `encoding/base64` | `encode` | `StdEncoding.EncodeToString` |
| `encoding/base64` | `decode` | `StdEncoding.DecodeString` |
| `encoding/base64` | `url_encode` | `URLEncoding.EncodeToString` |
| `encoding/base64` | `url_decode` | `URLEncoding.DecodeString` |
| `encoding/hex` | `encode` | `EncodeToString` |
| `encoding/hex` | `decode` | `DecodeString` |
| `math/rand/v2` | `n` | `IntN` |

## Import Deduplication

The codegen tracks `emittedImports` to prevent duplicate Go import statements:

1. **Base imports** always emitted: `fmt`, `os`, `os/exec`, `runtime/debug`, `strings`
2. **Rugo module imports** (from `use`): e.g., `use "conv"` adds `strconv`
3. **Go bridge imports** (from `import`): added last, skipped if already emitted
4. **Aliased imports**: always emitted even if the bare path exists

## Namespace Conflict Detection

| Conflict | Error |
|----------|-------|
| `use "os"` + `import "os"` | Must alias: `import "os" as go_os` |
| `require "x" as "os"` + `use "os"` | Require alias conflicts with use'd module |
| `require "x" as "strings"` + `import "strings"` | Require alias conflicts with Go bridge |

## Test Coverage

Tests are split into hand-written and auto-generated:

- `rats/gobridge/*.rugo` — Hand-written behavioral tests (175 tests)
- `rats/gobridge/auto/*_gen_test.rugo` — Auto-generated smoke tests (291 tests)

Auto-generated tests verify every function is callable with correct arg
types and returns the expected Rugo type. They are regenerated by
`make bridgegen` alongside the bridge code.

Run all: `make rats` or `bin/rugo rats rats/gobridge/`

## External Module Struct Support

When a `require`'d Go module exports struct types with bridgeable field types,
the compiler auto-generates wrapper structs with `DotGet`/`DotSet`/`DotCall`
methods. No reflect is used — all access is via compile-time generated switch
dispatch.

### Wrapper Architecture

For each discovered struct (e.g., `Config` in namespace `mymod`):

```go
type rugo_struct_mymod_Config struct{ v *mymod.Config }

func (w *rugo_struct_mymod_Config) DotGet(field string) (interface{}, bool) {
    switch field {
    case "name":     return interface{}(w.v.Name), true
    case "port":     return interface{}(w.v.Port), true
    case "__type__": return "Config", true
    }
    return nil, false
}

func (w *rugo_struct_mymod_Config) DotSet(field string, val interface{}) bool {
    switch field {
    case "name": w.v.Name = rugo_to_string(val); return true
    case "port": w.v.Port = rugo_to_int(val); return true
    }
    return false
}
```

### How It Works

1. **Inspector discovers structs** — `InspectSourcePackage` scans for exported
   struct types and classifies their fields
2. **FinalizeStructs** — called by the compiler with the resolved namespace;
   generates wrapper `RuntimeHelper`s, registers constructors, discovers methods,
   discovers embedded struct fields, and reclassifies previously-blocked functions
3. **Auto-upcast** — struct params use `rugo_upcast_<wrapType>(arg).v` which
   walks the embedded field chain if a direct type assertion fails, enabling
   derived types to be passed where base types are expected
4. **Runtime** — `rugo_dot_get`/`rugo_dot_set`/`rugo_dot_call` check the
   `DotGet`/`DotSet`/`DotCall` interfaces respectively

### Embedded Struct Fields

Both in-package and external struct wrappers discover embedded pointer-to-struct
fields. These appear in `DotGet` and enable hierarchy navigation:

```ruby
# QPushButton embeds *QAbstractButton which embeds *QWidget
btn.qabstract_button.qwidget    # manual chain (always works)
layout.add_widget(btn)           # auto-upcast (walks chain automatically)
```

Wrappers with embedded fields also implement `DotEnumFields() []string` to
support the auto-upcast walker.

### GoFuncSig Metadata

Reclassified functions use these fields on `GoFuncSig`:

```go
StructCasts       map[int]string  // param index → wrapper type name
StructReturnWraps map[int]string  // return index → wrapper type name
```

### Files

| File | Role |
|------|------|
| `gobridge/struct_wrap.go` | `GenerateStructWrapper()`, `GenerateUpcastHelper()` |
| `gobridge/inspect.go` | `classifyStructFields()`, `FinalizeStructs()`, `reclassifyWithStructs()`, `discoverEmbeddedFields()` |
| `compiler/codegen.go` | `StructCasts`/`StructReturnWraps` handling in `generateGoBridgeCall()` |
| `compiler/templates/runtime_core_post.go.tmpl` | `DotGet`/`DotSet`/`DotCall` interface dispatch |

## External Dependency Type Support

When a `require`'d Go module uses types from external dependencies (e.g.,
`*bytes.Buffer`, `*qt6.QWidget`), the compiler automatically discovers and
wraps those types as full opaque handles — with methods, signals, embedded
field navigation, and auto-upcasting.

### Discovery

1. **Direct types** — `FinalizeStructs` scans blocked function signatures for
   `*Named` pointer types from external packages
2. **Recursive hierarchy** — Embedded fields of discovered types are walked
   recursively to find intermediate types (e.g., `QPushButton` → `*QAbstractButton`
   → `*QWidget` → `*QObject`)
3. **Module-aware importer** — External types are resolved via `go list -export`
   which handles Go module dependencies in the module cache

### What Gets Generated

For each external type, a full wrapper is generated:

- **DotGet** — `__type__` + embedded struct fields (with opaque handle wrapping)
- **DotSet** — no-op (external fields not writable)
- **DotCall** — all bridgeable methods, including:
  - Methods with `GoFunc` params (signal connections via Rugo lambdas)
  - Named type casts for enum params (e.g., `qt6.GestureType`)
  - Named type casts for narrowing basic types (`int8`, `int16`, `uint16`)
  - Value-type struct params (auto-dereference)
- **DotEnumFields** — lists embedded fields for auto-upcast walking

### Auto-Upcasting

When a method expects `*QWidget` but receives a `*QPushButton`, the bridge
auto-extracts the base type by walking the embedded field chain:

```go
func rugo_upcast_rugo_struct_qt6_QWidget(v interface{}) *rugo_struct_qt6_QWidget {
    if w, ok := v.(*rugo_struct_qt6_QWidget); ok { return w }  // fast path
    // walk DotGet/DotEnumFields recursively to find QWidget
}
```

This enables natural usage without manual type navigation:

```ruby
layout.add_widget(btn)    # QPushButton auto-upcasts to QWidget
```

### GoFunc in DotCall

Methods accepting function parameters work with Rugo lambdas:

```ruby
btn.on_clicked(fn()
  lbl.set_text("Clicked!")
end)
```

The `FuncAdapterConv` generates typed Go adapters, handling:
- Named param types (e.g., `func(qt6.ApplicationState)` not `func(int)`)
- Named return types (e.g., `func() qt6.Orientation`)
- Void callbacks (no `return` statement)

### Warnings

Bridge warnings about unbridgeable functions (e.g., `unsafe.Pointer` params)
are hidden by default. Use `--show-warnings` on `rugo build` or `rugo run`
to see them.

### Example: Qt6 GUI with zero Go wrapper code

```ruby
require "/path/to/miqt/qt6" as qt6
import "os"
use "conv"

qt = {
  app:    fn() qt6.new_qapplication(os.args()) end,
  exec:   fn() qt6.qapplication_exec() end,
  quit:   fn() qt6.qcore_application_quit() end,
  window: fn() qt6.new_qwidget2() end,
  button: fn(text) qt6.new_qpush_button3(text) end,
  label:  fn(text) qt6.new_qlabel3(text) end,
  vbox:   fn(parent) qt6.new_qvbox_layout(parent) end
}

app = qt.app()
win = qt.window()
win.set_window_title("Hello from Rugo!")
win.resize(320, 200)

layout = qt.vbox(win)
lbl = qt.label("Click count: 0")
layout.add_widget(lbl)           # auto-upcast: QLabel → QWidget

count = 0
btn = qt.button("Click Me")
btn.on_clicked(fn()              # signal via DotCall + GoFunc
  count = count + 1
  lbl.set_text("Click count: " + conv.to_s(count))
end)
layout.add_widget(btn)           # auto-upcast: QPushButton → QWidget

win.show()
qt.exec()
```

This bridges 3600+ functions, 600+ struct types, and hundreds of methods per
type — all auto-discovered from the miqt Go package with no adapter code.

### Files

| File | Role |
|------|------|
| `gobridge/gobridge.go` | `ExternalTypeInfo`, `GoFuncType.TypeCasts`, `GoStructMethodInfo.FuncTypes` |
| `gobridge/struct_wrap.go` | `GenerateExternalOpaqueWrapper()`, `GenerateUpcastHelper()` |
| `gobridge/inspect.go` | `discoverExternalTypes()`, `discoverEmbeddedFields()`, `discoverMethods()`, `moduleAwareImporter()` |
| `gobridge/classify.go` | `ClassifyFuncType()` with named type detection |
| `compiler/codegen.go` | `ExtraImports` emission for external dependency packages |
| `compiler/compiler.go` | `ShowWarnings` flag, post-`FinalizeStructs` validation |
