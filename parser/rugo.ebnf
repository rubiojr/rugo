# Rugo Language Grammar (LL(1))
# A minimal Ruby-inspired language that transpiles to Go.

# Entry point
# ';' is a statement separator injected by the preprocessor to disambiguate
# array literals on new lines from index suffix operations (e.g. expr\n[1,2,3]).
# Users should not write ';' directly â€” the preprocessor rejects it.
Program     = { Statement | ';' } .

# Statements
Statement   = UseStmt
            | ImportStmt
            | RequireStmt
            | SandboxStmt
            | FuncDef
            | TestDef
            | BenchDef
            | IfStmt
            | WhileStmt
            | ForStmt
            | BreakStmt
            | NextStmt
            | ReturnStmt
            | AssignOrExpr .

UseStmt     = "use" str_lit .
ImportStmt  = "import" str_lit [ "as" ident ] .
RequireStmt = "require" str_lit [ "as" ( str_lit | ident ) | "with" ident { ',' ident } ] .
SandboxStmt = "sandbox" [ SandboxPerm { ',' SandboxPerm } ] .
SandboxPerm = ident ':' ( str_lit | integer | SandboxList ) .
SandboxList = '[' ( str_lit | integer ) { ',' ( str_lit | integer ) } ']' .
FuncDef     = "def" ident '(' [ ParamList ] ')' Body "end" .
TestDef     = "rats" str_lit Body "end" .
BenchDef    = "bench" str_lit Body "end" .
ParamList   = ident { ',' ident } .
Body        = { Statement | ';' } .
IfStmt      = "if" Expr Body { "elsif" Expr Body } [ "else" Body ] "end" .
WhileStmt   = "while" Expr Body "end" .
ForStmt     = "for" ident [ ',' ident ] "in" Expr Body "end" .
BreakStmt   = "break" .
NextStmt    = "next" .
ReturnStmt  = "return" [ Expr ] .
AssignOrExpr = Expr [ '=' Expr ] .

# Expressions (lowest to highest precedence)
Expr        = OrExpr .
OrExpr      = AndExpr { "||" AndExpr } .
AndExpr     = CompExpr { "&&" CompExpr } .
CompExpr    = AddExpr [ comp_op AddExpr ] .
AddExpr     = MulExpr { ('+' | '-') MulExpr } .
MulExpr     = UnaryExpr { ('*' | '/' | '%') UnaryExpr } .
UnaryExpr   = '!' Postfix | '-' Postfix | Postfix .
Postfix     = Primary { Suffix } .
Suffix      = '(' [ ArgList ] ')' | '[' Expr [ ',' Expr ] ']' | '.' ident .
ArgList     = Expr { ',' Expr } .

# Primary expressions
Primary     = ident
            | integer
            | float_lit
            | str_lit
            | raw_str_lit
            | "true"
            | "false"
            | "nil"
            | ArrayLit
            | HashLit
            | TryExpr
            | SpawnExpr
            | ParallelExpr
            | FnExpr
            | '(' Expr ')' .

TryExpr      = "try" Expr "or" ident Body "end" .
SpawnExpr    = "spawn" Body "end" .
ParallelExpr = "parallel" Body "end" .
FnExpr       = "fn" '(' [ ParamList ] ')' Body "end" .

ArrayLit    = '[' [ Expr { ',' Expr } ] ']' .
HashLit     = '{' [ HashEntry { ',' HashEntry } ] '}' .
HashEntry   = Expr "=>" Expr .

# Lexical tokens (lowercase = terminal)
comp_op     = "==" | "!=" | "<=" | ">=" | '<' | '>' .
ident       = `[a-zA-Z_][a-zA-Z0-9_]*` .
integer     = `[0-9]+` .
float_lit   = `[0-9]+\.[0-9]+` .
str_lit     = '"' { `[^"\\]` | '\\' `[^\n]` } '"' .
raw_str_lit = "'" { `[^'\\]` | "\\" `[^\n]` } "'" .
white_space = ` |\t|\n|\r` .
