func rugo_panic_handler(e interface{}) {
	// Parse debug.Stack() to find the Rugo source location
	stack := string(debug.Stack())
	file := ""
	line := ""
	// Find Rugo frames after the panic() frame (skip recovery frames)
	lines := strings.Split(stack, "\n")
	pastPanic := false
	for _, s := range lines {
		if strings.Contains(s, "panic(") { pastPanic = true; continue }
		if !pastPanic { continue }
		s = strings.TrimSpace(s)
		// Check for .rugo: first (preferred), then .rg: (deprecated)
		if idx := strings.Index(s, ".rugo:"); idx >= 0 {
			rest := s[idx+6:]
			lineEnd := strings.IndexAny(rest, " +")
			if lineEnd < 0 { lineEnd = len(rest) }
			line = rest[:lineEnd]
			file = s[:idx+5]
			break
		}
		if idx := strings.Index(s, ".rg:"); idx >= 0 {
			rest := s[idx+4:]
			lineEnd := strings.IndexAny(rest, " +")
			if lineEnd < 0 { lineEnd = len(rest) }
			line = rest[:lineEnd]
			file = s[:idx+3]
			break
		}
	}
	msg := rugo_friendly_error(fmt.Sprintf("%v", e))
	if file != "" && line != "" {
		fmt.Fprintf(os.Stderr, "error: %s (%s:%s)\n", msg, file, line)
	} else {
		fmt.Fprintf(os.Stderr, "error: %s\n", msg)
	}
	os.Exit(1)
}

// rugo_friendly_error translates raw Go runtime messages to human-friendly ones.
func rugo_friendly_error(msg string) string {
	// "runtime error: index out of range [N] with length M"
	if strings.HasPrefix(msg, "runtime error: index out of range [") {
		rest := msg[len("runtime error: index out of range ["):]
		if bracket := strings.Index(rest, "]"); bracket >= 0 {
			idx := rest[:bracket]
			rest = rest[bracket+1:]
			if strings.HasPrefix(rest, " with length ") {
				length := strings.TrimPrefix(rest, " with length ")
				return fmt.Sprintf("index %s out of bounds (length %s)", idx, length)
			}
		}
	}
	// "runtime error: ..."
	if strings.HasPrefix(msg, "runtime error: ") {
		return strings.TrimPrefix(msg, "runtime error: ")
	}
	return msg
}

func rugo_dot_get(obj interface{}, field string) interface{} {
	// Task-like objects: check for field accessor interface
	if fa, ok := obj.(interface{ DotGet(string) (interface{}, bool) }); ok {
		if val, handled := fa.DotGet(field); handled {
			return val
		}
	}
	if m, ok := obj.(map[interface{}]interface{}); ok {
		return m[field]
	}
	panic(fmt.Sprintf("cannot access .%s on %s — expected a hash/struct", field, rugo_type_label(obj)))
}

func rugo_dot_set(obj interface{}, field string, val interface{}) {
	// Struct wrappers: check for DotSet interface
	if ds, ok := obj.(interface{ DotSet(string, interface{}) bool }); ok {
		if ds.DotSet(field, val) {
			return
		}
	}
	if m, ok := obj.(map[interface{}]interface{}); ok {
		m[field] = val
		return
	}
	panic(fmt.Sprintf("cannot set .%s on %s — expected a hash/struct", field, rugo_type_label(obj)))
}

// rugo_dot_call dispatches a method call on any object implementing the DotCall interface.
// It also supports built-in methods on arrays and hashes, and calling lambdas stored
// as hash values via dot access (e.g. record.save()).
func rugo_dot_call(obj interface{}, method string, args ...interface{}) interface{} {
	// 1. DotCall interface (Queue, Task, etc.)
	if dc, ok := obj.(interface {
		DotCall(string, ...interface{}) (interface{}, bool)
	}); ok {
		if result, handled := dc.DotCall(method, args...); handled {
			return result
		}
	}
	// 2. Built-in array methods
	if arr, ok := obj.([]interface{}); ok {
		if result, handled := rugo_array_method(arr, method, args...); handled {
			return result
		}
	}
	// 3. Built-in hash methods (checked before hash-key-as-lambda)
	if m, ok := obj.(map[interface{}]interface{}); ok {
		if result, handled := rugo_hash_method(m, method, args...); handled {
			return result
		}
		// 4. Hash key lookup fallback (lambdas stored in hashes)
		val, exists := m[method]
		if !exists {
			panic(fmt.Sprintf("undefined method .%s() — key %q not found in hash", method, method))
		}
		if fn, ok := val.(func(...interface{}) interface{}); ok {
			return fn(args...)
		}
		panic(fmt.Sprintf("cannot call .%s() — value is %T, not a function", method, val))
	}
	panic(fmt.Sprintf("undefined method .%s() on %s", method, rugo_type_label(obj)))
}

// rugo_type_label returns a user-friendly type name for error messages.
func rugo_type_label(obj interface{}) string {
	if dg, ok := obj.(interface{ DotGet(string) (interface{}, bool) }); ok {
		if t, ok := dg.DotGet("__type__"); ok {
			if s, ok := t.(string); ok {
				return s
			}
		}
	}
	return fmt.Sprintf("%T", obj)
}

// rugo_to_lambda extracts a lambda from an interface{} value.
func rugo_to_lambda(v interface{}, method string) func(...interface{}) interface{} {
	fn, ok := v.(func(...interface{}) interface{})
	if !ok {
		panic(fmt.Sprintf(".%s() requires a function argument, got %T", method, v))
	}
	return fn
}

// --- Built-in Array Methods ---

func rugo_array_method(arr []interface{}, method string, args ...interface{}) (interface{}, bool) {
	switch method {
	case "map":
		fn := rugo_to_lambda(args[0], "map")
		result := make([]interface{}, len(arr))
		for i, v := range arr {
			result[i] = fn(v)
		}
		return interface{}(result), true

	case "filter":
		fn := rugo_to_lambda(args[0], "filter")
		result := make([]interface{}, 0)
		for _, v := range arr {
			if rugo_to_bool(fn(v)) {
				result = append(result, v)
			}
		}
		return interface{}(result), true

	case "reject":
		fn := rugo_to_lambda(args[0], "reject")
		result := make([]interface{}, 0)
		for _, v := range arr {
			if !rugo_to_bool(fn(v)) {
				result = append(result, v)
			}
		}
		return interface{}(result), true

	case "each":
		fn := rugo_to_lambda(args[0], "each")
		for _, v := range arr {
			fn(v)
		}
		return nil, true

	case "reduce":
		if len(args) < 2 {
			panic(".reduce() requires an initial value and a function")
		}
		acc := args[0]
		fn := rugo_to_lambda(args[1], "reduce")
		for _, v := range arr {
			acc = fn(acc, v)
		}
		return acc, true

	case "find":
		fn := rugo_to_lambda(args[0], "find")
		for _, v := range arr {
			if rugo_to_bool(fn(v)) {
				return v, true
			}
		}
		return nil, true

	case "any":
		fn := rugo_to_lambda(args[0], "any")
		for _, v := range arr {
			if rugo_to_bool(fn(v)) {
				return true, true
			}
		}
		return false, true

	case "all":
		fn := rugo_to_lambda(args[0], "all")
		for _, v := range arr {
			if !rugo_to_bool(fn(v)) {
				return false, true
			}
		}
		return true, true

	case "count":
		fn := rugo_to_lambda(args[0], "count")
		n := 0
		for _, v := range arr {
			if rugo_to_bool(fn(v)) {
				n++
			}
		}
		return n, true

	case "join":
		sep := ""
		if len(args) > 0 {
			sep = rugo_to_string(args[0])
		}
		parts := make([]string, len(arr))
		for i, v := range arr {
			parts[i] = rugo_to_string(v)
		}
		return strings.Join(parts, sep), true

	case "first":
		if len(arr) == 0 {
			return nil, true
		}
		return arr[0], true

	case "last":
		if len(arr) == 0 {
			return nil, true
		}
		return arr[len(arr)-1], true

	case "min":
		if len(arr) == 0 {
			return nil, true
		}
		best := arr[0]
		for _, v := range arr[1:] {
			if rugo_compare(v, best) < 0 {
				best = v
			}
		}
		return best, true

	case "max":
		if len(arr) == 0 {
			return nil, true
		}
		best := arr[0]
		for _, v := range arr[1:] {
			if rugo_compare(v, best) > 0 {
				best = v
			}
		}
		return best, true

	case "sum":
		var result interface{} = 0
		for _, v := range arr {
			result = rugo_add(result, v)
		}
		return result, true

	case "flatten":
		result := make([]interface{}, 0)
		for _, v := range arr {
			if inner, ok := v.([]interface{}); ok {
				result = append(result, inner...)
			} else {
				result = append(result, v)
			}
		}
		return interface{}(result), true

	case "uniq":
		seen := make(map[interface{}]bool)
		result := make([]interface{}, 0)
		for _, v := range arr {
			if !seen[v] {
				seen[v] = true
				result = append(result, v)
			}
		}
		return interface{}(result), true

	case "sort_by":
		fn := rugo_to_lambda(args[0], "sort_by")
		cp := make([]interface{}, len(arr))
		copy(cp, arr)
		sort.Slice(cp, func(i, j int) bool {
			return rugo_compare(fn(cp[i]), fn(cp[j])) < 0
		})
		return interface{}(cp), true

	case "flat_map":
		fn := rugo_to_lambda(args[0], "flat_map")
		result := make([]interface{}, 0)
		for _, v := range arr {
			mapped := fn(v)
			if inner, ok := mapped.([]interface{}); ok {
				result = append(result, inner...)
			} else {
				result = append(result, mapped)
			}
		}
		return interface{}(result), true

	case "take":
		n := rugo_to_int(args[0])
		if n > len(arr) {
			n = len(arr)
		}
		if n < 0 {
			n = 0
		}
		result := make([]interface{}, n)
		copy(result, arr[:n])
		return interface{}(result), true

	case "drop":
		n := rugo_to_int(args[0])
		if n > len(arr) {
			n = len(arr)
		}
		if n < 0 {
			n = 0
		}
		result := make([]interface{}, len(arr)-n)
		copy(result, arr[n:])
		return interface{}(result), true

	case "zip":
		other, ok := args[0].([]interface{})
		if !ok {
			panic(".zip() requires an array argument")
		}
		length := len(arr)
		if len(other) < length {
			length = len(other)
		}
		result := make([]interface{}, length)
		for i := 0; i < length; i++ {
			result[i] = interface{}([]interface{}{arr[i], other[i]})
		}
		return interface{}(result), true

	case "chunk":
		size := rugo_to_int(args[0])
		if size <= 0 {
			panic(".chunk() requires a positive size")
		}
		result := make([]interface{}, 0)
		for i := 0; i < len(arr); i += size {
			end := i + size
			if end > len(arr) {
				end = len(arr)
			}
			ch := make([]interface{}, end-i)
			copy(ch, arr[i:end])
			result = append(result, interface{}(ch))
		}
		return interface{}(result), true
	}
	return nil, false
}

// --- Built-in Hash Methods ---

func rugo_hash_method(m map[interface{}]interface{}, method string, args ...interface{}) (interface{}, bool) {
	switch method {
	case "map":
		fn := rugo_to_lambda(args[0], "map")
		result := make([]interface{}, 0, len(m))
		for k, v := range m {
			result = append(result, fn(k, v))
		}
		return interface{}(result), true

	case "filter":
		fn := rugo_to_lambda(args[0], "filter")
		result := make(map[interface{}]interface{})
		for k, v := range m {
			if rugo_to_bool(fn(k, v)) {
				result[k] = v
			}
		}
		return interface{}(result), true

	case "reject":
		fn := rugo_to_lambda(args[0], "reject")
		result := make(map[interface{}]interface{})
		for k, v := range m {
			if !rugo_to_bool(fn(k, v)) {
				result[k] = v
			}
		}
		return interface{}(result), true

	case "each":
		fn := rugo_to_lambda(args[0], "each")
		for k, v := range m {
			fn(k, v)
		}
		return nil, true

	case "reduce":
		if len(args) < 2 {
			panic(".reduce() requires an initial value and a function")
		}
		acc := args[0]
		fn := rugo_to_lambda(args[1], "reduce")
		for k, v := range m {
			acc = fn(acc, k, v)
		}
		return acc, true

	case "find":
		fn := rugo_to_lambda(args[0], "find")
		for k, v := range m {
			if rugo_to_bool(fn(k, v)) {
				return interface{}([]interface{}{k, v}), true
			}
		}
		return nil, true

	case "any":
		fn := rugo_to_lambda(args[0], "any")
		for k, v := range m {
			if rugo_to_bool(fn(k, v)) {
				return true, true
			}
		}
		return false, true

	case "all":
		fn := rugo_to_lambda(args[0], "all")
		for k, v := range m {
			if !rugo_to_bool(fn(k, v)) {
				return false, true
			}
		}
		return true, true

	case "count":
		fn := rugo_to_lambda(args[0], "count")
		n := 0
		for k, v := range m {
			if rugo_to_bool(fn(k, v)) {
				n++
			}
		}
		return n, true

	case "keys":
		result := make([]interface{}, 0, len(m))
		for k := range m {
			result = append(result, k)
		}
		return interface{}(result), true

	case "values":
		result := make([]interface{}, 0, len(m))
		for _, v := range m {
			result = append(result, v)
		}
		return interface{}(result), true

	case "merge":
		other, ok := args[0].(map[interface{}]interface{})
		if !ok {
			panic(".merge() requires a hash argument")
		}
		result := make(map[interface{}]interface{})
		for k, v := range m {
			result[k] = v
		}
		for k, v := range other {
			result[k] = v
		}
		return interface{}(result), true
	}
	return nil, false
}

// --- End Rugo Runtime ---

