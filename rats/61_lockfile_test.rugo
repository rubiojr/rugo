# RATS: Test rugo mod tidy, rugo mod update, and lock file behavior
#
# Starts an in-process git server, then verifies:
# 1. rugo mod tidy generates rugo.lock
# 2. rugo run/build reads lock but does not write it
# 3. rugo run without lock shows hint message
# 4. rugo mod update re-resolves mutable deps
# 5. --frozen flag errors on missing lock entries
# 6. rugo mod tidy prunes unused entries
use "test"
use "web"
use "conv"
use "str"

def base_dir()
  return "/tmp/rats_lockfile"
end

def setup_file()
  bd = base_dir()
  r = test.run("mkdir -p " + bd + "/repos/lockuser/lock-mod.git " + bd + "/work")
  if r["status"] != 0
    puts "DEBUG setup mkdir: " + r["output"]
  end
  r = test.run("git init --bare " + bd + "/repos/lockuser/lock-mod.git")
  if r["status"] != 0
    puts "DEBUG setup git init: " + r["output"]
  end
  r = test.run("git clone " + bd + "/repos/lockuser/lock-mod.git " + bd + "/work")
  if r["status"] != 0
    puts "DEBUG setup git clone: " + r["output"]
  end

  mod_src = <<~RG
    def greet(name)
      return "Hello v1, " + name + "!"
    end
  RG
  test.write_file(bd + "/work/lock-mod.rugo", mod_src)

  r = test.run("cd " + bd + "/work && git config user.email test@test.com && git config user.name test && git add . && git commit -m v1 && git tag v1.0.0")
  if r["status"] != 0
    puts "DEBUG setup v1 commit: " + r["output"]
  end
  r = test.run("cd " + bd + "/work && git push origin HEAD v1.0.0")
  if r["status"] != 0
    puts "DEBUG setup v1 push: " + r["output"]
  end

  # Create a second commit on main (for mutable version testing)
  mod_src2 = <<~RG
    def greet(name)
      return "Hello v2, " + name + "!"
    end
  RG
  test.write_file(bd + "/work/lock-mod.rugo", mod_src2)

  r = test.run("cd " + bd + "/work && git add . && git commit -m v2 && git push origin HEAD")
  if r["status"] != 0
    puts "DEBUG setup v2 push: " + r["output"]
  end

  r = test.run("cd " + bd + "/repos/lockuser/lock-mod.git && git update-server-info")
  if r["status"] != 0
    puts "DEBUG setup update-server-info: " + r["output"]
  end

  web.static("/lockuser/lock-mod.git", bd + "/repos/lockuser/lock-mod.git")
  spawn web.listen(0)
  p = web.port()
  test.write_file(bd + "/port", conv.to_s(p))
end

def teardown_file()
  test.run("rm -rf " + base_dir())
end

# --- Tests ---

rats "mod tidy generates lock file with tagged version"
  tmpdir = test.tmpdir()
  port = str.trim(test.run("cat " + base_dir() + "/port")["output"])
  consumer = <<~RG
    require "localhost:PORT/lockuser/lock-mod@v1.0.0" as "mod"
    puts mod.greet("Rugo")
  RG
  consumer = str.replace(consumer, "PORT", port)
  test.write_file(tmpdir + "/app.rugo", consumer)

  # Run mod tidy to generate lock file
  result = test.run("cd " + tmpdir + " && RUGO_MODULE_DIR=" + tmpdir + "/modules rugo mod tidy")
  if result["status"] != 0
    puts "DEBUG mod-tidy: " + result["output"]
  end
  test.assert_eq(result["status"], 0)

  # Verify rugo.lock was created
  lock_result = test.run("cat " + tmpdir + "/rugo.lock")
  test.assert_eq(lock_result["status"], 0)
  test.assert_contains(lock_result["output"], "localhost:" + port + "/lockuser/lock-mod")
  test.assert_contains(lock_result["output"], "v1.0.0")
end

rats "mod tidy generates lock file with mutable version"
  tmpdir = test.tmpdir()
  port = str.trim(test.run("cat " + base_dir() + "/port")["output"])
  consumer = <<~RG
    require "localhost:PORT/lockuser/lock-mod" as "mod"
    puts mod.greet("Rugo")
  RG
  consumer = str.replace(consumer, "PORT", port)
  test.write_file(tmpdir + "/app.rugo", consumer)

  # Run mod tidy
  result = test.run("cd " + tmpdir + " && RUGO_MODULE_DIR=" + tmpdir + "/modules rugo mod tidy")
  if result["status"] != 0
    puts "DEBUG mod-tidy-mutable: " + result["output"]
  end
  test.assert_eq(result["status"], 0)

  # Verify rugo.lock was created with _default version and a SHA
  lock_result = test.run("cat " + tmpdir + "/rugo.lock")
  test.assert_eq(lock_result["status"], 0)
  test.assert_contains(lock_result["output"], "_default")
end

rats "run does not create lock file"
  tmpdir = test.tmpdir()
  port = str.trim(test.run("cat " + base_dir() + "/port")["output"])
  consumer = <<~RG
    require "localhost:PORT/lockuser/lock-mod@v1.0.0" as "mod"
    puts mod.greet("Rugo")
  RG
  consumer = str.replace(consumer, "PORT", port)
  test.write_file(tmpdir + "/app.rugo", consumer)

  # Run without mod tidy — should work but not create lock file
  # Redirect stderr to /dev/null to avoid hint in output
  result = test.run("RUGO_MODULE_DIR=" + tmpdir + "/modules rugo run " + tmpdir + "/app.rugo 2>/dev/null")
  if result["status"] != 0
    puts "DEBUG run-no-lock: " + result["output"]
  end
  test.assert_eq(result["status"], 0)
  test.assert_eq(result["output"], "Hello v1, Rugo!")

  # Verify no lock file was created
  lock_result = test.run("cat " + tmpdir + "/rugo.lock")
  test.assert_neq(lock_result["status"], 0)
end

rats "run without lock shows hint message"
  tmpdir = test.tmpdir()
  port = str.trim(test.run("cat " + base_dir() + "/port")["output"])
  consumer = <<~RG
    require "localhost:PORT/lockuser/lock-mod@v1.0.0" as "mod"
    puts mod.greet("Rugo")
  RG
  consumer = str.replace(consumer, "PORT", port)
  test.write_file(tmpdir + "/app.rugo", consumer)

  # Create an empty lock file so the hint triggers (stale lock scenario)
  test.write_file(tmpdir + "/rugo.lock", "# rugo.lock — auto-generated, do not edit\n")

  # Run with stale lock — stderr should contain the hint
  result = test.run("RUGO_MODULE_DIR=" + tmpdir + "/modules rugo run " + tmpdir + "/app.rugo 2>&1")
  test.assert_eq(result["status"], 0)
  test.assert_contains(result["output"], "rugo mod tidy")
end

rats "run with lock does not show hint"
  tmpdir = test.tmpdir()
  port = str.trim(test.run("cat " + base_dir() + "/port")["output"])
  consumer = <<~RG
    require "localhost:PORT/lockuser/lock-mod@v1.0.0" as "mod"
    puts mod.greet("Rugo")
  RG
  consumer = str.replace(consumer, "PORT", port)
  test.write_file(tmpdir + "/app.rugo", consumer)

  # First, create lock file with mod tidy
  result = test.run("cd " + tmpdir + " && RUGO_MODULE_DIR=" + tmpdir + "/modules rugo mod tidy")
  test.assert_eq(result["status"], 0)

  # Run with lock — no hint in output
  result = test.run("RUGO_MODULE_DIR=" + tmpdir + "/modules rugo run " + tmpdir + "/app.rugo 2>&1")
  test.assert_eq(result["status"], 0)
  test.assert_contains(result["output"], "Hello v1, Rugo!")
  # Should NOT contain the hint
  if str.contains(result["output"], "rugo mod tidy")
    test.fail("hint should not be shown when lock file exists")
  end
end

rats "locked mutable version uses cached SHA on second run"
  tmpdir = test.tmpdir()
  port = str.trim(test.run("cat " + base_dir() + "/port")["output"])
  consumer = <<~RG
    require "localhost:PORT/lockuser/lock-mod" as "mod"
    puts mod.greet("Rugo")
  RG
  consumer = str.replace(consumer, "PORT", port)
  test.write_file(tmpdir + "/app.rugo", consumer)

  # Create lock file with mod tidy
  result = test.run("cd " + tmpdir + " && RUGO_MODULE_DIR=" + tmpdir + "/modules rugo mod tidy")
  test.assert_eq(result["status"], 0)

  # Read the locked SHA
  lock_content = test.run("cat " + tmpdir + "/rugo.lock")["output"]
  test.assert_contains(lock_content, "_default")

  # Run — should use cached SHA directory, no re-fetch needed
  result = test.run("RUGO_MODULE_DIR=" + tmpdir + "/modules rugo run " + tmpdir + "/app.rugo")
  test.assert_eq(result["status"], 0)
  test.assert_eq(result["output"], "Hello v2, Rugo!")

  # Verify SHA-keyed cache directory exists
  sha_dirs = test.run("ls " + tmpdir + "/modules/localhost:" + port + "/lockuser/lock-mod/ | grep _sha_")
  test.assert_eq(sha_dirs["status"], 0)
end

rats "frozen flag errors when no lock entry exists"
  tmpdir = test.tmpdir()
  port = str.trim(test.run("cat " + base_dir() + "/port")["output"])
  consumer = <<~RG
    require "localhost:PORT/lockuser/lock-mod@v1.0.0" as "mod"
    puts mod.greet("Rugo")
  RG
  consumer = str.replace(consumer, "PORT", port)
  test.write_file(tmpdir + "/app.rugo", consumer)

  # Build with --frozen and no lock file should fail
  result = test.run("RUGO_MODULE_DIR=" + tmpdir + "/modules rugo build --frozen " + tmpdir + "/app.rugo -o " + tmpdir + "/app")
  test.assert_neq(result["status"], 0)
  test.assert_contains(result["output"], "--frozen")
end

rats "frozen flag succeeds with valid lock file"
  tmpdir = test.tmpdir()
  port = str.trim(test.run("cat " + base_dir() + "/port")["output"])
  consumer = <<~RG
    require "localhost:PORT/lockuser/lock-mod@v1.0.0" as "mod"
    puts mod.greet("Rugo")
  RG
  consumer = str.replace(consumer, "PORT", port)
  test.write_file(tmpdir + "/app.rugo", consumer)

  # Generate lock file with mod tidy
  result = test.run("cd " + tmpdir + " && RUGO_MODULE_DIR=" + tmpdir + "/modules rugo mod tidy")
  if result["status"] != 0
    puts "DEBUG frozen-tidy: " + result["output"]
  end
  test.assert_eq(result["status"], 0)

  # Build with frozen should succeed
  result = test.run("RUGO_MODULE_DIR=" + tmpdir + "/modules rugo build --frozen " + tmpdir + "/app.rugo -o " + tmpdir + "/app")
  if result["status"] != 0
    puts "DEBUG frozen-success: " + result["output"]
  end
  test.assert_eq(result["status"], 0)
end

rats "mod tidy records immutable version SHA"
  tmpdir = test.tmpdir()
  port = str.trim(test.run("cat " + base_dir() + "/port")["output"])
  consumer = <<~RG
    require "localhost:PORT/lockuser/lock-mod@v1.0.0" as "mod"
    puts mod.greet("Rugo")
  RG
  consumer = str.replace(consumer, "PORT", port)
  test.write_file(tmpdir + "/app.rugo", consumer)

  result = test.run("cd " + tmpdir + " && RUGO_MODULE_DIR=" + tmpdir + "/modules rugo mod tidy")
  test.assert_eq(result["status"], 0)

  # Lock file should contain the module with v1.0.0 and a 40-char SHA
  lock_content = test.run("cat " + tmpdir + "/rugo.lock")["output"]
  test.assert_contains(lock_content, "v1.0.0")
  # Each non-comment line should have 3 fields
  lines = str.split(lock_content, "\n")
  for line in lines
    line = str.trim(line)
    if line == "" || str.starts_with(line, "#")
      next
    end
    parts = str.split(line, " ")
    test.assert_eq(len(parts), 3)
  end
end

rats "rugo mod update re-resolves mutable _default dependency"
  tmpdir = test.tmpdir()
  port = str.trim(test.run("cat " + base_dir() + "/port")["output"])
  consumer = <<~RG
    require "localhost:PORT/lockuser/lock-mod" as "mod"
    puts mod.greet("Rugo")
  RG
  consumer = str.replace(consumer, "PORT", port)
  test.write_file(tmpdir + "/app.rugo", consumer)

  # Generate lock file with mod tidy
  result = test.run("cd " + tmpdir + " && RUGO_MODULE_DIR=" + tmpdir + "/modules rugo mod tidy")
  test.assert_eq(result["status"], 0)

  # Read the initial SHA from lock
  lock_before = test.run("cat " + tmpdir + "/rugo.lock")["output"]
  test.assert_contains(lock_before, "_default")

  # Push a v3 commit to the repo
  mod_src3 = <<~RG
    def greet(name)
      return "Hello v3, " + name + "!"
    end
  RG
  bd = base_dir()
  test.write_file(bd + "/work/lock-mod.rugo", mod_src3)
  r = test.run("cd " + bd + "/work && git add . && git commit -m v3 && git push origin HEAD")
  if r["status"] != 0
    puts "DEBUG v3 push: " + r["output"]
  end
  r = test.run("cd " + bd + "/repos/lockuser/lock-mod.git && git update-server-info")

  # Run rugo mod update from the directory containing rugo.lock
  result = test.run("cd " + tmpdir + " && RUGO_MODULE_DIR=" + tmpdir + "/modules rugo mod update")
  if result["status"] != 0
    puts "DEBUG mod-update: " + result["output"]
  end
  test.assert_eq(result["status"], 0)

  # Lock file should be updated with new SHA
  lock_after = test.run("cat " + tmpdir + "/rugo.lock")["output"]
  test.assert_contains(lock_after, "_default")

  # Run again — should now get v3
  result = test.run("RUGO_MODULE_DIR=" + tmpdir + "/modules rugo run " + tmpdir + "/app.rugo")
  if result["status"] != 0
    puts "DEBUG post-update run: " + result["output"]
  end
  test.assert_eq(result["status"], 0)
  test.assert_eq(result["output"], "Hello v3, Rugo!")
end

rats "rugo mod update skips immutable versions"
  tmpdir = test.tmpdir()
  port = str.trim(test.run("cat " + base_dir() + "/port")["output"])
  consumer = <<~RG
    require "localhost:PORT/lockuser/lock-mod@v1.0.0" as "mod"
    puts mod.greet("Rugo")
  RG
  consumer = str.replace(consumer, "PORT", port)
  test.write_file(tmpdir + "/app.rugo", consumer)

  # Generate lock file with mod tidy
  result = test.run("cd " + tmpdir + " && RUGO_MODULE_DIR=" + tmpdir + "/modules rugo mod tidy")
  test.assert_eq(result["status"], 0)

  lock_before = test.run("cat " + tmpdir + "/rugo.lock")["output"]

  # Run mod update — should not change the SHA for immutable v1.0.0
  result = test.run("cd " + tmpdir + " && RUGO_MODULE_DIR=" + tmpdir + "/modules rugo mod update")
  test.assert_eq(result["status"], 0)

  lock_after = test.run("cat " + tmpdir + "/rugo.lock")["output"]
  test.assert_eq(lock_before, lock_after)
end

rats "mod tidy prunes unused entries"
  tmpdir = test.tmpdir()
  port = str.trim(test.run("cat " + base_dir() + "/port")["output"])
  consumer = <<~RG
    require "localhost:PORT/lockuser/lock-mod@v1.0.0" as "mod"
    puts mod.greet("Rugo")
  RG
  consumer = str.replace(consumer, "PORT", port)
  test.write_file(tmpdir + "/app.rugo", consumer)

  # Generate lock file with mod tidy
  result = test.run("cd " + tmpdir + " && RUGO_MODULE_DIR=" + tmpdir + "/modules rugo mod tidy")
  test.assert_eq(result["status"], 0)

  lock_result = test.run("cat " + tmpdir + "/rugo.lock")
  test.assert_eq(lock_result["status"], 0)
  test.assert_contains(lock_result["output"], "lock-mod")

  # Remove the remote require from the script
  test.write_file(tmpdir + "/app.rugo", "puts \"no deps\"")

  # Run mod tidy again — should prune the unused entry and remove lock file
  result = test.run("cd " + tmpdir + " && RUGO_MODULE_DIR=" + tmpdir + "/modules rugo mod tidy")
  test.assert_eq(result["status"], 0)

  # Lock file should be removed (no entries left)
  lock_result = test.run("cat " + tmpdir + "/rugo.lock")
  test.assert_neq(lock_result["status"], 0)
end

# --- Edge cases: mod tidy ---

rats "mod tidy in empty directory prints message"
  tmpdir = test.tmpdir()

  result = test.run("cd " + tmpdir + " && rugo mod tidy 2>&1")
  test.assert_eq(result["status"], 0)
  test.assert_contains(result["output"], "no .rugo files")

  # No lock file should be created
  lock_result = test.run("test -f " + tmpdir + "/rugo.lock")
  test.assert_neq(lock_result["status"], 0)
end

rats "mod tidy with no remote deps does not create lock file"
  tmpdir = test.tmpdir()
  test.write_file(tmpdir + "/hello.rugo", "puts \"hello\"")
  test.write_file(tmpdir + "/world.rugo", "puts \"world\"")

  result = test.run("cd " + tmpdir + " && rugo mod tidy")
  test.assert_eq(result["status"], 0)

  # No lock file — no remote deps
  lock_result = test.run("test -f " + tmpdir + "/rugo.lock")
  test.assert_neq(lock_result["status"], 0)
end

rats "mod tidy removes existing lock when no remote deps remain"
  tmpdir = test.tmpdir()
  port = str.trim(test.run("cat " + base_dir() + "/port")["output"])

  # Create a file with remote dep and tidy
  consumer = <<~RG
    require "localhost:PORT/lockuser/lock-mod@v1.0.0" as "mod"
    puts mod.greet("Rugo")
  RG
  consumer = str.replace(consumer, "PORT", port)
  test.write_file(tmpdir + "/app.rugo", consumer)
  result = test.run("cd " + tmpdir + " && RUGO_MODULE_DIR=" + tmpdir + "/modules rugo mod tidy")
  test.assert_eq(result["status"], 0)

  # Verify lock exists
  lock_result = test.run("test -f " + tmpdir + "/rugo.lock")
  test.assert_eq(lock_result["status"], 0)

  # Replace with no-dep file
  test.write_file(tmpdir + "/app.rugo", "puts \"no deps\"")

  # Tidy again — lock should be removed
  result = test.run("cd " + tmpdir + " && RUGO_MODULE_DIR=" + tmpdir + "/modules rugo mod tidy")
  test.assert_eq(result["status"], 0)
  lock_result = test.run("test -f " + tmpdir + "/rugo.lock")
  test.assert_neq(lock_result["status"], 0)
end

rats "mod tidy is idempotent"
  tmpdir = test.tmpdir()
  port = str.trim(test.run("cat " + base_dir() + "/port")["output"])
  consumer = <<~RG
    require "localhost:PORT/lockuser/lock-mod@v1.0.0" as "mod"
    puts mod.greet("Rugo")
  RG
  consumer = str.replace(consumer, "PORT", port)
  test.write_file(tmpdir + "/app.rugo", consumer)

  # Tidy once
  result = test.run("cd " + tmpdir + " && RUGO_MODULE_DIR=" + tmpdir + "/modules rugo mod tidy")
  test.assert_eq(result["status"], 0)
  lock_first = test.run("cat " + tmpdir + "/rugo.lock")["output"]

  # Tidy again — lock should be identical
  result = test.run("cd " + tmpdir + " && RUGO_MODULE_DIR=" + tmpdir + "/modules rugo mod tidy")
  test.assert_eq(result["status"], 0)
  lock_second = test.run("cat " + tmpdir + "/rugo.lock")["output"]

  test.assert_eq(lock_first, lock_second)
end

rats "mod tidy skips files with syntax errors"
  tmpdir = test.tmpdir()
  port = str.trim(test.run("cat " + base_dir() + "/port")["output"])

  # One good file with remote dep
  consumer = <<~RG
    require "localhost:PORT/lockuser/lock-mod@v1.0.0" as "mod"
    puts mod.greet("Rugo")
  RG
  consumer = str.replace(consumer, "PORT", port)
  test.write_file(tmpdir + "/good.rugo", consumer)

  # One broken file
  test.write_file(tmpdir + "/broken.rugo", "def foo(\n  this is broken syntax {{{{")

  # Tidy should warn about broken file but still generate lock from good file
  result = test.run("cd " + tmpdir + " && RUGO_MODULE_DIR=" + tmpdir + "/modules rugo mod tidy 2>&1")
  test.assert_eq(result["status"], 0)
  test.assert_contains(result["output"], "warning: skipping broken.rugo")

  # Lock should exist with the good file's dep
  lock_result = test.run("cat " + tmpdir + "/rugo.lock")
  test.assert_eq(lock_result["status"], 0)
  test.assert_contains(lock_result["output"], "lock-mod")
end

rats "mod tidy with multiple files collects all deps"
  tmpdir = test.tmpdir()
  port = str.trim(test.run("cat " + base_dir() + "/port")["output"])

  # File A: tagged version
  file_a = <<~RG
    require "localhost:PORT/lockuser/lock-mod@v1.0.0" as "mod"
    puts mod.greet("A")
  RG
  file_a = str.replace(file_a, "PORT", port)
  test.write_file(tmpdir + "/a.rugo", file_a)

  # File B: mutable version
  file_b = <<~RG
    require "localhost:PORT/lockuser/lock-mod" as "mod"
    puts mod.greet("B")
  RG
  file_b = str.replace(file_b, "PORT", port)
  test.write_file(tmpdir + "/b.rugo", file_b)

  # File C: no remote deps
  test.write_file(tmpdir + "/c.rugo", "puts \"no deps\"")

  result = test.run("cd " + tmpdir + " && RUGO_MODULE_DIR=" + tmpdir + "/modules rugo mod tidy")
  test.assert_eq(result["status"], 0)

  # Lock should have both the tagged and mutable entries
  lock_content = test.run("cat " + tmpdir + "/rugo.lock")["output"]
  test.assert_contains(lock_content, "v1.0.0")
  test.assert_contains(lock_content, "_default")
end

rats "mod tidy does not scan subdirectories"
  tmpdir = test.tmpdir()
  port = str.trim(test.run("cat " + base_dir() + "/port")["output"])

  # Put a remote-dep file only in a subdirectory
  test.run("mkdir -p " + tmpdir + "/sub")
  consumer = <<~RG
    require "localhost:PORT/lockuser/lock-mod@v1.0.0" as "mod"
    puts mod.greet("Rugo")
  RG
  consumer = str.replace(consumer, "PORT", port)
  test.write_file(tmpdir + "/sub/app.rugo", consumer)

  # Put a no-dep file in the root
  test.write_file(tmpdir + "/hello.rugo", "puts \"hello\"")

  # Tidy from root — should NOT pick up subdirectory file
  result = test.run("cd " + tmpdir + " && RUGO_MODULE_DIR=" + tmpdir + "/modules rugo mod tidy")
  test.assert_eq(result["status"], 0)

  # No lock file — root file has no remote deps
  lock_result = test.run("test -f " + tmpdir + "/rugo.lock")
  test.assert_neq(lock_result["status"], 0)
end

rats "mod tidy preserves existing SHAs for already-locked deps"
  tmpdir = test.tmpdir()
  port = str.trim(test.run("cat " + base_dir() + "/port")["output"])
  consumer = <<~RG
    require "localhost:PORT/lockuser/lock-mod" as "mod"
    puts mod.greet("Rugo")
  RG
  consumer = str.replace(consumer, "PORT", port)
  test.write_file(tmpdir + "/app.rugo", consumer)

  # Tidy to create lock with current SHA
  result = test.run("cd " + tmpdir + " && RUGO_MODULE_DIR=" + tmpdir + "/modules rugo mod tidy")
  test.assert_eq(result["status"], 0)
  lock_before = test.run("cat " + tmpdir + "/rugo.lock")["output"]

  # Capture what the locked version produces
  result = test.run("RUGO_MODULE_DIR=" + tmpdir + "/modules rugo run " + tmpdir + "/app.rugo")
  test.assert_eq(result["status"], 0)
  output_before = result["output"]

  # Push a new commit upstream
  mod_src_new = <<~RG
    def greet(name)
      return "Hello CHANGED, " + name + "!"
    end
  RG
  bd = base_dir()
  test.write_file(bd + "/work/lock-mod.rugo", mod_src_new)
  r = test.run("cd " + bd + "/work && git add . && git commit -m preserve-test && git push origin HEAD")
  test.run("cd " + bd + "/repos/lockuser/lock-mod.git && git update-server-info")

  # Tidy again — should keep the existing SHA, not re-resolve
  result = test.run("cd " + tmpdir + " && RUGO_MODULE_DIR=" + tmpdir + "/modules rugo mod tidy")
  test.assert_eq(result["status"], 0)
  lock_after = test.run("cat " + tmpdir + "/rugo.lock")["output"]

  test.assert_eq(lock_before, lock_after)

  # Run should still produce the same output as before (locked version)
  result = test.run("RUGO_MODULE_DIR=" + tmpdir + "/modules rugo run " + tmpdir + "/app.rugo")
  test.assert_eq(result["status"], 0)
  test.assert_eq(result["output"], output_before)
end

rats "mod tidy handles require with clause"
  tmpdir = test.tmpdir()
  port = str.trim(test.run("cat " + base_dir() + "/port")["output"])

  consumer = <<~RG
    require "localhost:PORT/lockuser/lock-mod@v1.0.0" as "mod"
    puts mod.greet("With")
  RG
  consumer = str.replace(consumer, "PORT", port)
  test.write_file(tmpdir + "/app.rugo", consumer)

  result = test.run("cd " + tmpdir + " && RUGO_MODULE_DIR=" + tmpdir + "/modules rugo mod tidy")
  if result["status"] != 0
    puts "DEBUG tidy-with: " + result["output"]
  end
  test.assert_eq(result["status"], 0)

  # Lock file should exist with the module
  lock_result = test.run("cat " + tmpdir + "/rugo.lock")
  test.assert_eq(lock_result["status"], 0)
  test.assert_contains(lock_result["output"], "lock-mod")
  test.assert_contains(lock_result["output"], "v1.0.0")
end

# --- Edge cases: mod update ---

rats "mod update with no lock file prints message"
  tmpdir = test.tmpdir()

  result = test.run("cd " + tmpdir + " && rugo mod update 2>&1")
  test.assert_eq(result["status"], 0)
  test.assert_contains(result["output"], "no rugo.lock")
end

rats "mod update with empty lock file prints message"
  tmpdir = test.tmpdir()
  test.write_file(tmpdir + "/rugo.lock", "# rugo.lock — auto-generated, do not edit\n")

  result = test.run("cd " + tmpdir + " && rugo mod update 2>&1")
  test.assert_eq(result["status"], 0)
  test.assert_contains(result["output"], "no rugo.lock found or lock file is empty")
end

rats "mod update with nonexistent module is a no-op"
  tmpdir = test.tmpdir()
  port = str.trim(test.run("cat " + base_dir() + "/port")["output"])
  consumer = <<~RG
    require "localhost:PORT/lockuser/lock-mod@v1.0.0" as "mod"
    puts mod.greet("Rugo")
  RG
  consumer = str.replace(consumer, "PORT", port)
  test.write_file(tmpdir + "/app.rugo", consumer)

  # Create lock file
  result = test.run("cd " + tmpdir + " && RUGO_MODULE_DIR=" + tmpdir + "/modules rugo mod tidy")
  test.assert_eq(result["status"], 0)
  lock_before = test.run("cat " + tmpdir + "/rugo.lock")["output"]

  # Update a module that doesn't exist in the lock — should succeed, no changes
  result = test.run("cd " + tmpdir + " && RUGO_MODULE_DIR=" + tmpdir + "/modules rugo mod update nonexistent.com/fake/module")
  test.assert_eq(result["status"], 0)

  lock_after = test.run("cat " + tmpdir + "/rugo.lock")["output"]
  test.assert_eq(lock_before, lock_after)
end

# --- Edge cases: build ---

rats "build does not create lock file"
  tmpdir = test.tmpdir()
  port = str.trim(test.run("cat " + base_dir() + "/port")["output"])
  consumer = <<~RG
    require "localhost:PORT/lockuser/lock-mod@v1.0.0" as "mod"
    puts mod.greet("Rugo")
  RG
  consumer = str.replace(consumer, "PORT", port)
  test.write_file(tmpdir + "/app.rugo", consumer)

  # Build without mod tidy — should work but not create lock file
  result = test.run("RUGO_MODULE_DIR=" + tmpdir + "/modules rugo build " + tmpdir + "/app.rugo -o " + tmpdir + "/app 2>/dev/null")
  if result["status"] != 0
    puts "DEBUG build-no-lock: " + result["output"]
  end
  test.assert_eq(result["status"], 0)

  # Verify no lock file was created
  lock_result = test.run("test -f " + tmpdir + "/rugo.lock")
  test.assert_neq(lock_result["status"], 0)

  # But the binary should work
  result = test.run(tmpdir + "/app")
  test.assert_eq(result["status"], 0)
  test.assert_eq(result["output"], "Hello v1, Rugo!")
end

rats "build --frozen fails when lock is stale"
  tmpdir = test.tmpdir()
  port = str.trim(test.run("cat " + base_dir() + "/port")["output"])

  # Create initial file and tidy
  consumer = <<~RG
    require "localhost:PORT/lockuser/lock-mod@v1.0.0" as "mod"
    puts mod.greet("Rugo")
  RG
  consumer = str.replace(consumer, "PORT", port)
  test.write_file(tmpdir + "/app.rugo", consumer)
  result = test.run("cd " + tmpdir + " && RUGO_MODULE_DIR=" + tmpdir + "/modules rugo mod tidy")
  test.assert_eq(result["status"], 0)

  # Now add a new dep that isn't in the lock (change to mutable version)
  consumer2 = <<~RG
    require "localhost:PORT/lockuser/lock-mod" as "mod"
    puts mod.greet("Rugo")
  RG
  consumer2 = str.replace(consumer2, "PORT", port)
  test.write_file(tmpdir + "/app.rugo", consumer2)

  # Build --frozen should fail because the mutable version isn't in the lock
  result = test.run("RUGO_MODULE_DIR=" + tmpdir + "/modules rugo build --frozen " + tmpdir + "/app.rugo -o " + tmpdir + "/app")
  test.assert_neq(result["status"], 0)
  test.assert_contains(result["output"], "--frozen")
end

# --- Edge cases: hint ---

rats "hint shows only once with multiple unlocked deps"
  tmpdir = test.tmpdir()
  port = str.trim(test.run("cat " + base_dir() + "/port")["output"])

  # File with two requires (tagged and mutable) — both unlocked
  consumer = <<~RG
    require "localhost:PORT/lockuser/lock-mod@v1.0.0" as "mod1"
    require "localhost:PORT/lockuser/lock-mod" as "mod2"
    puts mod1.greet("A")
  RG
  consumer = str.replace(consumer, "PORT", port)
  test.write_file(tmpdir + "/app.rugo", consumer)

  # Create an empty lock file so hints trigger
  test.write_file(tmpdir + "/rugo.lock", "# rugo.lock — auto-generated, do not edit\n")

  # Run — hint should appear exactly once, not twice
  result = test.run("RUGO_MODULE_DIR=" + tmpdir + "/modules rugo run " + tmpdir + "/app.rugo 2>&1")
  test.assert_eq(result["status"], 0)
  # Count occurrences of the hint
  lines = str.split(result["output"], "\n")
  hint_count = 0
  for line in lines
    if str.contains(line, "rugo mod tidy")
      hint_count = hint_count + 1
    end
  end
  test.assert_eq(hint_count, 1)
end

rats "no hint when lock file does not exist"
  tmpdir = test.tmpdir()
  port = str.trim(test.run("cat " + base_dir() + "/port")["output"])
  consumer = <<~RG
    require "localhost:PORT/lockuser/lock-mod@v1.0.0" as "mod"
    puts mod.greet("Rugo")
  RG
  consumer = str.replace(consumer, "PORT", port)
  test.write_file(tmpdir + "/app.rugo", consumer)

  # Run without any lock file — should NOT show hint
  result = test.run("RUGO_MODULE_DIR=" + tmpdir + "/modules rugo run " + tmpdir + "/app.rugo 2>&1")
  test.assert_eq(result["status"], 0)
  test.assert_contains(result["output"], "Hello v1, Rugo!")
  if str.contains(result["output"], "rugo mod tidy")
    test.fail("hint should not appear when no lock file exists")
  end
end

# --- Edge cases: lock file integrity ---

rats "mod tidy with malformed lock file reports error"
  tmpdir = test.tmpdir()
  port = str.trim(test.run("cat " + base_dir() + "/port")["output"])

  consumer = <<~RG
    require "localhost:PORT/lockuser/lock-mod@v1.0.0" as "mod"
    puts mod.greet("Rugo")
  RG
  consumer = str.replace(consumer, "PORT", port)
  test.write_file(tmpdir + "/app.rugo", consumer)

  # Write a malformed lock file (wrong number of fields)
  test.write_file(tmpdir + "/rugo.lock", "this is not a valid lock line\n")

  result = test.run("cd " + tmpdir + " && RUGO_MODULE_DIR=" + tmpdir + "/modules rugo mod tidy 2>&1")
  test.assert_neq(result["status"], 0)
  test.assert_contains(result["output"], "expected 3 fields")
end

rats "mod tidy prunes hand-added stale entries"
  tmpdir = test.tmpdir()
  port = str.trim(test.run("cat " + base_dir() + "/port")["output"])

  consumer = <<~RG
    require "localhost:PORT/lockuser/lock-mod@v1.0.0" as "mod"
    puts mod.greet("Rugo")
  RG
  consumer = str.replace(consumer, "PORT", port)
  test.write_file(tmpdir + "/app.rugo", consumer)

  # Tidy to get the real entry
  result = test.run("cd " + tmpdir + " && RUGO_MODULE_DIR=" + tmpdir + "/modules rugo mod tidy")
  test.assert_eq(result["status"], 0)

  # Hand-add a fake entry to the lock file
  lock_content = test.run("cat " + tmpdir + "/rugo.lock")["output"]
  lock_content = lock_content + "\nfake.com/bogus/module v9.9.9 aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n"
  test.write_file(tmpdir + "/rugo.lock", lock_content)

  # Verify the fake entry is there
  test.assert_contains(test.run("cat " + tmpdir + "/rugo.lock")["output"], "fake.com/bogus/module")

  # Tidy again — fake entry should be pruned
  result = test.run("cd " + tmpdir + " && RUGO_MODULE_DIR=" + tmpdir + "/modules rugo mod tidy")
  test.assert_eq(result["status"], 0)

  lock_after = test.run("cat " + tmpdir + "/rugo.lock")["output"]
  test.assert_contains(lock_after, "lock-mod")
  if str.contains(lock_after, "fake.com/bogus/module")
    test.fail("stale hand-added entry should have been pruned")
  end
end
